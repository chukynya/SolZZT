"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toruslabs";
exports.ids = ["vendor-chunks/@toruslabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACCOUNT_CATEGORY: () => (/* binding */ ACCOUNT_CATEGORY),\n/* harmony export */   ACTIVITY_ACTION: () => (/* binding */ ACTIVITY_ACTION),\n/* harmony export */   ACTIVITY_ACTION_ACCEPT_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_ACCEPT_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_ALL: () => (/* binding */ ACTIVITY_ACTION_ALL),\n/* harmony export */   ACTIVITY_ACTION_BURN: () => (/* binding */ ACTIVITY_ACTION_BURN),\n/* harmony export */   ACTIVITY_ACTION_CANCEL_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_CANCEL_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_CREATE_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_CREATE_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_CREATE_TRUSTLINE: () => (/* binding */ ACTIVITY_ACTION_CREATE_TRUSTLINE),\n/* harmony export */   ACTIVITY_ACTION_RECEIVE: () => (/* binding */ ACTIVITY_ACTION_RECEIVE),\n/* harmony export */   ACTIVITY_ACTION_REMOVE_TRUSTLINE: () => (/* binding */ ACTIVITY_ACTION_REMOVE_TRUSTLINE),\n/* harmony export */   ACTIVITY_ACTION_SEND: () => (/* binding */ ACTIVITY_ACTION_SEND),\n/* harmony export */   ACTIVITY_ACTION_TOPUP: () => (/* binding */ ACTIVITY_ACTION_TOPUP),\n/* harmony export */   ACTIVITY_PERIOD_ALL: () => (/* binding */ ACTIVITY_PERIOD_ALL),\n/* harmony export */   ACTIVITY_PERIOD_MONTH_ONE: () => (/* binding */ ACTIVITY_PERIOD_MONTH_ONE),\n/* harmony export */   ACTIVITY_PERIOD_MONTH_SIX: () => (/* binding */ ACTIVITY_PERIOD_MONTH_SIX),\n/* harmony export */   ACTIVITY_PERIOD_WEEK_ONE: () => (/* binding */ ACTIVITY_PERIOD_WEEK_ONE),\n/* harmony export */   ACTIVITY_STATUS_CANCELLED: () => (/* binding */ ACTIVITY_STATUS_CANCELLED),\n/* harmony export */   ACTIVITY_STATUS_CANCELLING: () => (/* binding */ ACTIVITY_STATUS_CANCELLING),\n/* harmony export */   ACTIVITY_STATUS_PENDING: () => (/* binding */ ACTIVITY_STATUS_PENDING),\n/* harmony export */   ACTIVITY_STATUS_SUCCESSFUL: () => (/* binding */ ACTIVITY_STATUS_SUCCESSFUL),\n/* harmony export */   ACTIVITY_STATUS_UNSUCCESSFUL: () => (/* binding */ ACTIVITY_STATUS_UNSUCCESSFUL),\n/* harmony export */   BROADCAST_CHANNELS: () => (/* binding */ BROADCAST_CHANNELS),\n/* harmony export */   BROADCAST_CHANNELS_MSGS: () => (/* binding */ BROADCAST_CHANNELS_MSGS),\n/* harmony export */   BUTTON_POSITION: () => (/* binding */ BUTTON_POSITION),\n/* harmony export */   BaseBlockTracker: () => (/* binding */ BaseBlockTracker),\n/* harmony export */   BaseController: () => (/* binding */ BaseController),\n/* harmony export */   BaseCurrencyController: () => (/* binding */ BaseCurrencyController),\n/* harmony export */   BaseEmbedController: () => (/* binding */ BaseEmbedController),\n/* harmony export */   BaseKeyringController: () => (/* binding */ BaseKeyringController),\n/* harmony export */   BasePreferencesController: () => (/* binding */ BasePreferencesController),\n/* harmony export */   BaseTransactionStateManager: () => (/* binding */ BaseTransactionStateManager),\n/* harmony export */   BroadcastChannelHandler: () => (/* binding */ BroadcastChannelHandler),\n/* harmony export */   CHAIN_NAMESPACES: () => (/* binding */ CHAIN_NAMESPACES),\n/* harmony export */   COMMUNICATION_JRPC_METHODS: () => (/* binding */ COMMUNICATION_JRPC_METHODS),\n/* harmony export */   COMMUNICATION_NOTIFICATIONS: () => (/* binding */ COMMUNICATION_NOTIFICATIONS),\n/* harmony export */   CONFIRMATION_STRATEGY: () => (/* binding */ CONFIRMATION_STRATEGY),\n/* harmony export */   CommunicationWindowManager: () => (/* binding */ CommunicationWindowManager),\n/* harmony export */   ControllerEvents: () => (/* binding */ ControllerEvents),\n/* harmony export */   DEFAULT_PREFERENCES: () => (/* binding */ DEFAULT_PREFERENCES),\n/* harmony export */   FEATURES_CONFIRM_WINDOW: () => (/* binding */ FEATURES_CONFIRM_WINDOW),\n/* harmony export */   FEATURES_DEFAULT_POPUP_WINDOW: () => (/* binding */ FEATURES_DEFAULT_POPUP_WINDOW),\n/* harmony export */   FEATURES_DEFAULT_WALLET_WINDOW: () => (/* binding */ FEATURES_DEFAULT_WALLET_WINDOW),\n/* harmony export */   FEATURES_PROVIDER_CHANGE_WINDOW: () => (/* binding */ FEATURES_PROVIDER_CHANGE_WINDOW),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   PAYMENT_PROVIDER: () => (/* binding */ PAYMENT_PROVIDER),\n/* harmony export */   POPUP_LOADED: () => (/* binding */ POPUP_LOADED),\n/* harmony export */   POPUP_RESULT: () => (/* binding */ POPUP_RESULT),\n/* harmony export */   PROVIDER_JRPC_METHODS: () => (/* binding */ PROVIDER_JRPC_METHODS),\n/* harmony export */   PROVIDER_NOTIFICATIONS: () => (/* binding */ PROVIDER_NOTIFICATIONS),\n/* harmony export */   PopupHandler: () => (/* binding */ PopupHandler),\n/* harmony export */   PopupStoreChannel: () => (/* binding */ PopupStoreChannel),\n/* harmony export */   PopupWithBcHandler: () => (/* binding */ PopupWithBcHandler),\n/* harmony export */   RedirectHandler: () => (/* binding */ RedirectHandler),\n/* harmony export */   SETUP_COMPLETE: () => (/* binding */ SETUP_COMPLETE),\n/* harmony export */   StreamWindow: () => (/* binding */ StreamWindow),\n/* harmony export */   TRANSACTION_TYPES: () => (/* binding */ TRANSACTION_TYPES),\n/* harmony export */   TX_EVENTS: () => (/* binding */ TX_EVENTS),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   UserError: () => (/* binding */ UserError),\n/* harmony export */   WSApiClient: () => (/* binding */ WSApiClient),\n/* harmony export */   addressSlicer: () => (/* binding */ addressSlicer),\n/* harmony export */   authServer: () => (/* binding */ authServer),\n/* harmony export */   broadcastChannelOptions: () => (/* binding */ broadcastChannelOptions),\n/* harmony export */   cloneDeep: () => (/* binding */ cloneDeep),\n/* harmony export */   concatSig: () => (/* binding */ concatSig),\n/* harmony export */   createChangeProviderMiddlewareMiddleware: () => (/* binding */ createChangeProviderMiddlewareMiddleware),\n/* harmony export */   createCommunicationMiddleware: () => (/* binding */ createCommunicationMiddleware),\n/* harmony export */   createEventEmitterProxy: () => (/* binding */ createEventEmitterProxy),\n/* harmony export */   createFetchConfigFromReq: () => (/* binding */ createFetchConfigFromReq),\n/* harmony export */   createFetchMiddleware: () => (/* binding */ createFetchMiddleware),\n/* harmony export */   createGenericJRPCMiddleware: () => (/* binding */ createGenericJRPCMiddleware),\n/* harmony export */   createInflightCacheMiddleware: () => (/* binding */ createInflightCacheMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createOriginMiddleware: () => (/* binding */ createOriginMiddleware),\n/* harmony export */   createRandomId: () => (/* binding */ createRandomId),\n/* harmony export */   createSwappableProxy: () => (/* binding */ createSwappableProxy),\n/* harmony export */   createTopupMiddleware: () => (/* binding */ createTopupMiddleware),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatSmallNumbers: () => (/* binding */ formatSmallNumbers),\n/* harmony export */   formatTime: () => (/* binding */ formatTime),\n/* harmony export */   getCustomDeviceInfo: () => (/* binding */ getCustomDeviceInfo),\n/* harmony export */   getHeaders: () => (/* binding */ getHeaders),\n/* harmony export */   getPopupFeatures: () => (/* binding */ getPopupFeatures),\n/* harmony export */   getTxStatusText: () => (/* binding */ getTxStatusText),\n/* harmony export */   handleRedirectParameters: () => (/* binding */ handleRedirectParameters),\n/* harmony export */   hashMessage: () => (/* binding */ hashMessage),\n/* harmony export */   intToHex: () => (/* binding */ intToHex),\n/* harmony export */   isUnauthorizedError: () => (/* binding */ isUnauthorizedError),\n/* harmony export */   omitBy: () => (/* binding */ omitBy),\n/* harmony export */   padWithZeroes: () => (/* binding */ padWithZeroes),\n/* harmony export */   pickBy: () => (/* binding */ pickBy),\n/* harmony export */   randomId: () => (/* binding */ randomId),\n/* harmony export */   signChallenge: () => (/* binding */ signChallenge),\n/* harmony export */   signMessage: () => (/* binding */ signMessage),\n/* harmony export */   significantDigits: () => (/* binding */ significantDigits),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   timeout: () => (/* binding */ timeout$1),\n/* harmony export */   transactionMatchesNetwork: () => (/* binding */ transactionMatchesNetwork),\n/* harmony export */   verifySignedChallenge: () => (/* binding */ verifySignedChallenge)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/esm/index.js\");\n/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/openlogin-utils */ \"(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @toruslabs/broadcast-channel */ \"(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bowser */ \"(ssr)/./node_modules/bowser/src/bowser.js\");\n/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jwt-decode */ \"(ssr)/./node_modules/jwt-decode/build/esm/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */ class BaseController extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.SafeEventEmitter {\n    /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */ constructor({ config = {}, state = {} }){\n        super();\n        // Use assign since generics can't be spread: https://git.io/vpRhY\n        /**\n     * Default options used to configure this controller\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultConfig\", {});\n        /**\n     * Default state set on this controller\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultState\", {});\n        /**\n     * Determines if listeners are notified of state changes\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"disabled\", false);\n        /**\n     * Name of this controller used during composition\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"BaseController\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"initialConfig\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"initialState\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"internalConfig\", this.defaultConfig);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"internalState\", this.defaultState);\n        this.initialState = state;\n        this.initialConfig = config;\n    }\n    /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */ get config() {\n        return this.internalConfig;\n    }\n    /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */ get state() {\n        return this.internalState;\n    }\n    /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */ configure(config, overwrite = false, fullUpdate = true) {\n        if (fullUpdate) {\n            this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n            for(const key in this.internalConfig){\n                if (typeof this.internalConfig[key] !== \"undefined\") {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    this[key] = this.internalConfig[key];\n                }\n            }\n        } else {\n            for(const key in config){\n                /* istanbul ignore else */ if (typeof this.internalConfig[key] !== \"undefined\") {\n                    this.internalConfig[key] = config[key];\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n    /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */ update(state, overwrite = false) {\n        this.internalState = overwrite ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, state) : _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.internalState), state);\n        this.emit(\"store\", this.internalState);\n    }\n    /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */ initialize() {\n        this.internalState = this.defaultState;\n        this.internalConfig = this.defaultConfig;\n        this.configure(this.initialConfig);\n        this.update(this.initialState);\n        return this;\n    }\n}\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue)=>accumulator + currentValue;\nconst blockTrackerEvents = [\n    \"sync\",\n    \"latest\"\n];\nclass BaseBlockTracker extends BaseController {\n    constructor({ config = {}, state = {} }){\n        super({\n            config,\n            state\n        });\n        // config\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"BaseBlockTracker\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_blockResetTimeout\", void 0);\n        this.defaultState = {\n            _currentBlock: {\n                idempotencyKey: \"\"\n            },\n            _isRunning: false\n        };\n        this.defaultConfig = {\n            blockResetDuration: 20 * sec\n        };\n        this.initialize();\n        // bind functions for internal use\n        this._onNewListener = this._onNewListener.bind(this);\n        this._onRemoveListener = this._onRemoveListener.bind(this);\n        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        this._setupInternalEvents();\n    }\n    isRunning() {\n        return this.state._isRunning;\n    }\n    getCurrentBlock() {\n        return this.state._currentBlock;\n    }\n    async getLatestBlock() {\n        // return if available\n        if (this.state._currentBlock.idempotencyKey) {\n            return this.state._currentBlock;\n        }\n        // wait for a new latest block\n        const latestBlock = await new Promise((resolve)=>{\n            this.once(\"latest\", (block)=>{\n                if (block) {\n                    resolve(block);\n                }\n            });\n        });\n        // return newly set current block\n        return latestBlock;\n    }\n    // dont allow module consumer to remove our internal event listeners\n    removeAllListeners(eventName) {\n        if (eventName) {\n            super.removeAllListeners(eventName);\n        } else {\n            super.removeAllListeners();\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener();\n        return this;\n    }\n    /**\n   * To be implemented in subclass.\n   */ _start() {\n    // default behavior is noop\n    }\n    /**\n   * To be implemented in subclass.\n   */ _end() {\n    // default behavior is noop\n    }\n    _newPotentialLatest(newBlock) {\n        const currentBlock = this.state._currentBlock;\n        // only update if block number is higher\n        if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    }\n    _setupInternalEvents() {\n        // first remove listeners for idempotency\n        this.removeListener(\"newListener\", this._onNewListener);\n        this.removeListener(\"removeListener\", this._onRemoveListener);\n        // then add them\n        this.on(\"removeListener\", this._onRemoveListener);\n        this.on(\"newListener\", this._onNewListener);\n    }\n    _onNewListener() {\n        this._maybeStart();\n    }\n    _onRemoveListener() {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    }\n    _maybeStart() {\n        if (this.state._isRunning) {\n            return;\n        }\n        this.state._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        this._start();\n    }\n    _maybeEnd() {\n        if (!this.state._isRunning) {\n            return;\n        }\n        this.state._isRunning = false;\n        this._setupBlockResetTimeout();\n        this._end();\n    }\n    _getBlockTrackerEventCount() {\n        return blockTrackerEvents.map((eventName)=>this.listenerCount(eventName)).reduce(calculateSum);\n    }\n    _setCurrentBlock(newBlock) {\n        const oldBlock = this.state._currentBlock;\n        this.update({\n            _currentBlock: newBlock\n        });\n        this.emit(\"latest\", newBlock);\n        this.emit(\"sync\", {\n            oldBlock,\n            newBlock\n        });\n    }\n    _setupBlockResetTimeout() {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    }\n    _cancelBlockResetTimeout() {\n        if (this._blockResetTimeout) {\n            clearTimeout(this._blockResetTimeout);\n        }\n    }\n    _resetCurrentBlock() {\n        this.update({\n            _currentBlock: {\n                idempotencyKey: \"\"\n            }\n        });\n    }\n}\nconst filterNoop = ()=>true;\nconst internalEvents = [\n    \"newListener\",\n    \"removeListener\"\n];\nconst externalEventFilter = (name)=>!internalEvents.includes(name);\nfunction getRawListeners(eventEmitter, name) {\n    // prefer native\n    return typeof eventEmitter.rawListeners !== \"undefined\" ? eventEmitter.rawListeners(name) : eventEmitter.listeners(name);\n}\nfunction createEventEmitterProxy(initialTarget, opts) {\n    // parse options\n    const finalOpts = opts || {};\n    let eventFilter = finalOpts.eventFilter || filterNoop;\n    if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n    if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n    let target = initialTarget;\n    let setTarget = (newTarget)=>{\n        const oldTarget = target;\n        target = newTarget;\n        oldTarget.eventNames().filter(eventFilter).forEach((name)=>{\n            getRawListeners(oldTarget, name).forEach((handler)=>{\n                newTarget.on(name, handler);\n            });\n        });\n        // remove old listeners\n        oldTarget.removeAllListeners();\n    };\n    const proxy = new Proxy({}, {\n        get: (_, name)=>{\n            // override `setTarget` access\n            if (name === \"setTarget\") return setTarget;\n            return target[name];\n        },\n        set: (_, name, value)=>{\n            // allow `setTarget` overrides\n            if (name === \"setTarget\") {\n                setTarget = value;\n                return true;\n            }\n            target[name] = value;\n            return true;\n        }\n    });\n    return proxy;\n}\nfunction createSwappableProxy(initialTarget) {\n    let target = initialTarget;\n    let setTarget = (newTarget)=>{\n        target = newTarget;\n    };\n    const proxy = new Proxy({}, {\n        get: (_, name)=>{\n            // override `setTarget` access\n            if (name === \"setTarget\") return setTarget;\n            return target[name];\n        },\n        set: (_, name, value)=>{\n            // allow `setTarget` overrides\n            if (name === \"setTarget\") {\n                setTarget = value;\n                return true;\n            }\n            target[name] = value;\n            return true;\n        }\n    });\n    return proxy;\n}\n// every ten minutes\nconst POLLING_INTERVAL = 600000;\nclass BaseCurrencyController extends BaseController {\n    constructor({ config = {}, state }){\n        super({\n            config,\n            state\n        });\n        this.defaultState = {\n            currentCurrency: \"usd\",\n            conversionRate: 0,\n            conversionDate: \"N/A\",\n            nativeCurrency: \"ETH\"\n        };\n        this.defaultConfig = {\n            pollInterval: POLLING_INTERVAL\n        };\n        this.initialize();\n    }\n    //\n    // PUBLIC METHODS\n    //\n    getNativeCurrency() {\n        return this.state.nativeCurrency;\n    }\n    setNativeCurrency(nativeCurrency) {\n        this.update({\n            nativeCurrency,\n            ticker: nativeCurrency\n        });\n    }\n    getCurrentCurrency() {\n        return this.state.currentCurrency;\n    }\n    setCurrentCurrency(currentCurrency) {\n        this.update({\n            currentCurrency\n        });\n    }\n    /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */ getConversionRate() {\n        return this.state.conversionRate;\n    }\n    setConversionRate(conversionRate) {\n        this.update({\n            conversionRate\n        });\n    }\n    /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */ getConversionDate() {\n        return this.state.conversionDate;\n    }\n    setConversionDate(conversionDate) {\n        this.update({\n            conversionDate\n        });\n    }\n}\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n    height: 660,\n    width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n    height: 740,\n    width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n    height: 700,\n    width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n    height: 700,\n    width: 450\n};\nconst POPUP_LOADED = \"popup_loaded\";\nconst POPUP_RESULT = \"popup_result\";\nconst SETUP_COMPLETE = \"setup_complete\";\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nconst ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\nconst ACTIVITY_ACTION_CREATE_TRUSTLINE = \"walletActivity.createTrustline\";\nconst ACTIVITY_ACTION_REMOVE_TRUSTLINE = \"walletActivity.removeTrustline\";\nconst ACTIVITY_ACTION_CREATE_NFT_OFFER = \"walletActivity.createNftOffer\";\nconst ACTIVITY_ACTION_ACCEPT_NFT_OFFER = \"walletActivity.acceptNftOffer\";\nconst ACTIVITY_ACTION_CANCEL_NFT_OFFER = \"walletActivity.cancelNftOffer\";\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\nconst COMMUNICATION_NOTIFICATIONS = {\n    IFRAME_STATUS: \"iframe_status\",\n    // Tell embed to close the window\n    CLOSE_WINDOW: \"close_window\",\n    USER_LOGGED_IN: \"user_logged_in\",\n    USER_LOGGED_OUT: \"user_logged_out\"\n};\nconst COMMUNICATION_JRPC_METHODS = {\n    LOGOUT: \"logout\",\n    WALLET_INSTANCE_ID: \"wallet_instance_id\",\n    USER_INFO: \"user_info\",\n    SET_PROVIDER: \"set_provider\",\n    TOPUP: \"topup\",\n    IFRAME_STATUS: \"iframe_status\",\n    // user has closed the window from embed's side\n    CLOSED_WINDOW: \"closed_window\",\n    WINDOW_BLOCKED: \"window_blocked\",\n    GET_PROVIDER_STATE: \"get_provider_state\",\n    LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\",\n    SHOW_WALLET_CONNECT: \"show_wallet_connect\",\n    SHOW_CHECKOUT: \"show_checkout\",\n    SHOW_WALLET_UI: \"show_wallet_ui\",\n    LOGIN_WITH_SESSION_ID: \"login_with_session_id\"\n};\nconst PROVIDER_JRPC_METHODS = {\n    GET_PROVIDER_STATE: \"wallet_get_provider_state\"\n};\nconst PROVIDER_NOTIFICATIONS = {\n    ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n    CHAIN_CHANGED: \"wallet_chain_changed\",\n    UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\n};\nconst BROADCAST_CHANNELS = {\n    REDIRECT_CHANNEL: \"redirect_channel\",\n    PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n    TRANSACTION_CHANNEL: \"torus_channel\",\n    MESSAGE_CHANNEL: \"torus_message_channel\",\n    WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n    WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n    WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n    WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n    THEME_CHANGE: \"theme_change_channel\",\n    TOP_UP_CHANNEL: \"top_up_channel\"\n};\nconst BROADCAST_CHANNELS_MSGS = {\n    LOGOUT: \"logout\",\n    ACCOUNT_IMPORTED: \"account_imported\",\n    SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n    NETWORK_CHANGE: \"network_change\",\n    SET_THEME: \"set_theme\"\n};\nlet ControllerEvents = /*#__PURE__*/ function(ControllerEvents) {\n    ControllerEvents[\"UserUnauthorized\"] = \"user.unauthorized\";\n    return ControllerEvents;\n}({});\nfunction createChangeProviderMiddlewareMiddleware({ changeProvider }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n        if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n        response.result = await changeProvider(request);\n    });\n}\nfunction createTopupMiddleware({ topup }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n        if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n        response.result = await topup(request);\n    });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== targetMethod) return next();\n        if (!handler) throw new Error(`CommunicationMiddleware - ${targetMethod} not provided`);\n        const result = await handler(request);\n        if (!result) {\n            return next();\n        }\n        response.result = result;\n        return undefined;\n    });\n}\nfunction createCommunicationMiddleware(providerHandlers) {\n    const { getUserInfo, getWalletInstanceId, topup, logout, changeProvider, setIFrameStatus, handleWindowRpc, getProviderState, loginWithPrivateKey, showWalletConnect, showCheckout, showWalletUi, showWindowBlockAlert, loginWithSessionId } = providerHandlers;\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.mergeMiddleware)([\n        createChangeProviderMiddlewareMiddleware({\n            changeProvider\n        }),\n        createTopupMiddleware({\n            topup\n        }),\n        (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createScaffoldMiddleware)({\n            [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n            [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n            [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n            [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n            // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n            [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n            [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState,\n            [COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT]: showWalletConnect,\n            [COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT]: showCheckout,\n            [COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI]: showWalletUi,\n            [COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED]: showWindowBlockAlert\n        }),\n        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey),\n        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_SESSION_ID, loginWithSessionId)\n    ]);\n}\nclass BaseEmbedController extends BaseController {\n    constructor({ config = {}, state }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_communicationProviderProxy\", void 0);\n        this.defaultState = {\n            isIFrameFullScreen: true,\n            oauthModalVisibility: false,\n            loginInProgress: false,\n            dappMetadata: {\n                name: \"\",\n                icon: \"\"\n            },\n            web3AuthClientId: \"\",\n            web3AuthNetwork: \"mainnet\",\n            whiteLabel: null,\n            confirmationStrategy: \"popup\"\n        };\n        this.initialize();\n    }\n    /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */ initializeProvider(handlers) {\n        const engine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.JRPCEngine();\n        const communicationMiddleware = createCommunicationMiddleware(handlers);\n        engine.push(communicationMiddleware);\n        const communicationProvider = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.providerFromEngine)(engine);\n        this.setCommunicationProvider(communicationProvider);\n    }\n    setCommunicationProvider(communicationProvider) {\n        if (this._communicationProviderProxy) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this._communicationProviderProxy.setTarget(communicationProvider);\n        } else {\n            this._communicationProviderProxy = createSwappableProxy(communicationProvider);\n        }\n    }\n}\nclass CommunicationWindowManager extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.SafeEventEmitter {\n    constructor(...args){\n        super(...args);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleWindowRpc\", (request, response, next, end)=>{\n            const { method, params } = request;\n            if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n                const { windowId } = params;\n                // I've been informed that a window has been closed\n                this.emit(`${windowId}:closed`);\n                response.result = true;\n                end();\n            } else {\n                next();\n            }\n        });\n    }\n}\nconst BUTTON_POSITION = {\n    BOTTOM_LEFT: \"bottom-left\",\n    TOP_LEFT: \"top-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    TOP_RIGHT: \"top-right\"\n};\nconst CONFIRMATION_STRATEGY = {\n    POPUP: \"popup\",\n    MODAL: \"modal\",\n    AUTO_APPROVE: \"auto-approve\",\n    DEFAULT: \"default\"\n};\n/**\n * State change callbacks\n */ /**\n * Base controller configuration\n */ /**\n * Base state representation\n */ const LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\",\n    SMS_PASSWORDLESS: \"sms_passwordless\"\n};\n/**\n * {@label loginProviderType}\n */ const PAYMENT_PROVIDER = {\n    MOONPAY: \"moonpay\",\n    WYRE: \"wyre\",\n    RAMPNETWORK: \"rampnetwork\",\n    XANPOOL: \"xanpool\",\n    MERCURYO: \"mercuryo\",\n    TRANSAK: \"transak\"\n};\nfunction omitBy(object, predicate) {\n    // Create a new object to store the results\n    const result = {};\n    // Iterate over all own properties of the object\n    for (const [key, value] of Object.entries(object)){\n        if (!predicate(value, key)) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\nfunction pickBy(object, predicate) {\n    // Create a new object to store the results\n    const result = {};\n    for (const [key, value] of Object.entries(object)){\n        if (predicate(value, key)) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\nfunction cloneDeep(object) {\n    try {\n        return structuredClone(object);\n    } catch (error) {\n        return JSON.parse(JSON.stringify(object));\n    }\n}\nconst authServer = \"https://authjs.web3auth.io\";\nconst signChallenge = async (payload, chainNamespace)=>{\n    const t = chainNamespace === \"solana\" ? \"sip99\" : \"eip191\";\n    const header = {\n        t\n    };\n    const network = chainNamespace === \"solana\" ? \"solana\" : \"ethereum\";\n    const data = {\n        payload,\n        header,\n        network\n    };\n    const res = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${authServer}/siww/get`, data);\n    if (!res.success) {\n        throw new Error(\"Failed to authenticate user, Please reach out to Web3Auth Support team\");\n    }\n    return res.challenge;\n};\nconst verifySignedChallenge = async (chainNamespace, signedMessage, challenge, issuer, sessionTime, clientId, web3AuthNetwork, audience, additionalMetadata)=>{\n    var _window$location;\n    const t = chainNamespace === \"solana\" ? \"sip99\" : \"eip191\";\n    const sigData = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n        signature: {\n            s: signedMessage,\n            t\n        },\n        message: challenge,\n        issuer,\n        audience: audience || ( false ? 0 : \"com://reactnative\"),\n        timeout: sessionTime\n    }, additionalMetadata || {});\n    const idTokenRes = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${authServer}/siww/verify`, sigData, {\n        headers: {\n            client_id: clientId,\n            wallet_provider: issuer,\n            web3auth_network: web3AuthNetwork\n        }\n    });\n    if (!idTokenRes.success) {\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"Failed to authenticate user, ,message verification failed\", idTokenRes.error);\n        throw new Error(\"Failed to authenticate user, ,message verification failed\");\n    }\n    return idTokenRes.token;\n};\nconst getTxStatusText = (txStatus)=>{\n    switch(txStatus){\n        case \"rejected\":\n        case \"unapproved\":\n        case \"failed\":\n            return ACTIVITY_STATUS_UNSUCCESSFUL;\n        case \"confirmed\":\n            return ACTIVITY_STATUS_SUCCESSFUL;\n        case \"submitted\":\n            return ACTIVITY_STATUS_PENDING;\n        case \"cancelled\":\n            return ACTIVITY_STATUS_CANCELLED;\n        default:\n            return \"\";\n    }\n};\n/**\n * General utility functions\n */ function intToHex(i) {\n    const hex = i.toString(16);\n    return `0x${hex}`;\n}\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */ const randomId = ()=>Math.random().toString(36).slice(2);\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */ function padWithZeroes(hexString, targetLength) {\n    if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n    }\n    if (targetLength < 0) {\n        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n    }\n    return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */ function concatSig(v, r, s) {\n    const rSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.fromSigned)(r);\n    const sSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.fromSigned)(s);\n    const vSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt)(v);\n    const rStr = padWithZeroes(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.toUnsigned)(rSig)).toString(\"hex\"), 64);\n    const sStr = padWithZeroes(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.toUnsigned)(sSig)).toString(\"hex\"), 64);\n    const vStr = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.stripHexPrefix)((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bigIntToHex)(vSig));\n    return (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.addHexPrefix)(rStr.concat(sStr, vStr));\n}\nfunction timeout$1(duration) {\n    return new Promise((resolve)=>{\n        const timeoutRef = window.setTimeout(()=>{\n            resolve();\n            window.clearTimeout(timeoutRef);\n        }, duration);\n    });\n}\nconst getHeaders = (jwt, publicAddress)=>{\n    return {\n        headers: {\n            Authorization: `Bearer ${jwt}`,\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"public-address\": publicAddress\n        }\n    };\n};\n/**\n * Text/number formatting utilities\n */ const formatSmallNumbers = (number, currency = \"usd\", noTilde = false)=>{\n    const finalNumber = bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isBigNumber(number) ? number.toNumber() : number;\n    if (!Number.isFinite(finalNumber)) return \"\";\n    const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n    const tilde = value > 0 ? \"~ \" : \"\";\n    return `${currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde}${Number(value)} ${currency.toUpperCase()}`;\n};\nconst addressSlicer = (address, sliceLength = 5)=>{\n    if (!address) return \"\";\n    if (address.length < 11) {\n        return address;\n    }\n    if (typeof address !== \"string\") return \"\";\n    return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;\n};\nconst significantDigits = (number, perc = false, length_ = 2)=>{\n    let input = !bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isBigNumber(number) ? new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](number) : number;\n    if (input.isZero()) return input;\n    if (perc) {\n        input = input.times(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](100));\n    }\n    let depth;\n    if (input.gte(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](1))) {\n        depth = length_;\n    } else {\n        depth = length_ - 1 + Math.ceil(Math.log10(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](\"1\").div(input).toNumber()));\n    }\n    const shift = new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](10).pow(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](depth));\n    const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n    return roundedNumber;\n};\nconst formatDate = (inputDate)=>{\n    const monthList = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ];\n    const date = new Date(inputDate);\n    const day = date.getDate();\n    const month = monthList[date.getMonth()];\n    const year = date.getFullYear();\n    return `${day} ${month} ${year}`;\n};\nconst formatTime = (time)=>{\n    return new Date(time).toTimeString().slice(0, 8);\n};\n/**\n * Network utilities\n */ const transactionMatchesNetwork = (transaction, chainId)=>{\n    if (typeof transaction.chainId !== \"undefined\") {\n        return transaction.chainId === chainId;\n    }\n    return false;\n};\n/**\n * Signing utils\n */ const hashMessage = (message)=>{\n    const bufferedMessage = Buffer.from(message, \"utf8\");\n    const el = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.hashPersonalMessage)(bufferedMessage);\n    return Buffer.from(el);\n};\nconst signMessage = async (privateKey, data)=>{\n    const privKey = Buffer.from(privateKey, \"hex\");\n    const message = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.stripHexPrefix)(data);\n    const msgSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.ecsign)(Buffer.from(message, \"hex\"), privKey);\n    const rawMsgSig = concatSig(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bigIntToBytes)(msgSig.v)), Buffer.from(msgSig.r), Buffer.from(msgSig.s));\n    return rawMsgSig;\n};\n/**\n * popup handler utils\n */ function getPopupFeatures({ width: w, height: h }) {\n    // Fixes dual-screen position                             Most browsers      Firefox\n    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n    const systemZoom = 1; // No reliable estimate\n    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n    return features;\n}\nconst broadcastChannelOptions = {\n    type: \"server\",\n    // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n    webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n};\nfunction getCustomDeviceInfo() {\n    var _navigator;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n        return {\n            browser: \"Brave\"\n        };\n    }\n}\nclass UserError extends Error {\n}\nconst handleRedirectParameters = (hash, queryParameters)=>{\n    const hashParameters = {};\n    const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);\n    hashUrl.searchParams.forEach((value, key)=>{\n        hashParameters[key] = value;\n    });\n    let instanceParameters = {};\n    let error = \"\";\n    if (!queryParameters.windowId) {\n        if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n            instanceParameters = JSON.parse((0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.safeatob)(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n            error = hashParameters.error_description || hashParameters.error || error;\n        } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n            instanceParameters = JSON.parse((0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.safeatob)(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n            if (queryParameters.error) error = queryParameters.error;\n        }\n    }\n    return {\n        error,\n        instanceParameters,\n        hashParameters\n    };\n};\nfunction sleep(ms) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms);\n    });\n}\nconst isUnauthorizedError = (error)=>{\n    return error instanceof Response && error.status === 401;\n};\nclass BaseKeyringController extends BaseController {\n    constructor({ config = {}, state }){\n        var _state$wallets;\n        super({\n            config,\n            state\n        });\n        this.defaultState = {\n            wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\n        };\n        this.initialize();\n    }\n    // for signing auth message\n    async signAuthMessage(address, message) {\n        const keyring = this.state.wallets.find((x)=>x.address === address);\n        if (!keyring) {\n            throw new Error(\"key does not exist\");\n        }\n        const hashedMessage = hashMessage(message).toString(\"hex\");\n        const rawMessageSig = await signMessage(keyring.privateKey, hashedMessage);\n        return rawMessageSig;\n    }\n}\nconst RETRIABLE_ERRORS = [\n    // ignore server overload errors\n    \"Gateway timeout\",\n    \"ETIMEDOUT\",\n    // ignore server sent html error pages\n    // or truncated json responses\n    \"failed to parse response body\",\n    // ignore errors where http req failed to establish\n    \"Failed to fetch\"\n];\nfunction checkForHttpErrors(fetchRes) {\n    // check for errors\n    switch(fetchRes.status){\n        case 405:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.methodNotFound();\n        case 418:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n                message: `Request is being rate limited.`,\n                data: {\n                    cause: fetchRes\n                }\n            });\n        case 503:\n        case 504:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n                message: `Gateway timeout. The request took too long to process.` + `This can happen when querying over too wide a block range.`\n            });\n    }\n}\nfunction timeout(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction parseResponse(fetchRes, body) {\n    // check for error code\n    if (fetchRes.status !== 200) {\n        throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n            message: `Non-200 status code: '${fetchRes.status}'`,\n            data: body\n        });\n    }\n    // check for rpc error\n    if (body.error) {\n        throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n            data: body.error\n        });\n    }\n    // return successful result\n    return body.result;\n}\nfunction createFetchConfigFromReq({ req, rpcTarget, originHttpHeaderKey }) {\n    const parsedUrl = new URL(rpcTarget);\n    // prepare payload\n    // copy only canonical json rpc properties\n    const payload = {\n        id: req.id,\n        jsonrpc: req.jsonrpc,\n        method: req.method,\n        params: req.params\n    };\n    // extract 'origin' parameter from request\n    const originDomain = req.origin;\n    // serialize request body\n    const serializedPayload = JSON.stringify(payload);\n    // configure fetch params\n    const fetchParams = {\n        method: \"POST\",\n        headers: {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\"\n        },\n        body: serializedPayload\n    };\n    // optional: add request origin as header\n    if (originHttpHeaderKey && originDomain) {\n        fetchParams.headers[originHttpHeaderKey] = originDomain;\n    }\n    return {\n        fetchUrl: parsedUrl.href,\n        fetchParams\n    };\n}\nfunction createFetchMiddleware({ rpcTarget, originHttpHeaderKey }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (req, res, _next)=>{\n        const { fetchUrl, fetchParams } = createFetchConfigFromReq({\n            req,\n            rpcTarget,\n            originHttpHeaderKey\n        });\n        // attempt request multiple times\n        const maxAttempts = 5;\n        const retryInterval = 1000;\n        for(let attempt = 0; attempt < maxAttempts; attempt++){\n            try {\n                const fetchRes = await fetch(fetchUrl, fetchParams);\n                // check for http errrors\n                checkForHttpErrors(fetchRes);\n                // parse response body\n                const fetchBody = await fetchRes.json();\n                const result = parseResponse(fetchRes, fetchBody);\n                // set result and exit retry loop\n                res.result = result;\n                return;\n            } catch (err) {\n                const errMsg = (err.message || err).toString();\n                const isRetriable = RETRIABLE_ERRORS.some((phrase)=>errMsg.includes(phrase));\n                // re-throw error if not retriable\n                if (!isRetriable) {\n                    throw err;\n                }\n            }\n            // delay before retrying\n            await timeout(retryInterval);\n        }\n    });\n}\nfunction deferredPromise() {\n    let resolve;\n    const promise = new Promise((_resolve)=>{\n        resolve = _resolve;\n    });\n    return {\n        resolve,\n        promise\n    };\n}\nfunction createInflightCacheMiddleware({ cacheIdentifierForRequest }) {\n    const inflightRequests = {};\n    async function createActiveRequestHandler(res, activeRequestHandlers) {\n        const { resolve, promise } = deferredPromise();\n        activeRequestHandlers.push((handledRes)=>{\n            // append a copy of the result and error to the response\n            res.result = cloneDeep(handledRes.result);\n            res.error = cloneDeep(handledRes.error);\n            resolve();\n        });\n        return promise;\n    }\n    function handleActiveRequest(res, activeRequestHandlers) {\n        // use setTimeout so we can resolve our original request first\n        setTimeout(()=>{\n            activeRequestHandlers.forEach((handler)=>{\n                try {\n                    handler(res);\n                } catch (err) {\n                    // catch error so all requests are handled correctly\n                    loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err);\n                }\n            });\n        });\n    }\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (req, res, next)=>{\n        // allow cach to be skipped if so specified\n        if (req.skipCache) {\n            return next();\n        }\n        // get cacheId, if cacheable\n        const cacheId = cacheIdentifierForRequest(req);\n        // if not cacheable, skip\n        if (!cacheId) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Request is not cacheable, proceeding. req = %o\", req);\n            return next();\n        }\n        // check for matching requests\n        let activeRequestHandlers = inflightRequests[cacheId];\n        // if found, wait for the active request to be handled\n        if (activeRequestHandlers) {\n            // setup the response listener and wait for it to be called\n            // it will handle copying the result and request fields\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Running %i handler(s) for request %o\", activeRequestHandlers.length, req);\n            await createActiveRequestHandler(res, activeRequestHandlers);\n            return undefined;\n        }\n        // setup response handler array for subsequent requests\n        activeRequestHandlers = [];\n        inflightRequests[cacheId] = activeRequestHandlers;\n        // allow request to be handled normally\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Carrying original request forward %o\", req);\n        await next();\n        // clear inflight requests\n        delete inflightRequests[cacheId];\n        // schedule activeRequestHandlers to be handled\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Running %i collected handler(s) for request %o\", activeRequestHandlers.length, req);\n        handleActiveRequest(res, activeRequestHandlers);\n        // complete\n        return undefined;\n    });\n}\nfunction createLoggerMiddleware(options) {\n    return function loggerMiddleware(request, response, next) {\n        next((callback)=>{\n            if (response.error) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().warn(\"Error in RPC response:\\n\", response);\n            }\n            if (request.isTorusInternal) return;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`RPC (${options.origin}):`, request, \"->\", response);\n            callback();\n        });\n    };\n}\nfunction createOriginMiddleware(options) {\n    return function originMiddleware(request, _, next) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        request.origin = options.origin;\n        next();\n    };\n}\nconst createRandomId = ()=>Math.random().toString(36).substring(2);\nconst CHAIN_NAMESPACES = {\n    EIP155: \"eip155\",\n    SOLANA: \"solana\",\n    CASPER: \"casper\",\n    XRPL: \"xrpl\",\n    OTHER: \"other\"\n};\n// eip155 for all evm chains\n/**\n * Custom network properties\n * @example isEIP1559Compatible: true etc.\n */ /**\n *\n */ class BroadcastChannelHandler {\n    constructor(channelPrefix, instanceId){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"bc\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"channel\", void 0);\n        const queryParameters = new URLSearchParams(window.location.search);\n        const windowId = queryParameters.get(\"windowId\");\n        this.channel = `${channelPrefix}_${instanceId}_${windowId}`;\n        this.bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(this.channel, broadcastChannelOptions);\n    }\n    getMessageFromChannel() {\n        return new Promise((resolve, reject)=>{\n            this.bc.addEventListener(\"message\", async (ev)=>{\n                this.bc.close();\n                if (ev.error) {\n                    reject(ev.error);\n                } else {\n                    resolve(ev.data);\n                }\n            });\n            this.bc.postMessage({\n                data: {\n                    type: POPUP_LOADED\n                }\n            });\n        });\n    }\n}\nclass StreamWindow extends BaseController {\n    constructor({ config, state = {} }){\n        super({\n            config,\n            state\n        });\n        // if window has been closed by users\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"closed\", false);\n        this.initialize();\n    }\n    async open() {\n        return new Promise((resolve, reject)=>{\n            const { communicationEngine, communicationWindowManager } = this.config;\n            let popupSuccess = false;\n            communicationWindowManager.once(`${this.state.windowId}:closed`, ()=>{\n                this.closed = true;\n            });\n            // Window is not open yet\n            if (!this.state.windowId) {\n                // since, we're opening window now, no need to tell window anything\n                this.update({\n                    windowId: randomId()\n                });\n                if (typeof this.config.handleWindowBlockAlert !== \"function\") reject(new Error(\"handleWindowBlockAlert is not a function\"));\n                communicationWindowManager.once(`${this.state.windowId}:iframe-opened`, ()=>{\n                    // this means iframe is full screen now\n                    // there might be multiple block alerts at a time. so, we don't set iframe to close after handling this here\n                    this.config.handleWindowBlockAlert({\n                        windowId: this.state.windowId,\n                        finalUrl: this.state.url.href\n                    }).then(resolve).catch(reject);\n                });\n                // Tell the other party to maximize the iframe\n                communicationEngine.emit(\"notification\", {\n                    method: COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS,\n                    params: {\n                        isFullScreen: true,\n                        rid: this.state.windowId\n                    }\n                });\n            } else {\n                // this is a pre-opened window. so, we need to tell it to redirect to correct url. it's currently waiting on /redirect and uses `RedirectHandler` code\n                // Send this window with `windowId` the url to open via bc\n                const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.config.instanceId}_${this.state.windowId}`;\n                const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n                bc.addEventListener(\"message\", async (ev)=>{\n                    try {\n                        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                        const { error } = ev;\n                        if (error) {\n                            // Popup says some error. so, we say it's not really opened\n                            reject(new Error(error));\n                            return;\n                        }\n                        const { message } = ev.data;\n                        if (message === POPUP_LOADED) {\n                            popupSuccess = true;\n                            await bc.postMessage({\n                                data: {\n                                    url: this.state.url.href,\n                                    message: \"\" // No need of a msg\n                                }\n                            });\n                            resolve(this);\n                            bc.close();\n                        }\n                    } catch (error) {\n                        reject(error);\n                        bc.close();\n                        // Something went wrong. so, we close that window\n                        this.close();\n                    }\n                });\n                // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n                // we need backoff strategy\n                // we need to wait for first attempt to succeed/fail until the second attempt\n                // If we get 429, we need to wait for a while and then try again\n                const postMsg = async ()=>{\n                    // this never throws\n                    const localResponse = await bc.postMessage({\n                        data: {\n                            message: SETUP_COMPLETE\n                        }\n                    });\n                    return localResponse;\n                };\n                let currentDelay = bc.type === \"server\" ? 1000 : 200;\n                const recursiveFn = async ()=>{\n                    if (!popupSuccess && !this.closed) {\n                        const localResponse = await postMsg();\n                        if (bc.type === \"server\") {\n                            const serverResponse = localResponse;\n                            if (serverResponse.status >= 400) {\n                                // We need to wait for a while and then try again\n                                currentDelay = Math.round(currentDelay * 1.5);\n                            }\n                        }\n                        await sleep(currentDelay);\n                        await recursiveFn();\n                    }\n                };\n                recursiveFn();\n            }\n        });\n    }\n    close() {\n        const { communicationEngine } = this.config;\n        communicationEngine.emit(\"notification\", {\n            method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n            params: {\n                windowId: this.state.windowId\n            }\n        });\n    }\n}\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler. \n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\n  StreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/ /**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */ class PopupHandler extends BaseController {\n    constructor({ config, state }){\n        super({\n            config,\n            state\n        });\n        // this.id = randomId()\n        // Add in dapp storage key to all popups as a hash parameter\n        this.defaultConfig = {\n            features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n            target: \"_blank\",\n            communicationEngine: null,\n            communicationWindowManager: null,\n            timeout: 30000,\n            instanceId: \"\",\n            handleWindowBlockAlert: null\n        };\n        this.defaultState = {\n            windowTimer: null,\n            window: null,\n            iClosedWindow: false,\n            windowId: \"\",\n            url: state.url\n        };\n        this.initialize();\n        this._setupTimer();\n    }\n    async open() {\n        // if window is already open\n        const { target, features, communicationEngine, communicationWindowManager } = this.config;\n        const { windowId, url } = this.state;\n        // No window has been pre-opened\n        if (!windowId) {\n            // try to open a window first\n            let localWindow = window.open(url.href, target, features);\n            let finalWindowId = \"\";\n            if (!localWindow) {\n                // if it's blocked, open StreamWindow\n                const streamWindow = new StreamWindow({\n                    config: {\n                        communicationEngine,\n                        communicationWindowManager,\n                        instanceId: this.config.instanceId,\n                        handleWindowBlockAlert: this.config.handleWindowBlockAlert\n                    },\n                    state: {\n                        url\n                    }\n                });\n                streamWindow.open();\n                finalWindowId = streamWindow.state.windowId;\n                localWindow = streamWindow;\n            }\n            this.update({\n                window: localWindow,\n                windowId: finalWindowId || randomId()\n            });\n            return;\n        }\n        // A window has been pre-opened with a query parameter `windowId`\n        const localWindow = new StreamWindow({\n            config: {\n                communicationEngine,\n                communicationWindowManager,\n                instanceId: this.config.instanceId,\n                handleWindowBlockAlert: this.config.handleWindowBlockAlert\n            },\n            state: {\n                url,\n                windowId\n            }\n        });\n        this.update({\n            window: localWindow,\n            windowId: localWindow.state.windowId\n        });\n        await localWindow.open();\n    }\n    close() {\n        this.update({\n            iClosedWindow: true\n        });\n        const { window: window1 } = this.state;\n        if (window1) window1.close();\n    }\n    _setupTimer() {\n        const timer = window.setInterval(()=>{\n            const { window: window1, windowTimer, iClosedWindow } = this.state;\n            if (window1 && window1.closed) {\n                if (windowTimer) clearInterval(windowTimer);\n                setTimeout(()=>{\n                    if (!iClosedWindow) {\n                        this.emit(\"close\");\n                    }\n                    this.update({\n                        iClosedWindow: false,\n                        window: null\n                    });\n                }, this.config.timeout);\n            }\n            if (window1 === null && windowTimer) clearInterval(windowTimer);\n        }, 500);\n        this.update({\n            windowTimer: timer\n        });\n    }\n}\n// Always listening channels. Hence, no window id\nclass PopupStoreChannel {\n    constructor({ instanceId, handleLogout, handleAccountImport, handleNetworkChange, handleSelectedAddressChange, handleThemeChange }){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleLogout\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleAccountImport\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleNetworkChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleThemeChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleSelectedAddressChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceId\", void 0);\n        this.instanceId = instanceId;\n        this.handleLogout = handleLogout;\n        this.handleAccountImport = handleAccountImport;\n        this.handleNetworkChange = handleNetworkChange;\n        this.handleSelectedAddressChange = handleSelectedAddressChange;\n        this.handleThemeChange = handleThemeChange;\n    }\n    setupStoreChannels() {\n        this.logoutChannel();\n        this.importAccountChannel();\n        this.networkChangeChannel();\n        this.selectedAddressChangeChannel();\n        this.themeChangedChannel();\n    }\n    logoutChannel() {\n        const logoutChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        logoutChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"received logout message\", ev);\n            if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Logging Out\");\n                this.handleLogout();\n            }\n        });\n    }\n    importAccountChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data2;\n            if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n                var _ev$data3;\n                this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\n            }\n        });\n    }\n    networkChangeChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data4;\n            if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n                var _ev$data5;\n                this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\n            }\n        });\n    }\n    themeChangedChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.THEME_CHANGE}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data6;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info({\n                ev\n            });\n            if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n                var _ev$data7;\n                this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);\n            }\n        });\n    }\n    selectedAddressChangeChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data8;\n            if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n                var _ev$data9;\n                this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);\n            }\n        });\n    }\n}\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */ class PopupWithBcHandler extends PopupHandler {\n    constructor({ config, state, channelPrefix }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"channelPrefix\", void 0);\n        this.channelPrefix = channelPrefix;\n    }\n    /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */ handle(successExtraFn) {\n        const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;\n        const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n        return new Promise((resolve, reject)=>{\n            const closeListener = ()=>{\n                bc.close();\n                reject(new UserError(\"user closed popup\"));\n                this.removeListener(\"close\", closeListener);\n            };\n            this.on(\"close\", closeListener);\n            bc.addEventListener(\"message\", async (ev)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                try {\n                    const { error, data } = ev;\n                    if (error) {\n                        reject(new Error(error));\n                        return;\n                    }\n                    if (successExtraFn) await successExtraFn.call(this, data);\n                    resolve(data);\n                } catch (error) {\n                    reject(error);\n                } finally{\n                    bc.close();\n                    this.close();\n                }\n            });\n            this.open().then(()=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`opened window ${bc.name}`);\n                // Opened window. yay.  let the bc events do their job\n                return undefined;\n            }).catch((err)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err, \"something went wrong while opening window\");\n                reject(err);\n            });\n        });\n    }\n    /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */ handleWithHandshake(payload, successExtraFn) {\n        const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;\n        const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n        return new Promise((resolve, reject)=>{\n            const closeListener = ()=>{\n                bc.close();\n                reject(new UserError(\"user closed popup\"));\n                this.removeListener(\"close\", closeListener);\n            };\n            this.on(\"close\", closeListener);\n            bc.addEventListener(\"message\", async (ev)=>{\n                try {\n                    loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                    const { error, data } = ev;\n                    if (error) {\n                        reject(new Error(error));\n                        return;\n                    }\n                    // Do handshake\n                    const { type = \"\" } = data;\n                    if (type === POPUP_LOADED) {\n                        // Hack with generic to use the same type for both send and receive\n                        await bc.postMessage({\n                            data: payload\n                        });\n                    } else if (type === POPUP_RESULT) {\n                        if (successExtraFn) await successExtraFn.call(this, data);\n                        resolve(data);\n                        // Must only close the bc after result is done\n                        bc.close();\n                        this.close();\n                    }\n                } catch (error) {\n                    reject(error);\n                    bc.close();\n                    this.close();\n                }\n            });\n            this.open().then(()=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`opened window ${bc.name}`);\n                // Opened window. yay.  let the bc events do their job\n                return undefined;\n            }).catch((err)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err, \"something went wrong while opening window\");\n                reject(err);\n            });\n        });\n    }\n}\nclass RedirectHandler {\n    // private hashParameters: Record<string, string>;\n    constructor(instanceId){\n        // private error: string;\n        // this is sessionid post login\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceId\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"finalQueryParams\", {});\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceParameters\", void 0);\n        const { hash } = window.location;\n        const queryParameters = new URLSearchParams(window.location.search);\n        queryParameters.forEach((value, key)=>{\n            this.finalQueryParams[key] = value;\n        });\n        const { instanceParameters } = handleRedirectParameters(hash, this.finalQueryParams);\n        // this.error = error;\n        this.instanceParameters = instanceParameters;\n        // this.hashParameters = hashParameters;\n        this.instanceId = instanceId;\n    }\n    async handle() {\n        return new Promise((resolve, reject)=>{\n            const { finalQueryParams, instanceParameters } = this;\n            let bc;\n            try {\n                // used for login case. there's no windowId here\n                // if (!finalQueryParams.windowId) {\n                //   bc = new BroadcastChannel(`${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${instanceParameters.instanceId}`, broadcastChannelOptions);\n                //   bc.addEventListener(\"message\", async (ev) => {\n                //     if (ev.error) {\n                //       reject(ev.error);\n                //       window.close();\n                //     } else {\n                //       resolve();\n                //       bc.close();\n                //       log.info(\"posted\", { finalQueryParams, hashParameters, instanceParameters });\n                //     }\n                //   });\n                //   bc.postMessage({\n                //     data: {\n                //       instanceParams: instanceParameters,\n                //       hashParams: hashParameters,\n                //       queryParams: finalQueryParams,\n                //     },\n                //     error,\n                //   });\n                //   setTimeout(() => {\n                //     resolve();\n                //     window.location.href = window.location.origin + window.location.search + window.location.hash;\n                //   }, 5000);\n                // } else {\n                const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.instanceId || instanceParameters.instanceId}_${finalQueryParams.windowId || instanceParameters.windowId}`;\n                bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n                bc.addEventListener(\"message\", async (ev)=>{\n                    const { url, message } = ev.data;\n                    if (url) {\n                        resolve();\n                        window.location.href = url;\n                    } else if (message === SETUP_COMPLETE) {\n                        await bc.postMessage({\n                            data: {\n                                windowId: finalQueryParams.windowId,\n                                message: POPUP_LOADED\n                            }\n                        });\n                    }\n                    if (ev.error && ev.error !== \"\") {\n                        loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(ev.error);\n                        resolve();\n                        bc.close();\n                    }\n                });\n            // }\n            } catch (err) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(err, \"something went wrong\");\n                reject(err);\n                if (bc) bc.close();\n                window.close();\n            }\n        });\n    }\n}\nvar HTTP_METHOD = /*#__PURE__*/ function(HTTP_METHOD) {\n    HTTP_METHOD[HTTP_METHOD[\"GET\"] = 0] = \"GET\";\n    HTTP_METHOD[HTTP_METHOD[\"POST\"] = 1] = \"POST\";\n    HTTP_METHOD[HTTP_METHOD[\"PUT\"] = 2] = \"PUT\";\n    HTTP_METHOD[HTTP_METHOD[\"PATCH\"] = 3] = \"PATCH\";\n    HTTP_METHOD[HTTP_METHOD[\"DELETE\"] = 4] = \"DELETE\";\n    return HTTP_METHOD;\n}(HTTP_METHOD || {});\nconst constructAuthHeaders = ({ jwtToken, publicAddress })=>{\n    return {\n        headers: {\n            Authorization: `Bearer ${jwtToken}`,\n            \"public-address\": publicAddress\n        }\n    };\n};\nconst withUnauthorizedHandler = async (fn, emitter)=>{\n    try {\n        const response = await fn();\n        return response;\n    } catch (e) {\n        if (isUnauthorizedError(e)) {\n            emitter.emit(ControllerEvents.UserUnauthorized);\n        }\n        throw e;\n    }\n};\nconst jwtTokenExpired = (jwt)=>{\n    const decoded = (0,jwt_decode__WEBPACK_IMPORTED_MODULE_9__.jwtDecode)(jwt);\n    const jwtExpiry = decoded.exp * 1000;\n    const currentTime = new Date().getTime();\n    return currentTime >= jwtExpiry;\n};\nconst WSApiClient = (baseApiUrl, emitter)=>{\n    const authRequest = (method, url, data, authCredentials, customOptions)=>{\n        if (jwtTokenExpired(authCredentials.jwtToken)) {\n            emitter.emit(ControllerEvents.UserUnauthorized);\n            // eslint-disable-next-line @typescript-eslint/no-throw-literal\n            throw new Response(null, {\n                status: 401,\n                statusText: \"Unauthorized\"\n            });\n        }\n        const headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }, constructAuthHeaders(authCredentials));\n        if (method === HTTP_METHOD.GET) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.get)(url, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.POST) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.PUT) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.put)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.PATCH) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.patch)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.DELETE) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.remove)(url, data, headers, customOptions), emitter);\n        }\n    };\n    return {\n        authGet: (url, authCredentials, customOptions)=>authRequest(HTTP_METHOD.GET, `${baseApiUrl}/${url}`, {}, authCredentials, customOptions),\n        authPost: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.POST, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authPut: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.PUT, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authPatch: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.PATCH, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authRemove: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.DELETE, `${baseApiUrl}/${url}`, data, authCredentials, customOptions)\n    };\n};\nconst ACTIVITY_ACTION = {\n    ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n    ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n    ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n    ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\n};\nconst ACCOUNT_CATEGORY = {\n    NORMAL: \"normal\",\n    THRESHOLD: \"threshold\",\n    IMPORTED: \"imported\",\n    // we have private key here\n    APP_SCOPED: \"app_scoped\",\n    ACCOUNT_ABSTRACTION: \"account_abstraction\",\n    EXTERNAL: \"external\",\n    // like metamask, wallet connect\n    MPC: \"mpc\",\n    SFA: \"sfa\"\n};\n/**\n * Preferences controller state\n */ /**\n * @param address - address of the user\n * @param jwtToken - if jwt token already exists, it will be used instead of fetching from backend\n * @param calledFromEmbed - if called from embed\n * @param userInfo - optional user info\n * @param rehydrate - Rehydrate the preferences from the local storage\n */ // By default, poll every 3 minutes\nconst DEFAULT_INTERVAL = 180 * 1000;\nconst DEFAULT_PREFERENCES = {\n    selectedCurrency: \"USD\",\n    theme: \"dark\",\n    locale: \"en\",\n    accountType: ACCOUNT_CATEGORY.NORMAL,\n    contacts: [],\n    jwtToken: \"\",\n    fetchedPastTx: [],\n    pastTransactions: [],\n    paymentTx: [],\n    defaultPublicAddress: \"\",\n    customTokens: [],\n    customNfts: [],\n    crashReport: true,\n    userInfo: {\n        aggregateVerifier: \"\",\n        email: \"\",\n        name: \"\",\n        profileImage: \"\",\n        typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n        verifier: \"\",\n        verifierId: \"\"\n    }\n};\n/**\n * Controller that stores shared settings and exposes convenience methods\n */ class BasePreferencesController extends BaseController {\n    /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */ constructor({ config, state, defaultPreferences, signAuthMessage, validateSignMessage }){\n        super({\n            config,\n            state\n        });\n        /**\n     * Name of this controller used during composition\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"PreferencesController\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"iframeOrigin\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"wsApiClient\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"signAuthMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"validateSignMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultPreferences\", void 0);\n        if (!config.api) {\n            throw new Error(\"PreferencesController - no api specified in config.\");\n        }\n        this.defaultState = {\n            identities: {},\n            selectedAddress: \"\",\n            lastErrorMessage: \"\",\n            lastSuccessMessage: \"\"\n        };\n        this.defaultConfig = {\n            api: config.api,\n            pollInterval: DEFAULT_INTERVAL\n        };\n        this.initialize();\n        this.defaultPreferences = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, DEFAULT_PREFERENCES), defaultPreferences);\n        this.signAuthMessage = signAuthMessage;\n        this.validateSignMessage = validateSignMessage;\n        this.wsApiClient = WSApiClient(this.config.api, this);\n    }\n    setIframeOrigin(origin) {\n        this.iframeOrigin = origin;\n    }\n    getAddressState(address) {\n        const selectedAddress = address || this.state.selectedAddress;\n        return this.state.identities[selectedAddress];\n    }\n    /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */ setSelectedAddress(selectedAddress) {\n        this.update({\n            selectedAddress\n        });\n    }\n    async getUser(address) {\n        const user = await this.wsApiClient.authGet(\"user?fetchTx=false\", this.authCredentials(address), {\n            useAPIKey: true\n        });\n        return user.data;\n    }\n    async createUser(params) {\n        const { selectedCurrency, theme, verifier, verifierId, locale, address, idToken, type, web3AuthNetwork } = params;\n        const userPayload = {\n            default_currency: selectedCurrency,\n            theme,\n            verifier,\n            verifier_id: verifierId,\n            locale,\n            idToken,\n            account_type: type,\n            web3auth_network: web3AuthNetwork\n        };\n        await this.wsApiClient.authPost(\"user\", userPayload, this.authCredentials(address), {\n            useAPIKey: true\n        });\n        this.updateState({\n            theme,\n            defaultPublicAddress: address,\n            selectedCurrency,\n            locale,\n            accountType: type\n        }, address);\n    }\n    async storeUserLogin(params) {\n        const { verifierId, verifier, options, address, idToken, web3AuthClientId, web3AuthNetwork, sessionPubKey, loginMode } = params;\n        if (!options.rehydrate) {\n            const browser = bowser__WEBPACK_IMPORTED_MODULE_8__[\"default\"].getParser(window.navigator.userAgent);\n            const specialBrowser = getCustomDeviceInfo();\n            const recordLoginPayload = {\n                os: browser.getOSName(),\n                os_version: browser.getOSVersion() || \"unidentified\",\n                browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\n                browser_version: browser.getBrowserVersion() || \"unidentified\",\n                platform: browser.getPlatform().type || \"desktop\",\n                hostname: this.iframeOrigin,\n                verifier,\n                verifier_id: verifierId,\n                idToken,\n                web3auth_client_id: web3AuthClientId,\n                web3auth_network: web3AuthNetwork,\n                session_pub_key: sessionPubKey,\n                login_mode: loginMode\n            };\n            await this.wsApiClient.authPost(\"user/recordLogin\", recordLoginPayload, this.authCredentials(address), {\n                useAPIKey: true\n            });\n        }\n    }\n    async setCrashReport(isEnabled) {\n        var _this$getAddressState;\n        if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                enable_crash_reporter: isEnabled\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                crashReport: isEnabled\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async setUserTheme(theme) {\n        var _this$getAddressState2;\n        if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                theme\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                theme\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async setUserLocale(locale) {\n        var _this$getAddressState3;\n        if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                locale\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                locale\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to set locale\", error);\n            return false;\n        }\n    }\n    async setSelectedCurrency(payload) {\n        var _this$getAddressState4;\n        if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                default_currency: payload.selectedCurrency\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                selectedCurrency: payload.selectedCurrency\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async addContact(contact) {\n        try {\n            var _this$getAddressState5;\n            const response = await this.wsApiClient.authPost(\"contact\", contact, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                contacts: [\n                    ...((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || [],\n                    response.data\n                ]\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to add contact\", error);\n            return false;\n        }\n    }\n    async deleteContact(contactId) {\n        try {\n            var _this$getAddressState6;\n            const response = await this.wsApiClient.authRemove(`contact/${contactId}`, {}, this.authCredentials(), {\n                useAPIKey: true\n            });\n            const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter((contact)=>contact.id !== response.data.id);\n            if (finalContacts) this.updateState({\n                contacts: [\n                    ...finalContacts\n                ]\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to delete contact\", error);\n            return false;\n        }\n    }\n    async revokeDiscord(idToken) {\n        try {\n            const resp = await this.wsApiClient.authPost(\"revoke/discord\", {\n                token: idToken\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(resp);\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n        }\n    }\n    async patchPastTx(body, address) {\n        try {\n            const response = await this.wsApiClient.authPatch(\"transaction\", body, this.authCredentials(address), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"successfully patched\", response);\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to patch tx\", error);\n        }\n    }\n    async postPastTx(tx, address) {\n        try {\n            const response = await this.wsApiClient.authPost(\"transaction\", tx, this.authCredentials(address), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"successfully posted tx\", response);\n            return response;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error, \"unable to insert transaction\");\n        }\n    }\n    async getWalletOrders(address) {\n        try {\n            const response = await this.wsApiClient.authGet(\"transaction\", this.authCredentials(address), {\n                useAPIKey: true\n            });\n            return response.success ? response.data ? response.data : [] : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get wallet orders tx\", error);\n            return [];\n        }\n    }\n    async getTopUpOrders(address) {\n        try {\n            const response = await this.wsApiClient.authGet(\"transaction\", this.authCredentials(address), {\n                useAPIKey: true\n            });\n            return response.data || [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to fetch past Top up orders\", error);\n        }\n    }\n    async getBillBoardData() {\n        try {\n            const response = await this.wsApiClient.authGet(\"billboard\", this.authCredentials(), {\n                useAPIKey: true\n            });\n            return response.success ? response.data : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get billboard data\", error);\n            return [];\n        }\n    }\n    async getMessageForSigning(publicAddress, web3AuthIdToken) {\n        const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/message`, {\n            public_address: publicAddress,\n            id_token: web3AuthIdToken\n        }, {}, {\n            useAPIKey: true\n        });\n        return response.message;\n    }\n    async getTwitterId(payload) {\n        const res = await this.wsApiClient.authGet(`twitter?screen_name=${payload.nick}`, this.authCredentials(), {\n            useAPIKey: true\n        });\n        return `${payload.typeOfLogin.toLowerCase()}|${res.data.toString()}`;\n    }\n    async sendEmail(payload) {\n        return this.wsApiClient.authPost(\"transaction/sendemail\", payload.emailObject, this.authCredentials(), {\n            useAPIKey: true\n        });\n    }\n    async refreshJwt() {\n        const address = this.state.selectedAddress;\n        const messageToSign = await this.getMessageForSigning(address);\n        await this.validateSignMessage(messageToSign);\n        const signedMessage = await this.signAuthMessage(address, messageToSign);\n        const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, {\n            challenge: messageToSign,\n            public_address: address,\n            signed_message: signedMessage\n        }, {}, {\n            useAPIKey: true\n        });\n        this.updateState({\n            jwtToken: response.token\n        }, address);\n    }\n    async getDappList() {\n        try {\n            const response = await this.wsApiClient.authGet(\"dapps\", this.authCredentials(), {\n                useAPIKey: true\n            });\n            return response.success ? response.data : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get dapps list\", error);\n            return [];\n        }\n    }\n    /**\n   * Strategy\n   * For account type: threshold, normal (web3auth login)\n   * idToken from web3auth login must be present. We use it directly\n   *\n   * For account type: app_scoped, IMPORTED\n   * idToken from web3auth login must be present. We request a message for signing using the idToken\n   * and sign it using the private key of the account. We then send the signed message to the backend\n   * to verify the signature and return a new jwtToken that includes the app_scoped address\n   *\n   * For account type: Account abstraction\n   * idToken from web3auth login must be present. We use it to exchange for a new jwtToken.\n   * Because backend can derive AA address from public address and issue this token easily.\n   *\n   * For account type: external\n   * idToken from web3auth `authenticateUser` (siww) login must be present. We use it directly\n   */ async init(params) {\n        const { address, userInfo, idToken, metadata = {}, type } = params;\n        if (this.getAddressState(address)) return;\n        let jwtToken;\n        switch(type){\n            case ACCOUNT_CATEGORY.IMPORTED:\n                {\n                    if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                    const messageToSign = await this.getMessageForSigning(address, idToken);\n                    await this.validateSignMessage(messageToSign);\n                    const signedMessage = await this.signAuthMessage(address, messageToSign);\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        challenge: messageToSign,\n                        account_type: type,\n                        public_address: address,\n                        signed_message: signedMessage,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.EXTERNAL:\n                {\n                    if (!idToken) throw new Error(\"SIWW idToken must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        account_type: type,\n                        public_address: address,\n                        id_token: idToken,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.ACCOUNT_ABSTRACTION:\n                {\n                    if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        public_address: address,\n                        id_token: idToken,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId,\n                        account_type: type\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.MPC:\n            case ACCOUNT_CATEGORY.SFA:\n                {\n                    if (!metadata.signatures) throw new Error(\"MPC signatures must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        public_address: address,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId,\n                        account_type: type\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.NORMAL:\n            case ACCOUNT_CATEGORY.THRESHOLD:\n            case ACCOUNT_CATEGORY.APP_SCOPED:\n            default:\n                if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                jwtToken = idToken;\n                break;\n        }\n        this.updateState({\n            jwtToken,\n            userInfo,\n            accountType: type !== null && type !== void 0 ? type : this.defaultPreferences.accountType\n        }, address);\n    }\n    updateState(preferences, address) {\n        const selectedAddress = address || this.state.selectedAddress;\n        const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);\n        const mergedState = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, currentState), preferences);\n        this.update({\n            identities: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.state.identities), {}, {\n                [selectedAddress]: mergedState\n            })\n        });\n        return mergedState;\n    }\n    authCredentials(address) {\n        var _this$getAddressState7;\n        const selectedAddress = address || this.state.selectedAddress;\n        const jwtToken = ((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\";\n        return {\n            jwtToken,\n            publicAddress: selectedAddress\n        };\n    }\n    headers(address) {\n        var _this$getAddressState8;\n        const selectedAddress = address || this.state.selectedAddress;\n        return getHeaders(((_this$getAddressState8 = this.getAddressState(selectedAddress)) === null || _this$getAddressState8 === void 0 ? void 0 : _this$getAddressState8.jwtToken) || \"\", selectedAddress);\n    }\n}\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[\"approved\"] = \"approved\";\n    TransactionStatus[\"cancelled\"] = \"cancelled\";\n    TransactionStatus[\"cancelling\"] = \"cancelling\";\n    TransactionStatus[\"confirmed\"] = \"confirmed\";\n    TransactionStatus[\"failed\"] = \"failed\";\n    TransactionStatus[\"finalized\"] = \"finalized\";\n    TransactionStatus[\"processed\"] = \"processed\";\n    TransactionStatus[\"rejected\"] = \"rejected\";\n    TransactionStatus[\"signed\"] = \"signed\";\n    TransactionStatus[\"submitted\"] = \"submitted\";\n    TransactionStatus[\"unapproved\"] = \"unapproved\";\n    TransactionStatus[\"dropped\"] = \"dropped\";\n    TransactionStatus[\"expired\"] = \"expired\";\n    TransactionStatus[\"pending\"] = \"pending\";\n    return TransactionStatus;\n}({});\nconst TRANSACTION_TYPES = {\n    CANCEL: \"cancel\",\n    RETRY: \"retry\",\n    CONTRACT_INTERACTION: \"contractInteraction\",\n    DEPLOY_CONTRACT: \"contractDeployment\",\n    WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n    STANDARD_TRANSACTION: \"transaction\",\n    STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\",\n    // specific to chains like solana and casper\n    SENT_ETHER: \"sentEther\",\n    TOKEN_METHOD_TRANSFER: \"transfer\",\n    TOKEN_METHOD_TRANSFER_FROM: \"transferFrom\",\n    TOKEN_METHOD_APPROVE: \"approve\",\n    COLLECTIBLE_METHOD_SAFE_TRANSFER_FROM: \"safeTransferFrom\",\n    SET_APPROVAL_FOR_ALL: \"setApprovalForAll\"\n};\nconst TX_EVENTS = {\n    TX_WARNING: \"tx:warning\",\n    TX_ERROR: \"tx:error\",\n    TX_FAILED: \"tx:failed\",\n    TX_CONFIRMED: \"tx:confirmed\",\n    TX_DROPPED: \"tx:dropped\",\n    TX_EXPIRED: \"tx:expired\",\n    TX_STATUS_UPDATE: \"tx:status_update\",\n    TX_UNAPPROVED: \"tx:unapproved\",\n    TX_RETRY: \"tx:retry\",\n    TX_BLOCK_UPDATE: \"tx:block_update\"\n};\n/**\n * Transaction controller configuration\n */ /**\n * Transaction controller state\n */ /**\n * Result\n *\n * result - Promise resolving to a new transaction hash\n * transactionMeta - Meta information about this new transaction\n */ class BaseTransactionStateManager extends BaseController {\n    constructor({ config, state, getCurrentChainId }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"getCurrentChainId\", void 0);\n        this.defaultConfig = {\n            txHistoryLimit: 40\n        };\n        this.defaultState = {\n            transactions: {},\n            unapprovedTxs: {},\n            currentNetworkTxsList: []\n        };\n        this.initialize();\n        this.getCurrentChainId = getCurrentChainId;\n    }\n    getUnapprovedTxList() {\n        const chainId = this.getCurrentChainId();\n        return pickBy(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\n    }\n    getTransaction(txId) {\n        const { transactions } = this.state;\n        return transactions[txId];\n    }\n    updateTransaction(txMeta) {\n        // commit txMeta to state\n        const txId = txMeta.id;\n        txMeta.updated_at = new Date().toISOString();\n        this.update({\n            transactions: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.state.transactions), {}, {\n                [txId]: txMeta\n            })\n        });\n    }\n    setTxStatusRejected(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.rejected);\n        this._deleteTransaction(txId);\n    }\n    /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */ setTxStatusUnapproved(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.unapproved);\n    }\n    setTxStatusApproved(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.approved);\n    }\n    setTxStatusSigned(txId, isFinalStep) {\n        this._setTransactionStatus(txId, TransactionStatus.signed, isFinalStep);\n    }\n    setTxStatusSubmitted(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.submitted);\n    }\n    setTxStatusDropped(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.dropped);\n    }\n    setTxStatusExpired(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.expired);\n    }\n    setTxStatusConfirmed(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.confirmed);\n    }\n    setTxStatusFailed(txId, error_) {\n        const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n        const txMeta = this.getTransaction(txId);\n        txMeta.error = error;\n        this.updateTransaction(txMeta);\n        this._setTransactionStatus(txId, TransactionStatus.failed);\n    }\n    /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */ isFinalState(status) {\n        return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\n    }\n    /**\n   * Filters out the unapproved transactions from state\n   */ clearUnapprovedTxs() {\n        this.update({\n            transactions: omitBy(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved)\n        });\n    }\n    /**\n   * will append new transactions to old txns.\n   */ _addTransactionsToState(transactions) {\n        this.update({\n            transactions: transactions.reduce((result, newTx)=>{\n                result[newTx.id] = newTx;\n                return result;\n            }, this.state.transactions)\n        });\n    }\n    /**\n   * will set new txns, override existing if any in state.\n   */ _setTransactionsToState(transactions) {\n        this.update({\n            transactions: transactions.reduce((result, newTx)=>{\n                result[newTx.id] = newTx;\n                return result;\n            }, {})\n        });\n    }\n    _deleteTransaction(targetTransactionId) {\n        const { transactions } = this.state;\n        delete transactions[targetTransactionId];\n        this.update({\n            transactions\n        });\n    }\n    _deleteTransactions(targetTransactionIds) {\n        const { transactions } = this.state;\n        targetTransactionIds.forEach((transactionId)=>{\n            delete transactions[transactionId];\n        });\n        this.update({\n            transactions\n        });\n    }\n    _setTransactionStatus(txId, status, isFinalStep) {\n        const txMeta = this.getTransaction(txId);\n        if (!txMeta) {\n            return;\n        }\n        txMeta.status = status;\n        // only updating status so no validation required on txn.\n        this.updateTransaction(txMeta);\n        this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n            txId,\n            status\n        });\n        if (this.isFinalState(status) || isFinalStep) {\n            this.emit(`${txMeta.id}:finished`, txMeta);\n        } else {\n            this.emit(`${txMeta.id}:${status}`, txId);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvYmFzZUNvbnRyb2xsZXJzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNHO0FBQ3NHO0FBQ2xHO0FBQzdDO0FBQ3FJO0FBQzFHO0FBQ2pCO0FBQzJCO0FBQ3BDO0FBQ1c7QUFFdkM7O0NBRUMsR0FDRCxNQUFNNkIsdUJBQXVCM0IsdUVBQWdCQTtJQUMzQzs7Ozs7O0dBTUMsR0FDRDRCLFlBQVksRUFDVkMsU0FBUyxDQUFDLENBQUMsRUFDWEMsUUFBUSxDQUFDLENBQUMsRUFDWCxDQUFFO1FBQ0QsS0FBSztRQUNMLGtFQUFrRTtRQUNsRTs7S0FFQyxHQUNEL0IsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixDQUFDO1FBQ3hDOztLQUVDLEdBQ0RBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQztRQUN2Qzs7S0FFQyxHQUNEQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsWUFBWTtRQUNsQzs7S0FFQyxHQUNEQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsUUFBUTtRQUM5QkEsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixLQUFLO1FBQzVDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEtBQUs7UUFDM0NBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxrQkFBa0IsSUFBSSxDQUFDZ0MsYUFBYTtRQUMxRGhDLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsSUFBSSxDQUFDaUMsWUFBWTtRQUN4RCxJQUFJLENBQUNDLFlBQVksR0FBR0g7UUFDcEIsSUFBSSxDQUFDSSxhQUFhLEdBQUdMO0lBQ3ZCO0lBRUE7Ozs7R0FJQyxHQUNELElB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eUMsY0FBYztRQUNwQztRQUNBLElBQUksQ0FBQ3p4QixNQUFNLENBQUM7WUFDVmd2QjtRQUNGO0lBQ0Y7SUFDQVksc0JBQXNCTixJQUFJLEVBQUV4VSxNQUFNLEVBQUVxVixXQUFXLEVBQUU7UUFDL0MsTUFBTVgsU0FBUyxJQUFJLENBQUNILGNBQWMsQ0FBQ0M7UUFDbkMsSUFBSSxDQUFDRSxRQUFRO1lBQ1g7UUFDRjtRQUNBQSxPQUFPMVUsTUFBTSxHQUFHQTtRQUNoQix5REFBeUQ7UUFDekQsSUFBSSxDQUFDeVUsaUJBQWlCLENBQUNDO1FBQ3ZCLElBQUksQ0FBQ3Z2QixJQUFJLENBQUNpdUIsVUFBVU8sZ0JBQWdCLEVBQUU7WUFDcENhO1lBQ0F4VTtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNrVyxZQUFZLENBQUNsVyxXQUFXcVYsYUFBYTtZQUM1QyxJQUFJLENBQUNsd0IsSUFBSSxDQUFDLENBQUMsRUFBRXV2QixPQUFPblQsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFbVQ7UUFDckMsT0FBTztZQUNMLElBQUksQ0FBQ3Z2QixJQUFJLENBQUMsQ0FBQyxFQUFFdXZCLE9BQU9uVCxFQUFFLENBQUMsQ0FBQyxFQUFFdkIsT0FBTyxDQUFDLEVBQUV3VTtRQUN0QztJQUNGO0FBQ0Y7QUFFdWtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29senp0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYmFzZS1jb250cm9sbGVycy9kaXN0L2Jhc2VDb250cm9sbGVycy5lc20uanM/ZDk0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFNhZmVFdmVudEVtaXR0ZXIsIGNyZWF0ZUFzeW5jTWlkZGxld2FyZSwgbWVyZ2VNaWRkbGV3YXJlLCBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUsIEpSUENFbmdpbmUsIHByb3ZpZGVyRnJvbUVuZ2luZSwgcnBjRXJyb3JzIH0gZnJvbSAnQHRvcnVzbGFicy9vcGVubG9naW4tanJwYyc7XG5pbXBvcnQgeyBwb3N0LCBnZXQsIHB1dCwgcGF0Y2gsIHJlbW92ZSB9IGZyb20gJ0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgZnJvbVNpZ25lZCwgYnl0ZXNUb0JpZ0ludCwgdG9VbnNpZ25lZCwgc3RyaXBIZXhQcmVmaXgsIGJpZ0ludFRvSGV4LCBhZGRIZXhQcmVmaXgsIGhhc2hQZXJzb25hbE1lc3NhZ2UsIGVjc2lnbiwgYmlnSW50VG9CeXRlcyB9IGZyb20gJ0BldGhlcmV1bWpzL3V0aWwnO1xuaW1wb3J0IHsgc2FmZWF0b2IgfSBmcm9tICdAdG9ydXNsYWJzL29wZW5sb2dpbi11dGlscyc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBCcm9hZGNhc3RDaGFubmVsIH0gZnJvbSAnQHRvcnVzbGFicy9icm9hZGNhc3QtY2hhbm5lbCc7XG5pbXBvcnQgYm93c2VyIGZyb20gJ2Jvd3Nlcic7XG5pbXBvcnQgeyBqd3REZWNvZGUgfSBmcm9tICdqd3QtZGVjb2RlJztcblxuLyoqXG4gKiBDb250cm9sbGVyIGNsYXNzIHRoYXQgcHJvdmlkZXMgY29uZmlndXJhdGlvbiwgc3RhdGUgbWFuYWdlbWVudCwgYW5kIHN1YnNjcmlwdGlvbnNcbiAqL1xuY2xhc3MgQmFzZUNvbnRyb2xsZXIgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCYXNlQ29udHJvbGxlciBpbnN0YW5jZS4gQm90aCBpbml0aWFsIHN0YXRlIGFuZCBpbml0aWFsXG4gICAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggZGVmYXVsdHMgdXBvbiBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnID0ge30sXG4gICAgc3RhdGUgPSB7fVxuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvLyBVc2UgYXNzaWduIHNpbmNlIGdlbmVyaWNzIGNhbid0IGJlIHNwcmVhZDogaHR0cHM6Ly9naXQuaW8vdnBSaFlcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdENvbmZpZ1wiLCB7fSk7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzdGF0ZSBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFN0YXRlXCIsIHt9KTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGxpc3RlbmVycyBhcmUgbm90aWZpZWQgb2Ygc3RhdGUgY2hhbmdlc1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwgXCJCYXNlQ29udHJvbGxlclwiKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0aWFsQ29uZmlnXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5pdGlhbFN0YXRlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZXJuYWxDb25maWdcIiwgdGhpcy5kZWZhdWx0Q29uZmlnKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcm5hbFN0YXRlXCIsIHRoaXMuZGVmYXVsdFN0YXRlKTtcbiAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuaW5pdGlhbENvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgY3VycmVudCBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyAtIEN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0IGNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgY3VycmVudCBjb250cm9sbGVyIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIC0gQ3VycmVudCBzdGF0ZVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyAtIE5ldyBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIE92ZXJ3cml0ZSBjb25maWcgaW5zdGVhZCBvZiBtZXJnaW5nXG4gICAqIEBwYXJhbSBmdWxsVXBkYXRlIC0gQm9vbGVhbiB0aGF0IGRlZmluZXMgaWYgdGhlIHVwZGF0ZSBpcyBwYXJ0aWFsIG9yIG5vdFxuICAgKi9cbiAgY29uZmlndXJlKGNvbmZpZywgb3ZlcndyaXRlID0gZmFsc2UsIGZ1bGxVcGRhdGUgPSB0cnVlKSB7XG4gICAgaWYgKGZ1bGxVcGRhdGUpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxDb25maWcgPSBvdmVyd3JpdGUgPyBjb25maWcgOiBPYmplY3QuYXNzaWduKHRoaXMuaW50ZXJuYWxDb25maWcsIGNvbmZpZyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmludGVybmFsQ29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICB0aGlzW2tleV0gPSB0aGlzLmludGVybmFsQ29uZmlnW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29uZmlnKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldID0gY29uZmlnW2tleV07XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICB0aGlzW2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbnRyb2xsZXIgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIC0gTmV3IHN0YXRlXG4gICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBPdmVyd3JpdGUgc3RhdGUgaW5zdGVhZCBvZiBtZXJnaW5nXG4gICAqL1xuICB1cGRhdGUoc3RhdGUsIG92ZXJ3cml0ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gb3ZlcndyaXRlID8gX29iamVjdFNwcmVhZCh7fSwgc3RhdGUpIDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmludGVybmFsU3RhdGUpLCBzdGF0ZSk7XG4gICAgdGhpcy5lbWl0KFwic3RvcmVcIiwgdGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBjb250cm9sbGVyLiBUaGlzIHNldHMgZWFjaCBjb25maWcgb3B0aW9uIGFzIGEgbWVtYmVyXG4gICAqIHZhcmlhYmxlIG9uIHRoaXMgaW5zdGFuY2UgYW5kIHRyaWdnZXJzIGFueSBkZWZpbmVkIHNldHRlcnMuIFRoaXNcbiAgICogYWxzbyBzZXRzIGluaXRpYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGFueSBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIC0gVGhpcyBjb250cm9sbGVyIGluc3RhbmNlXG4gICAqL1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIHRoaXMuaW50ZXJuYWxDb25maWcgPSB0aGlzLmRlZmF1bHRDb25maWc7XG4gICAgdGhpcy5jb25maWd1cmUodGhpcy5pbml0aWFsQ29uZmlnKTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmluaXRpYWxTdGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuY29uc3Qgc2VjID0gMTAwMDtcbmNvbnN0IGNhbGN1bGF0ZVN1bSA9IChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZTtcbmNvbnN0IGJsb2NrVHJhY2tlckV2ZW50cyA9IFtcInN5bmNcIiwgXCJsYXRlc3RcIl07XG5jbGFzcyBCYXNlQmxvY2tUcmFja2VyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnID0ge30sXG4gICAgc3RhdGUgPSB7fVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcblxuICAgIC8vIGNvbmZpZ1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwgXCJCYXNlQmxvY2tUcmFja2VyXCIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ibG9ja1Jlc2V0VGltZW91dFwiLCB2b2lkIDApO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgX2N1cnJlbnRCbG9jazoge1xuICAgICAgICBpZGVtcG90ZW5jeUtleTogXCJcIlxuICAgICAgfSxcbiAgICAgIF9pc1J1bm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICBibG9ja1Jlc2V0RHVyYXRpb246IDIwICogc2VjXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcblxuICAgIC8vIGJpbmQgZnVuY3Rpb25zIGZvciBpbnRlcm5hbCB1c2VcbiAgICB0aGlzLl9vbk5ld0xpc3RlbmVyID0gdGhpcy5fb25OZXdMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIgPSB0aGlzLl9vblJlbW92ZUxpc3RlbmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVzZXRDdXJyZW50QmxvY2sgPSB0aGlzLl9yZXNldEN1cnJlbnRCbG9jay5iaW5kKHRoaXMpO1xuXG4gICAgLy8gbGlzdGVuIGZvciBoYW5kbGVyIGNoYW5nZXNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7XG4gIH1cbiAgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLl9pc1J1bm5pbmc7XG4gIH1cbiAgZ2V0Q3VycmVudEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLl9jdXJyZW50QmxvY2s7XG4gIH1cbiAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2soKSB7XG4gICAgLy8gcmV0dXJuIGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLnN0YXRlLl9jdXJyZW50QmxvY2suaWRlbXBvdGVuY3lLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLl9jdXJyZW50QmxvY2s7XG4gICAgfVxuICAgIC8vIHdhaXQgZm9yIGEgbmV3IGxhdGVzdCBibG9ja1xuICAgIGNvbnN0IGxhdGVzdEJsb2NrID0gYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLm9uY2UoXCJsYXRlc3RcIiwgYmxvY2sgPT4ge1xuICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICByZXNvbHZlKGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gcmV0dXJuIG5ld2x5IHNldCBjdXJyZW50IGJsb2NrXG4gICAgcmV0dXJuIGxhdGVzdEJsb2NrO1xuICB9XG5cbiAgLy8gZG9udCBhbGxvdyBtb2R1bGUgY29uc3VtZXIgdG8gcmVtb3ZlIG91ciBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnNcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLy8gcmUtYWRkIGludGVybmFsIGV2ZW50c1xuICAgIHRoaXMuX3NldHVwSW50ZXJuYWxFdmVudHMoKTtcbiAgICAvLyB0cmlnZ2VyIHN0b3AgY2hlY2sganVzdCBpbiBjYXNlXG4gICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlxuICAgKi9cbiAgX3N0YXJ0KCkge1xuICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgbm9vcFxuICB9XG5cbiAgLyoqXG4gICAqIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlxuICAgKi9cbiAgX2VuZCgpIHtcbiAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcbiAgfVxuICBfbmV3UG90ZW50aWFsTGF0ZXN0KG5ld0Jsb2NrKSB7XG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gdGhpcy5zdGF0ZS5fY3VycmVudEJsb2NrO1xuICAgIC8vIG9ubHkgdXBkYXRlIGlmIGJsb2NrIG51bWJlciBpcyBoaWdoZXJcbiAgICBpZiAoY3VycmVudEJsb2NrICYmIG5ld0Jsb2NrLmlkZW1wb3RlbmN5S2V5ID09PSBjdXJyZW50QmxvY2suaWRlbXBvdGVuY3lLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKTtcbiAgfVxuICBfc2V0dXBJbnRlcm5hbEV2ZW50cygpIHtcbiAgICAvLyBmaXJzdCByZW1vdmUgbGlzdGVuZXJzIGZvciBpZGVtcG90ZW5jeVxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJuZXdMaXN0ZW5lclwiLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwicmVtb3ZlTGlzdGVuZXJcIiwgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgLy8gdGhlbiBhZGQgdGhlbVxuICAgIHRoaXMub24oXCJyZW1vdmVMaXN0ZW5lclwiLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICB0aGlzLm9uKFwibmV3TGlzdGVuZXJcIiwgdGhpcy5fb25OZXdMaXN0ZW5lcik7XG4gIH1cbiAgX29uTmV3TGlzdGVuZXIoKSB7XG4gICAgdGhpcy5fbWF5YmVTdGFydCgpO1xuICB9XG4gIF9vblJlbW92ZUxpc3RlbmVyKCkge1xuICAgIC8vIGByZW1vdmVMaXN0ZW5lcmAgaXMgY2FsbGVkICphZnRlciogdGhlIGxpc3RlbmVyIGlzIHJlbW92ZWRcbiAgICBpZiAodGhpcy5fZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tYXliZUVuZCgpO1xuICB9XG4gIF9tYXliZVN0YXJ0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAvLyBjYW5jZWwgc2V0dGluZyBsYXRlc3QgYmxvY2sgdG8gc3RhbGVcbiAgICB0aGlzLl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCgpO1xuICAgIHRoaXMuX3N0YXJ0KCk7XG4gIH1cbiAgX21heWJlRW5kKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3NldHVwQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICB0aGlzLl9lbmQoKTtcbiAgfVxuICBfZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpIHtcbiAgICByZXR1cm4gYmxvY2tUcmFja2VyRXZlbnRzLm1hcChldmVudE5hbWUgPT4gdGhpcy5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkpLnJlZHVjZShjYWxjdWxhdGVTdW0pO1xuICB9XG4gIF9zZXRDdXJyZW50QmxvY2sobmV3QmxvY2spIHtcbiAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaztcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBfY3VycmVudEJsb2NrOiBuZXdCbG9ja1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdChcImxhdGVzdFwiLCBuZXdCbG9jayk7XG4gICAgdGhpcy5lbWl0KFwic3luY1wiLCB7XG4gICAgICBvbGRCbG9jayxcbiAgICAgIG5ld0Jsb2NrXG4gICAgfSk7XG4gIH1cbiAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQoKSB7XG4gICAgLy8gY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXRcbiAgICB0aGlzLl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCgpO1xuICAgIC8vIGNsZWFyIGxhdGVzdCBibG9jayB3aGVuIHN0YWxlXG4gICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLCB0aGlzLmNvbmZpZy5ibG9ja1Jlc2V0RHVyYXRpb24pO1xuXG4gICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZikge1xuICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYoKTtcbiAgICB9XG4gIH1cbiAgX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgX3Jlc2V0Q3VycmVudEJsb2NrKCkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIF9jdXJyZW50QmxvY2s6IHtcbiAgICAgICAgaWRlbXBvdGVuY3lLZXk6IFwiXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBmaWx0ZXJOb29wID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IGludGVybmFsRXZlbnRzID0gW1wibmV3TGlzdGVuZXJcIiwgXCJyZW1vdmVMaXN0ZW5lclwiXTtcbmNvbnN0IGV4dGVybmFsRXZlbnRGaWx0ZXIgPSBuYW1lID0+ICFpbnRlcm5hbEV2ZW50cy5pbmNsdWRlcyhuYW1lKTtcbmZ1bmN0aW9uIGdldFJhd0xpc3RlbmVycyhldmVudEVtaXR0ZXIsIG5hbWUpIHtcbiAgLy8gcHJlZmVyIG5hdGl2ZVxuICByZXR1cm4gdHlwZW9mIGV2ZW50RW1pdHRlci5yYXdMaXN0ZW5lcnMgIT09IFwidW5kZWZpbmVkXCIgPyBldmVudEVtaXR0ZXIucmF3TGlzdGVuZXJzKG5hbWUpIDogZXZlbnRFbWl0dGVyLmxpc3RlbmVycyhuYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlclByb3h5KGluaXRpYWxUYXJnZXQsIG9wdHMpIHtcbiAgLy8gcGFyc2Ugb3B0aW9uc1xuICBjb25zdCBmaW5hbE9wdHMgPSBvcHRzIHx8IHt9O1xuICBsZXQgZXZlbnRGaWx0ZXIgPSBmaW5hbE9wdHMuZXZlbnRGaWx0ZXIgfHwgZmlsdGVyTm9vcDtcbiAgaWYgKHR5cGVvZiBldmVudEZpbHRlciA9PT0gXCJzdHJpbmdcIiAmJiBldmVudEZpbHRlciA9PT0gXCJza2lwSW50ZXJuYWxcIikgZXZlbnRGaWx0ZXIgPSBleHRlcm5hbEV2ZW50RmlsdGVyO1xuICBpZiAodHlwZW9mIGV2ZW50RmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZUV2ZW50RW1pdHRlclByb3h5IC0gSW52YWxpZCBldmVudEZpbHRlclwiKTtcbiAgbGV0IHRhcmdldCA9IGluaXRpYWxUYXJnZXQ7XG4gIGxldCBzZXRUYXJnZXQgPSBuZXdUYXJnZXQgPT4ge1xuICAgIGNvbnN0IG9sZFRhcmdldCA9IHRhcmdldDtcbiAgICB0YXJnZXQgPSBuZXdUYXJnZXQ7XG4gICAgb2xkVGFyZ2V0LmV2ZW50TmFtZXMoKS5maWx0ZXIoZXZlbnRGaWx0ZXIpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBnZXRSYXdMaXN0ZW5lcnMob2xkVGFyZ2V0LCBuYW1lKS5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgICBuZXdUYXJnZXQub24obmFtZSwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBvbGQgbGlzdGVuZXJzXG4gICAgb2xkVGFyZ2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9O1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh7fSwge1xuICAgIGdldDogKF8sIG5hbWUpID0+IHtcbiAgICAgIC8vIG92ZXJyaWRlIGBzZXRUYXJnZXRgIGFjY2Vzc1xuICAgICAgaWYgKG5hbWUgPT09IFwic2V0VGFyZ2V0XCIpIHJldHVybiBzZXRUYXJnZXQ7XG4gICAgICByZXR1cm4gdGFyZ2V0W25hbWVdO1xuICAgIH0sXG4gICAgc2V0OiAoXywgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIC8vIGFsbG93IGBzZXRUYXJnZXRgIG92ZXJyaWRlc1xuICAgICAgaWYgKG5hbWUgPT09IFwic2V0VGFyZ2V0XCIpIHtcbiAgICAgICAgc2V0VGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJveHk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN3YXBwYWJsZVByb3h5KGluaXRpYWxUYXJnZXQpIHtcbiAgbGV0IHRhcmdldCA9IGluaXRpYWxUYXJnZXQ7XG4gIGxldCBzZXRUYXJnZXQgPSBuZXdUYXJnZXQgPT4ge1xuICAgIHRhcmdldCA9IG5ld1RhcmdldDtcbiAgfTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICBnZXQ6IChfLCBuYW1lKSA9PiB7XG4gICAgICAvLyBvdmVycmlkZSBgc2V0VGFyZ2V0YCBhY2Nlc3NcbiAgICAgIGlmIChuYW1lID09PSBcInNldFRhcmdldFwiKSByZXR1cm4gc2V0VGFyZ2V0O1xuICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcbiAgICB9LFxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcbiAgICAgIGlmIChuYW1lID09PSBcInNldFRhcmdldFwiKSB7XG4gICAgICAgIHNldFRhcmdldCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vLyBldmVyeSB0ZW4gbWludXRlc1xuY29uc3QgUE9MTElOR19JTlRFUlZBTCA9IDYwMDAwMDtcbmNsYXNzIEJhc2VDdXJyZW5jeUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcgPSB7fSxcbiAgICBzdGF0ZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIGN1cnJlbnRDdXJyZW5jeTogXCJ1c2RcIixcbiAgICAgIGNvbnZlcnNpb25SYXRlOiAwLFxuICAgICAgY29udmVyc2lvbkRhdGU6IFwiTi9BXCIsXG4gICAgICBuYXRpdmVDdXJyZW5jeTogXCJFVEhcIlxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgcG9sbEludGVydmFsOiBQT0xMSU5HX0lOVEVSVkFMXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFBVQkxJQyBNRVRIT0RTXG4gIC8vXG5cbiAgZ2V0TmF0aXZlQ3VycmVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubmF0aXZlQ3VycmVuY3k7XG4gIH1cbiAgc2V0TmF0aXZlQ3VycmVuY3kobmF0aXZlQ3VycmVuY3kpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBuYXRpdmVDdXJyZW5jeSxcbiAgICAgIHRpY2tlcjogbmF0aXZlQ3VycmVuY3lcbiAgICB9KTtcbiAgfVxuICBnZXRDdXJyZW50Q3VycmVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudEN1cnJlbmN5O1xuICB9XG4gIHNldEN1cnJlbnRDdXJyZW5jeShjdXJyZW50Q3VycmVuY3kpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBjdXJyZW50Q3VycmVuY3lcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBmb3IgdGhlIGNvbnZlcnNpb25SYXRlIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBjb252ZXJzaW9uIHJhdGUgZnJvbSBFVEggdG8gdGhlIHNlbGVjdGVkIGN1cnJlbmN5LlxuICAgKlxuICAgKi9cbiAgZ2V0Q29udmVyc2lvblJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udmVyc2lvblJhdGU7XG4gIH1cbiAgc2V0Q29udmVyc2lvblJhdGUoY29udmVyc2lvblJhdGUpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBjb252ZXJzaW9uUmF0ZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgY29udmVyc2lvbkRhdGUgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGRhdGUgYXQgd2hpY2ggdGhlIGNvbnZlcnNpb24gcmF0ZSB3YXMgc2V0LiBFeHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIG1pZG5pZ2h0IG9mXG4gICAqIEphbnVhcnkgMSwgMTk3MFxuICAgKlxuICAgKi9cbiAgZ2V0Q29udmVyc2lvbkRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udmVyc2lvbkRhdGU7XG4gIH1cbiAgc2V0Q29udmVyc2lvbkRhdGUoY29udmVyc2lvbkRhdGUpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBjb252ZXJzaW9uRGF0ZVxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IEZFQVRVUkVTX1BST1ZJREVSX0NIQU5HRV9XSU5ET1cgPSB7XG4gIGhlaWdodDogNjYwLFxuICB3aWR0aDogMzc1XG59O1xuY29uc3QgRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XID0ge1xuICBoZWlnaHQ6IDc0MCxcbiAgd2lkdGg6IDEzMTVcbn07XG5jb25zdCBGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA3MDAsXG4gIHdpZHRoOiAxMjAwXG59O1xuY29uc3QgRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cgPSB7XG4gIGhlaWdodDogNzAwLFxuICB3aWR0aDogNDUwXG59O1xuY29uc3QgUE9QVVBfTE9BREVEID0gXCJwb3B1cF9sb2FkZWRcIjtcbmNvbnN0IFBPUFVQX1JFU1VMVCA9IFwicG9wdXBfcmVzdWx0XCI7XG5jb25zdCBTRVRVUF9DT01QTEVURSA9IFwic2V0dXBfY29tcGxldGVcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9BTEwgPSBcIndhbGxldEFjdGl2aXR5LmFsbFRyYW5zYWN0aW9uc1wiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX1NFTkQgPSBcIndhbGxldEFjdGl2aXR5LnNlbmRcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9CVVJOID0gXCJ3YWxsZXRBY3Rpdml0eS5idXJuXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fUkVDRUlWRSA9IFwid2FsbGV0QWN0aXZpdHkucmVjZWl2ZVwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX1RPUFVQID0gXCJ3YWxsZXRBY3Rpdml0eS50b3B1cFwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX0NSRUFURV9UUlVTVExJTkUgPSBcIndhbGxldEFjdGl2aXR5LmNyZWF0ZVRydXN0bGluZVwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX1JFTU9WRV9UUlVTVExJTkUgPSBcIndhbGxldEFjdGl2aXR5LnJlbW92ZVRydXN0bGluZVwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX0NSRUFURV9ORlRfT0ZGRVIgPSBcIndhbGxldEFjdGl2aXR5LmNyZWF0ZU5mdE9mZmVyXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fQUNDRVBUX05GVF9PRkZFUiA9IFwid2FsbGV0QWN0aXZpdHkuYWNjZXB0TmZ0T2ZmZXJcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9DQU5DRUxfTkZUX09GRkVSID0gXCJ3YWxsZXRBY3Rpdml0eS5jYW5jZWxOZnRPZmZlclwiO1xuY29uc3QgQUNUSVZJVFlfUEVSSU9EX0FMTCA9IFwid2FsbGV0QWN0aXZpdHkuYWxsXCI7XG5jb25zdCBBQ1RJVklUWV9QRVJJT0RfV0VFS19PTkUgPSBcIndhbGxldEFjdGl2aXR5Lmxhc3RPbmVXZWVrXCI7XG5jb25zdCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfT05FID0gXCJ3YWxsZXRBY3Rpdml0eS5sYXN0T25lTW9udGhcIjtcbmNvbnN0IEFDVElWSVRZX1BFUklPRF9NT05USF9TSVggPSBcIndhbGxldEFjdGl2aXR5Lmxhc3RTaXhNb250c1wiO1xuY29uc3QgQUNUSVZJVFlfU1RBVFVTX1NVQ0NFU1NGVUwgPSBcIndhbGxldEFjdGl2aXR5LnN1Y2Nlc3NmdWxcIjtcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19VTlNVQ0NFU1NGVUwgPSBcIndhbGxldEFjdGl2aXR5LnVuc3VjY2Vzc2Z1bFwiO1xuY29uc3QgQUNUSVZJVFlfU1RBVFVTX1BFTkRJTkcgPSBcIndhbGxldEFjdGl2aXR5LnBlbmRpbmdcIjtcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19DQU5DRUxMRUQgPSBcIndhbGxldEFjdGl2aXR5LmNhbmNlbGxlZFwiO1xuY29uc3QgQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExJTkcgPSBcIndhbGxldEFjdGl2aXR5LmNhbmNlbGxpbmdcIjtcbmNvbnN0IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUyA9IHtcbiAgSUZSQU1FX1NUQVRVUzogXCJpZnJhbWVfc3RhdHVzXCIsXG4gIC8vIFRlbGwgZW1iZWQgdG8gY2xvc2UgdGhlIHdpbmRvd1xuICBDTE9TRV9XSU5ET1c6IFwiY2xvc2Vfd2luZG93XCIsXG4gIFVTRVJfTE9HR0VEX0lOOiBcInVzZXJfbG9nZ2VkX2luXCIsXG4gIFVTRVJfTE9HR0VEX09VVDogXCJ1c2VyX2xvZ2dlZF9vdXRcIlxufTtcbmNvbnN0IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTID0ge1xuICBMT0dPVVQ6IFwibG9nb3V0XCIsXG4gIFdBTExFVF9JTlNUQU5DRV9JRDogXCJ3YWxsZXRfaW5zdGFuY2VfaWRcIixcbiAgVVNFUl9JTkZPOiBcInVzZXJfaW5mb1wiLFxuICBTRVRfUFJPVklERVI6IFwic2V0X3Byb3ZpZGVyXCIsXG4gIFRPUFVQOiBcInRvcHVwXCIsXG4gIElGUkFNRV9TVEFUVVM6IFwiaWZyYW1lX3N0YXR1c1wiLFxuICAvLyB1c2VyIGhhcyBjbG9zZWQgdGhlIHdpbmRvdyBmcm9tIGVtYmVkJ3Mgc2lkZVxuICBDTE9TRURfV0lORE9XOiBcImNsb3NlZF93aW5kb3dcIixcbiAgV0lORE9XX0JMT0NLRUQ6IFwid2luZG93X2Jsb2NrZWRcIixcbiAgR0VUX1BST1ZJREVSX1NUQVRFOiBcImdldF9wcm92aWRlcl9zdGF0ZVwiLFxuICBMT0dJTl9XSVRIX1BSSVZBVEVfS0VZOiBcImxvZ2luX3dpdGhfcHJpdmF0ZV9rZXlcIixcbiAgU0hPV19XQUxMRVRfQ09OTkVDVDogXCJzaG93X3dhbGxldF9jb25uZWN0XCIsXG4gIFNIT1dfQ0hFQ0tPVVQ6IFwic2hvd19jaGVja291dFwiLFxuICBTSE9XX1dBTExFVF9VSTogXCJzaG93X3dhbGxldF91aVwiLFxuICBMT0dJTl9XSVRIX1NFU1NJT05fSUQ6IFwibG9naW5fd2l0aF9zZXNzaW9uX2lkXCJcbn07XG5jb25zdCBQUk9WSURFUl9KUlBDX01FVEhPRFMgPSB7XG4gIEdFVF9QUk9WSURFUl9TVEFURTogXCJ3YWxsZXRfZ2V0X3Byb3ZpZGVyX3N0YXRlXCJcbn07XG5jb25zdCBQUk9WSURFUl9OT1RJRklDQVRJT05TID0ge1xuICBBQ0NPVU5UU19DSEFOR0VEOiBcIndhbGxldF9hY2NvdW50c19jaGFuZ2VkXCIsXG4gIENIQUlOX0NIQU5HRUQ6IFwid2FsbGV0X2NoYWluX2NoYW5nZWRcIixcbiAgVU5MT0NLX1NUQVRFX0NIQU5HRUQ6IFwid2FsbGV0X3VubG9ja19zdGF0ZV9jaGFuZ2VkXCJcbn07XG5jb25zdCBCUk9BRENBU1RfQ0hBTk5FTFMgPSB7XG4gIFJFRElSRUNUX0NIQU5ORUw6IFwicmVkaXJlY3RfY2hhbm5lbFwiLFxuICBQUk9WSURFUl9DSEFOR0VfQ0hBTk5FTDogXCJ0b3J1c19wcm92aWRlcl9jaGFuZ2VfY2hhbm5lbFwiLFxuICBUUkFOU0FDVElPTl9DSEFOTkVMOiBcInRvcnVzX2NoYW5uZWxcIixcbiAgTUVTU0FHRV9DSEFOTkVMOiBcInRvcnVzX21lc3NhZ2VfY2hhbm5lbFwiLFxuICBXQUxMRVRfTE9HT1VUX0NIQU5ORUw6IFwid2FsbGV0X2xvZ291dF9jaGFubmVsXCIsXG4gIFdBTExFVF9TRUxFQ1RFRF9BRERSRVNTX0NIQU5ORUw6IFwid2FsbGV0X3NlbGVjdGVkX2FkZHJlc3NfY2hhbm5lbFwiLFxuICBXQUxMRVRfTkVUV09SS19DSEFOR0VfQ0hBTk5FTDogXCJ3YWxsZXRfbmV0d29ya19jaGFuZ2VfY2hhbm5lbFwiLFxuICBXQUxMRVRfQUNDT1VOVF9JTVBPUlRfQ0hBTk5FTDogXCJ3YWxsZXRfYWNjb3VudF9pbXBvcnRfY2hhbm5lbFwiLFxuICBUSEVNRV9DSEFOR0U6IFwidGhlbWVfY2hhbmdlX2NoYW5uZWxcIixcbiAgVE9QX1VQX0NIQU5ORUw6IFwidG9wX3VwX2NoYW5uZWxcIlxufTtcbmNvbnN0IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTID0ge1xuICBMT0dPVVQ6IFwibG9nb3V0XCIsXG4gIEFDQ09VTlRfSU1QT1JURUQ6IFwiYWNjb3VudF9pbXBvcnRlZFwiLFxuICBTRUxFQ1RFRF9BRERSRVNTX0NIQU5HRTogXCJzZWxlY3RlZF9hZGRyZXNzX2NoYW5nZVwiLFxuICBORVRXT1JLX0NIQU5HRTogXCJuZXR3b3JrX2NoYW5nZVwiLFxuICBTRVRfVEhFTUU6IFwic2V0X3RoZW1lXCJcbn07XG5sZXQgQ29udHJvbGxlckV2ZW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoQ29udHJvbGxlckV2ZW50cykge1xuICBDb250cm9sbGVyRXZlbnRzW1wiVXNlclVuYXV0aG9yaXplZFwiXSA9IFwidXNlci51bmF1dGhvcml6ZWRcIjtcbiAgcmV0dXJuIENvbnRyb2xsZXJFdmVudHM7XG59KHt9KTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhbmdlUHJvdmlkZXJNaWRkbGV3YXJlTWlkZGxld2FyZSh7XG4gIGNoYW5nZVByb3ZpZGVyXG59KSB7XG4gIHJldHVybiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbWV0aG9kXG4gICAgfSA9IHJlcXVlc3Q7XG4gICAgaWYgKG1ldGhvZCAhPT0gQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuU0VUX1BST1ZJREVSKSByZXR1cm4gbmV4dCgpO1xuICAgIGlmICghY2hhbmdlUHJvdmlkZXIpIHRocm93IG5ldyBFcnJvcihcIkNvbW11bmljYXRpb25NaWRkbGV3YXJlIC0gb3B0cy5jaGFuZ2VQcm92aWRlciBub3QgcHJvdmlkZWRcIik7XG4gICAgcmVzcG9uc2UucmVzdWx0ID0gYXdhaXQgY2hhbmdlUHJvdmlkZXIocmVxdWVzdCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9wdXBNaWRkbGV3YXJlKHtcbiAgdG9wdXBcbn0pIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtZXRob2RcbiAgICB9ID0gcmVxdWVzdDtcbiAgICBpZiAobWV0aG9kICE9PSBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5UT1BVUCkgcmV0dXJuIG5leHQoKTtcbiAgICBpZiAoIXRvcHVwKSB0aHJvdyBuZXcgRXJyb3IoXCJDb21tdW5pY2F0aW9uTWlkZGxld2FyZSAtIG9wdHMudG9wdXAgbm90IHByb3ZpZGVkXCIpO1xuICAgIHJlc3BvbnNlLnJlc3VsdCA9IGF3YWl0IHRvcHVwKHJlcXVlc3QpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZSh0YXJnZXRNZXRob2QsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtZXRob2RcbiAgICB9ID0gcmVxdWVzdDtcbiAgICBpZiAobWV0aG9kICE9PSB0YXJnZXRNZXRob2QpIHJldHVybiBuZXh0KCk7XG4gICAgaWYgKCFoYW5kbGVyKSB0aHJvdyBuZXcgRXJyb3IoYENvbW11bmljYXRpb25NaWRkbGV3YXJlIC0gJHt0YXJnZXRNZXRob2R9IG5vdCBwcm92aWRlZGApO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIocmVxdWVzdCk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuICAgIHJlc3BvbnNlLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW11bmljYXRpb25NaWRkbGV3YXJlKHByb3ZpZGVySGFuZGxlcnMpIHtcbiAgY29uc3Qge1xuICAgIGdldFVzZXJJbmZvLFxuICAgIGdldFdhbGxldEluc3RhbmNlSWQsXG4gICAgdG9wdXAsXG4gICAgbG9nb3V0LFxuICAgIGNoYW5nZVByb3ZpZGVyLFxuICAgIHNldElGcmFtZVN0YXR1cyxcbiAgICBoYW5kbGVXaW5kb3dScGMsXG4gICAgZ2V0UHJvdmlkZXJTdGF0ZSxcbiAgICBsb2dpbldpdGhQcml2YXRlS2V5LFxuICAgIHNob3dXYWxsZXRDb25uZWN0LFxuICAgIHNob3dDaGVja291dCxcbiAgICBzaG93V2FsbGV0VWksXG4gICAgc2hvd1dpbmRvd0Jsb2NrQWxlcnQsXG4gICAgbG9naW5XaXRoU2Vzc2lvbklkXG4gIH0gPSBwcm92aWRlckhhbmRsZXJzO1xuICByZXR1cm4gbWVyZ2VNaWRkbGV3YXJlKFtjcmVhdGVDaGFuZ2VQcm92aWRlck1pZGRsZXdhcmVNaWRkbGV3YXJlKHtcbiAgICBjaGFuZ2VQcm92aWRlclxuICB9KSwgY3JlYXRlVG9wdXBNaWRkbGV3YXJlKHtcbiAgICB0b3B1cFxuICB9KSwgY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKHtcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuTE9HT1VUXTogbG9nb3V0LFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5XQUxMRVRfSU5TVEFOQ0VfSURdOiBnZXRXYWxsZXRJbnN0YW5jZUlkLFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5VU0VSX0lORk9dOiBnZXRVc2VySW5mbyxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuSUZSQU1FX1NUQVRVU106IHNldElGcmFtZVN0YXR1cyxcbiAgICAvLyBEbyB0aGlzIGluIHRoZSBvcmNoZXN0cmF0b3IgYmVjYXVzZSBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlciBuZWVkcyB0byBiZSBwYXNzZWQgaW50byBQb3B1cEhhbmRsZXJzXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkNMT1NFRF9XSU5ET1ddOiBoYW5kbGVXaW5kb3dScGMsXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkdFVF9QUk9WSURFUl9TVEFURV06IGdldFByb3ZpZGVyU3RhdGUsXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNIT1dfV0FMTEVUX0NPTk5FQ1RdOiBzaG93V2FsbGV0Q29ubmVjdCxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuU0hPV19DSEVDS09VVF06IHNob3dDaGVja291dCxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuU0hPV19XQUxMRVRfVUldOiBzaG93V2FsbGV0VWksXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLldJTkRPV19CTE9DS0VEXTogc2hvd1dpbmRvd0Jsb2NrQWxlcnRcbiAgfSksIGNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZShDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5MT0dJTl9XSVRIX1BSSVZBVEVfS0VZLCBsb2dpbldpdGhQcml2YXRlS2V5KSwgY3JlYXRlR2VuZXJpY0pSUENNaWRkbGV3YXJlKENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkxPR0lOX1dJVEhfU0VTU0lPTl9JRCwgbG9naW5XaXRoU2Vzc2lvbklkKV0pO1xufVxuXG5jbGFzcyBCYXNlRW1iZWRDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnID0ge30sXG4gICAgc3RhdGVcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NvbW11bmljYXRpb25Qcm92aWRlclByb3h5XCIsIHZvaWQgMCk7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICBpc0lGcmFtZUZ1bGxTY3JlZW46IHRydWUsXG4gICAgICBvYXV0aE1vZGFsVmlzaWJpbGl0eTogZmFsc2UsXG4gICAgICBsb2dpbkluUHJvZ3Jlc3M6IGZhbHNlLFxuICAgICAgZGFwcE1ldGFkYXRhOiB7XG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIGljb246IFwiXCJcbiAgICAgIH0sXG4gICAgICB3ZWIzQXV0aENsaWVudElkOiBcIlwiLFxuICAgICAgd2ViM0F1dGhOZXR3b3JrOiBcIm1haW5uZXRcIixcbiAgICAgIHdoaXRlTGFiZWw6IG51bGwsXG4gICAgICBjb25maXJtYXRpb25TdHJhdGVneTogXCJwb3B1cFwiXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYnkgb3JjaGVzdHJhdG9yIG9uY2Ugd2hpbGUgaW5pdGlhbGl6aW5nIHRoZSBjbGFzc1xuICAgKiBAcGFyYW0gaGFuZGxlcnMgLSBKUlBDIGhhbmRsZXJzIGZvciBwcm92aWRlclxuICAgKiBAcmV0dXJucyAtIHByb3ZpZGVyIC0gUmV0dXJucyB0aGUgcHJvdmlkZXJQcm94eVxuICAgKi9cbiAgaW5pdGlhbGl6ZVByb3ZpZGVyKGhhbmRsZXJzKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IEpSUENFbmdpbmUoKTtcbiAgICBjb25zdCBjb21tdW5pY2F0aW9uTWlkZGxld2FyZSA9IGNyZWF0ZUNvbW11bmljYXRpb25NaWRkbGV3YXJlKGhhbmRsZXJzKTtcbiAgICBlbmdpbmUucHVzaChjb21tdW5pY2F0aW9uTWlkZGxld2FyZSk7XG4gICAgY29uc3QgY29tbXVuaWNhdGlvblByb3ZpZGVyID0gcHJvdmlkZXJGcm9tRW5naW5lKGVuZ2luZSk7XG4gICAgdGhpcy5zZXRDb21tdW5pY2F0aW9uUHJvdmlkZXIoY29tbXVuaWNhdGlvblByb3ZpZGVyKTtcbiAgfVxuICBzZXRDb21tdW5pY2F0aW9uUHJvdmlkZXIoY29tbXVuaWNhdGlvblByb3ZpZGVyKSB7XG4gICAgaWYgKHRoaXMuX2NvbW11bmljYXRpb25Qcm92aWRlclByb3h5KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLl9jb21tdW5pY2F0aW9uUHJvdmlkZXJQcm94eS5zZXRUYXJnZXQoY29tbXVuaWNhdGlvblByb3ZpZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29tbXVuaWNhdGlvblByb3ZpZGVyUHJveHkgPSBjcmVhdGVTd2FwcGFibGVQcm94eShjb21tdW5pY2F0aW9uUHJvdmlkZXIpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBDb21tdW5pY2F0aW9uV2luZG93TWFuYWdlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlV2luZG93UnBjXCIsIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCwgZW5kKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGFyYW1zXG4gICAgICB9ID0gcmVxdWVzdDtcbiAgICAgIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkNMT1NFRF9XSU5ET1cpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0gPSBwYXJhbXM7XG4gICAgICAgIC8vIEkndmUgYmVlbiBpbmZvcm1lZCB0aGF0IGEgd2luZG93IGhhcyBiZWVuIGNsb3NlZFxuICAgICAgICB0aGlzLmVtaXQoYCR7d2luZG93SWR9OmNsb3NlZGApO1xuICAgICAgICByZXNwb25zZS5yZXN1bHQgPSB0cnVlO1xuICAgICAgICBlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBCVVRUT05fUE9TSVRJT04gPSB7XG4gIEJPVFRPTV9MRUZUOiBcImJvdHRvbS1sZWZ0XCIsXG4gIFRPUF9MRUZUOiBcInRvcC1sZWZ0XCIsXG4gIEJPVFRPTV9SSUdIVDogXCJib3R0b20tcmlnaHRcIixcbiAgVE9QX1JJR0hUOiBcInRvcC1yaWdodFwiXG59O1xuY29uc3QgQ09ORklSTUFUSU9OX1NUUkFURUdZID0ge1xuICBQT1BVUDogXCJwb3B1cFwiLFxuICBNT0RBTDogXCJtb2RhbFwiLFxuICBBVVRPX0FQUFJPVkU6IFwiYXV0by1hcHByb3ZlXCIsXG4gIERFRkFVTFQ6IFwiZGVmYXVsdFwiXG59O1xuXG4vKipcbiAqIFN0YXRlIGNoYW5nZSBjYWxsYmFja3NcbiAqL1xuXG4vKipcbiAqIEJhc2UgY29udHJvbGxlciBjb25maWd1cmF0aW9uXG4gKi9cblxuLyoqXG4gKiBCYXNlIHN0YXRlIHJlcHJlc2VudGF0aW9uXG4gKi9cblxuY29uc3QgTE9HSU5fUFJPVklERVIgPSB7XG4gIEdPT0dMRTogXCJnb29nbGVcIixcbiAgRkFDRUJPT0s6IFwiZmFjZWJvb2tcIixcbiAgUkVERElUOiBcInJlZGRpdFwiLFxuICBESVNDT1JEOiBcImRpc2NvcmRcIixcbiAgVFdJVENIOiBcInR3aXRjaFwiLFxuICBBUFBMRTogXCJhcHBsZVwiLFxuICBMSU5FOiBcImxpbmVcIixcbiAgR0lUSFVCOiBcImdpdGh1YlwiLFxuICBLQUtBTzogXCJrYWthb1wiLFxuICBMSU5LRURJTjogXCJsaW5rZWRpblwiLFxuICBUV0lUVEVSOiBcInR3aXR0ZXJcIixcbiAgV0VJQk86IFwid2VpYm9cIixcbiAgV0VDSEFUOiBcIndlY2hhdFwiLFxuICBFTUFJTF9QQVNTV09SRExFU1M6IFwiZW1haWxfcGFzc3dvcmRsZXNzXCIsXG4gIFNNU19QQVNTV09SRExFU1M6IFwic21zX3Bhc3N3b3JkbGVzc1wiXG59O1xuLyoqXG4gKiB7QGxhYmVsIGxvZ2luUHJvdmlkZXJUeXBlfVxuICovXG5cbmNvbnN0IFBBWU1FTlRfUFJPVklERVIgPSB7XG4gIE1PT05QQVk6IFwibW9vbnBheVwiLFxuICBXWVJFOiBcInd5cmVcIixcbiAgUkFNUE5FVFdPUks6IFwicmFtcG5ldHdvcmtcIixcbiAgWEFOUE9PTDogXCJ4YW5wb29sXCIsXG4gIE1FUkNVUllPOiBcIm1lcmN1cnlvXCIsXG4gIFRSQU5TQUs6IFwidHJhbnNha1wiXG59O1xuXG5mdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB0byBzdG9yZSB0aGUgcmVzdWx0c1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAvLyBJdGVyYXRlIG92ZXIgYWxsIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3RcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuICAgIGlmICghcHJlZGljYXRlKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgdG8gc3RvcmUgdGhlIHJlc3VsdHNcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2xvbmVEZWVwKG9iamVjdCkge1xuICB0cnkge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmplY3QpKTtcbiAgfVxufVxuXG5jb25zdCBhdXRoU2VydmVyID0gXCJodHRwczovL2F1dGhqcy53ZWIzYXV0aC5pb1wiO1xuY29uc3Qgc2lnbkNoYWxsZW5nZSA9IGFzeW5jIChwYXlsb2FkLCBjaGFpbk5hbWVzcGFjZSkgPT4ge1xuICBjb25zdCB0ID0gY2hhaW5OYW1lc3BhY2UgPT09IFwic29sYW5hXCIgPyBcInNpcDk5XCIgOiBcImVpcDE5MVwiO1xuICBjb25zdCBoZWFkZXIgPSB7XG4gICAgdFxuICB9O1xuICBjb25zdCBuZXR3b3JrID0gY2hhaW5OYW1lc3BhY2UgPT09IFwic29sYW5hXCIgPyBcInNvbGFuYVwiIDogXCJldGhlcmV1bVwiO1xuICBjb25zdCBkYXRhID0ge1xuICAgIHBheWxvYWQsXG4gICAgaGVhZGVyLFxuICAgIG5ldHdvcmtcbiAgfTtcbiAgY29uc3QgcmVzID0gYXdhaXQgcG9zdChgJHthdXRoU2VydmVyfS9zaXd3L2dldGAsIGRhdGEpO1xuICBpZiAoIXJlcy5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSB1c2VyLCBQbGVhc2UgcmVhY2ggb3V0IHRvIFdlYjNBdXRoIFN1cHBvcnQgdGVhbVwiKTtcbiAgfVxuICByZXR1cm4gcmVzLmNoYWxsZW5nZTtcbn07XG5jb25zdCB2ZXJpZnlTaWduZWRDaGFsbGVuZ2UgPSBhc3luYyAoY2hhaW5OYW1lc3BhY2UsIHNpZ25lZE1lc3NhZ2UsIGNoYWxsZW5nZSwgaXNzdWVyLCBzZXNzaW9uVGltZSwgY2xpZW50SWQsIHdlYjNBdXRoTmV0d29yaywgYXVkaWVuY2UsIGFkZGl0aW9uYWxNZXRhZGF0YSkgPT4ge1xuICB2YXIgX3dpbmRvdyRsb2NhdGlvbjtcbiAgY29uc3QgdCA9IGNoYWluTmFtZXNwYWNlID09PSBcInNvbGFuYVwiID8gXCJzaXA5OVwiIDogXCJlaXAxOTFcIjtcbiAgY29uc3Qgc2lnRGF0YSA9IF9vYmplY3RTcHJlYWQoe1xuICAgIHNpZ25hdHVyZToge1xuICAgICAgczogc2lnbmVkTWVzc2FnZSxcbiAgICAgIHRcbiAgICB9LFxuICAgIG1lc3NhZ2U6IGNoYWxsZW5nZSxcbiAgICBpc3N1ZXIsXG4gICAgYXVkaWVuY2U6IGF1ZGllbmNlIHx8ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gKChfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfd2luZG93JGxvY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93JGxvY2F0aW9uLmhvc3RuYW1lKSB8fCBcImNvbTovL3JlYWN0bmF0aXZlXCIgOiBcImNvbTovL3JlYWN0bmF0aXZlXCIpLFxuICAgIHRpbWVvdXQ6IHNlc3Npb25UaW1lXG4gIH0sIGFkZGl0aW9uYWxNZXRhZGF0YSB8fCB7fSk7XG4gIGNvbnN0IGlkVG9rZW5SZXMgPSBhd2FpdCBwb3N0KGAke2F1dGhTZXJ2ZXJ9L3Npd3cvdmVyaWZ5YCwgc2lnRGF0YSwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgICB3YWxsZXRfcHJvdmlkZXI6IGlzc3VlcixcbiAgICAgIHdlYjNhdXRoX25ldHdvcms6IHdlYjNBdXRoTmV0d29ya1xuICAgIH1cbiAgfSk7XG4gIGlmICghaWRUb2tlblJlcy5zdWNjZXNzKSB7XG4gICAgbG9nLmVycm9yKFwiRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSB1c2VyLCAsbWVzc2FnZSB2ZXJpZmljYXRpb24gZmFpbGVkXCIsIGlkVG9rZW5SZXMuZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBhdXRoZW50aWNhdGUgdXNlciwgLG1lc3NhZ2UgdmVyaWZpY2F0aW9uIGZhaWxlZFwiKTtcbiAgfVxuICByZXR1cm4gaWRUb2tlblJlcy50b2tlbjtcbn07XG5cbmNvbnN0IGdldFR4U3RhdHVzVGV4dCA9IHR4U3RhdHVzID0+IHtcbiAgc3dpdGNoICh0eFN0YXR1cykge1xuICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgIGNhc2UgXCJ1bmFwcHJvdmVkXCI6XG4gICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgcmV0dXJuIEFDVElWSVRZX1NUQVRVU19VTlNVQ0NFU1NGVUw7XG4gICAgY2FzZSBcImNvbmZpcm1lZFwiOlxuICAgICAgcmV0dXJuIEFDVElWSVRZX1NUQVRVU19TVUNDRVNTRlVMO1xuICAgIGNhc2UgXCJzdWJtaXR0ZWRcIjpcbiAgICAgIHJldHVybiBBQ1RJVklUWV9TVEFUVVNfUEVORElORztcbiAgICBjYXNlIFwiY2FuY2VsbGVkXCI6XG4gICAgICByZXR1cm4gQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExFRDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXR5IGZ1bmN0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgY29uc3QgaGV4ID0gaS50b1N0cmluZygxNik7XG4gIHJldHVybiBgMHgke2hleH1gO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyLiBEb24ndCB1c2UgZm9yIGNyeXB0b2dyYXBoaWMgcHVycG9zZXMuXG4gKiBAcmV0dXJucyBhIHJhbmRvbSBudW1iZXJcbiAqL1xuY29uc3QgcmFuZG9tSWQgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuLyoqXG4gKiBQYWRzIHRoZSBmcm9udCBvZiB0aGUgZ2l2ZW4gaGV4IHN0cmluZyB3aXRoIHplcm9lcyB1bnRpbCBpdCByZWFjaGVzIHRoZVxuICogdGFyZ2V0IGxlbmd0aC4gSWYgdGhlIGlucHV0IHN0cmluZyBpcyBhbHJlYWR5IGxvbmdlciB0aGFuIG9yIGVxdWFsIHRvIHRoZVxuICogdGFyZ2V0IGxlbmd0aCwgaXQgaXMgcmV0dXJuZWQgdW5tb2RpZmllZC5cbiAqXG4gKiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIFwiMHhcIi1wcmVmaXhlZCBvciBub3QgYSBoZXggc3RyaW5nLCBhbiBlcnJvciB3aWxsIGJlXG4gKiB0aHJvd24uXG4gKlxuICogQHBhcmFtIGhleFN0cmluZyAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gcGFkIHdpdGggemVyb2VzLlxuICogQHBhcmFtIHRhcmdldExlbmd0aCAtIFRoZSB0YXJnZXQgbGVuZ3RoIG9mIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaW5wdXQgc3RyaW5nIGZyb250LXBhZGRlZCB3aXRoIHplcm9lcywgb3IgdGhlIG9yaWdpbmFsIHN0cmluZ1xuICogaWYgaXQgd2FzIGFscmVhZHkgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRvIHRoZSB0YXJnZXQgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBwYWRXaXRoWmVyb2VzKGhleFN0cmluZywgdGFyZ2V0TGVuZ3RoKSB7XG4gIGlmIChoZXhTdHJpbmcgIT09IFwiXCIgJiYgIS9eW2EtZjAtOV0rJC9pdS50ZXN0KGhleFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIHVucHJlZml4ZWQgaGV4IHN0cmluZy4gUmVjZWl2ZWQ6ICR7aGV4U3RyaW5nfWApO1xuICB9XG4gIGlmICh0YXJnZXRMZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIHRhcmdldCBsZW5ndGguIFJlY2VpdmVkOiAke3RhcmdldExlbmd0aH1gKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydC5jYWxsKGhleFN0cmluZywgdGFyZ2V0TGVuZ3RoLCBcIjBcIik7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGV4dGVuZGVkIEVDRFNBIHNpZ25hdHVyZSBpbnRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSAndicgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIHIgLSBUaGUgJ3InIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBzIC0gVGhlICdzJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIEVDRFNBIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gY29uY2F0U2lnKHYsIHIsIHMpIHtcbiAgY29uc3QgclNpZyA9IGZyb21TaWduZWQocik7XG4gIGNvbnN0IHNTaWcgPSBmcm9tU2lnbmVkKHMpO1xuICBjb25zdCB2U2lnID0gYnl0ZXNUb0JpZ0ludCh2KTtcbiAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoQnVmZmVyLmZyb20odG9VbnNpZ25lZChyU2lnKSkudG9TdHJpbmcoXCJoZXhcIiksIDY0KTtcbiAgY29uc3Qgc1N0ciA9IHBhZFdpdGhaZXJvZXMoQnVmZmVyLmZyb20odG9VbnNpZ25lZChzU2lnKSkudG9TdHJpbmcoXCJoZXhcIiksIDY0KTtcbiAgY29uc3QgdlN0ciA9IHN0cmlwSGV4UHJlZml4KGJpZ0ludFRvSGV4KHZTaWcpKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChyU3RyLmNvbmNhdChzU3RyLCB2U3RyKSk7XG59XG5mdW5jdGlvbiB0aW1lb3V0JDEoZHVyYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXRSZWYgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYpO1xuICAgIH0sIGR1cmF0aW9uKTtcbiAgfSk7XG59XG5jb25zdCBnZXRIZWFkZXJzID0gKGp3dCwgcHVibGljQWRkcmVzcykgPT4ge1xuICByZXR1cm4ge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtqd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgXCJwdWJsaWMtYWRkcmVzc1wiOiBwdWJsaWNBZGRyZXNzXG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBUZXh0L251bWJlciBmb3JtYXR0aW5nIHV0aWxpdGllc1xuICovXG5jb25zdCBmb3JtYXRTbWFsbE51bWJlcnMgPSAobnVtYmVyLCBjdXJyZW5jeSA9IFwidXNkXCIsIG5vVGlsZGUgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBmaW5hbE51bWJlciA9IEJpZ051bWJlci5pc0JpZ051bWJlcihudW1iZXIpID8gbnVtYmVyLnRvTnVtYmVyKCkgOiBudW1iZXI7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZpbmFsTnVtYmVyKSkgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHZhbHVlID0gY3VycmVuY3kudG9Mb3dlckNhc2UoKSA9PT0gXCJ1c2RcIiA/IHBhcnNlRmxvYXQoTnVtYmVyKGZpbmFsTnVtYmVyKS50b0ZpeGVkKDIpKSA6IHBhcnNlRmxvYXQoTnVtYmVyKGZpbmFsTnVtYmVyKS50b0ZpeGVkKDUpKTtcbiAgY29uc3QgdGlsZGUgPSB2YWx1ZSA+IDAgPyBcIn4gXCIgOiBcIlwiO1xuICByZXR1cm4gYCR7Y3VycmVuY3kudG9Mb3dlckNhc2UoKSA9PT0gXCJ1c2RcIiB8fCBub1RpbGRlID8gXCJcIiA6IHRpbGRlfSR7TnVtYmVyKHZhbHVlKX0gJHtjdXJyZW5jeS50b1VwcGVyQ2FzZSgpfWA7XG59O1xuY29uc3QgYWRkcmVzc1NsaWNlciA9IChhZGRyZXNzLCBzbGljZUxlbmd0aCA9IDUpID0+IHtcbiAgaWYgKCFhZGRyZXNzKSByZXR1cm4gXCJcIjtcbiAgaWYgKGFkZHJlc3MubGVuZ3RoIDwgMTEpIHtcbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuICBpZiAodHlwZW9mIGFkZHJlc3MgIT09IFwic3RyaW5nXCIpIHJldHVybiBcIlwiO1xuICByZXR1cm4gYCR7YWRkcmVzcy5zbGljZSgwLCBzbGljZUxlbmd0aCl9Li4uJHthZGRyZXNzLnNsaWNlKC1zbGljZUxlbmd0aCl9YDtcbn07XG5jb25zdCBzaWduaWZpY2FudERpZ2l0cyA9IChudW1iZXIsIHBlcmMgPSBmYWxzZSwgbGVuZ3RoXyA9IDIpID0+IHtcbiAgbGV0IGlucHV0ID0gIUJpZ051bWJlci5pc0JpZ051bWJlcihudW1iZXIpID8gbmV3IEJpZ051bWJlcihudW1iZXIpIDogbnVtYmVyO1xuICBpZiAoaW5wdXQuaXNaZXJvKCkpIHJldHVybiBpbnB1dDtcbiAgaWYgKHBlcmMpIHtcbiAgICBpbnB1dCA9IGlucHV0LnRpbWVzKG5ldyBCaWdOdW1iZXIoMTAwKSk7XG4gIH1cbiAgbGV0IGRlcHRoO1xuICBpZiAoaW5wdXQuZ3RlKG5ldyBCaWdOdW1iZXIoMSkpKSB7XG4gICAgZGVwdGggPSBsZW5ndGhfO1xuICB9IGVsc2Uge1xuICAgIGRlcHRoID0gbGVuZ3RoXyAtIDEgKyBNYXRoLmNlaWwoTWF0aC5sb2cxMChuZXcgQmlnTnVtYmVyKFwiMVwiKS5kaXYoaW5wdXQpLnRvTnVtYmVyKCkpKTtcbiAgfVxuICBjb25zdCBzaGlmdCA9IG5ldyBCaWdOdW1iZXIoMTApLnBvdyhuZXcgQmlnTnVtYmVyKGRlcHRoKSk7XG4gIGNvbnN0IHJvdW5kZWROdW1iZXIgPSBNYXRoLnJvdW5kKHNoaWZ0LnRpbWVzKGlucHV0KS50b051bWJlcigpKSAvIHNoaWZ0LnRvTnVtYmVyKCk7XG4gIHJldHVybiByb3VuZGVkTnVtYmVyO1xufTtcbmNvbnN0IGZvcm1hdERhdGUgPSBpbnB1dERhdGUgPT4ge1xuICBjb25zdCBtb250aExpc3QgPSBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl07XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpbnB1dERhdGUpO1xuICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKTtcbiAgY29uc3QgbW9udGggPSBtb250aExpc3RbZGF0ZS5nZXRNb250aCgpXTtcbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgcmV0dXJuIGAke2RheX0gJHttb250aH0gJHt5ZWFyfWA7XG59O1xuY29uc3QgZm9ybWF0VGltZSA9IHRpbWUgPT4ge1xuICByZXR1cm4gbmV3IERhdGUodGltZSkudG9UaW1lU3RyaW5nKCkuc2xpY2UoMCwgOCk7XG59O1xuXG4vKipcbiAqIE5ldHdvcmsgdXRpbGl0aWVzXG4gKi9cbmNvbnN0IHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsgPSAodHJhbnNhY3Rpb24sIGNoYWluSWQpID0+IHtcbiAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5jaGFpbklkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmNoYWluSWQgPT09IGNoYWluSWQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTaWduaW5nIHV0aWxzXG4gKi9cbmNvbnN0IGhhc2hNZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gIGNvbnN0IGJ1ZmZlcmVkTWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIFwidXRmOFwiKTtcbiAgY29uc3QgZWwgPSBoYXNoUGVyc29uYWxNZXNzYWdlKGJ1ZmZlcmVkTWVzc2FnZSk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShlbCk7XG59O1xuY29uc3Qgc2lnbk1lc3NhZ2UgPSBhc3luYyAocHJpdmF0ZUtleSwgZGF0YSkgPT4ge1xuICBjb25zdCBwcml2S2V5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgXCJoZXhcIik7XG4gIGNvbnN0IG1lc3NhZ2UgPSBzdHJpcEhleFByZWZpeChkYXRhKTtcbiAgY29uc3QgbXNnU2lnID0gZWNzaWduKEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIFwiaGV4XCIpLCBwcml2S2V5KTtcbiAgY29uc3QgcmF3TXNnU2lnID0gY29uY2F0U2lnKEJ1ZmZlci5mcm9tKGJpZ0ludFRvQnl0ZXMobXNnU2lnLnYpKSwgQnVmZmVyLmZyb20obXNnU2lnLnIpLCBCdWZmZXIuZnJvbShtc2dTaWcucykpO1xuICByZXR1cm4gcmF3TXNnU2lnO1xufTtcblxuLyoqXG4gKiBwb3B1cCBoYW5kbGVyIHV0aWxzXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHVwRmVhdHVyZXMoe1xuICB3aWR0aDogdyxcbiAgaGVpZ2h0OiBoXG59KSB7XG4gIC8vIEZpeGVzIGR1YWwtc2NyZWVuIHBvc2l0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3N0IGJyb3dzZXJzICAgICAgRmlyZWZveFxuICBjb25zdCBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0ICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuTGVmdCA6IHdpbmRvdy5zY3JlZW5YO1xuICBjb25zdCBkdWFsU2NyZWVuVG9wID0gd2luZG93LnNjcmVlblRvcCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlblRvcCA6IHdpbmRvdy5zY3JlZW5ZO1xuICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoID8gd2luZG93LmlubmVyV2lkdGggOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiB3aW5kb3cuc2NyZWVuLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xuICBjb25zdCBzeXN0ZW1ab29tID0gMTsgLy8gTm8gcmVsaWFibGUgZXN0aW1hdGVcblxuICBjb25zdCBsZWZ0ID0gTWF0aC5hYnMoKHdpZHRoIC0gdykgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5MZWZ0KTtcbiAgY29uc3QgdG9wID0gTWF0aC5hYnMoKGhlaWdodCAtIGgpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuVG9wKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBgdGl0bGViYXI9MCx0b29sYmFyPTAsc3RhdHVzPTAsbG9jYXRpb249MCxtZW51YmFyPTAsaGVpZ2h0PSR7aCAvIHN5c3RlbVpvb219LHdpZHRoPSR7dyAvIHN5c3RlbVpvb219LHRvcD0ke3RvcH0sbGVmdD0ke2xlZnR9YDtcbiAgcmV0dXJuIGZlYXR1cmVzO1xufVxuY29uc3QgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMgPSB7XG4gIHR5cGU6IFwic2VydmVyXCIsXG4gIC8vIHR5cGU6ICdsb2NhbHN0b3JhZ2UnLCAvLyAob3B0aW9uYWwpIGVuZm9yY2UgYSB0eXBlLCBvbmVPZlsnbmF0aXZlJywgJ2lkYicsICdsb2NhbHN0b3JhZ2UnLCAnbm9kZSddXG4gIHdlYldvcmtlclN1cHBvcnQ6IGZhbHNlIC8vIChvcHRpb25hbCkgc2V0IHRoaXMgdG8gZmFsc2UgaWYgeW91IGtub3cgdGhhdCB5b3VyIGNoYW5uZWwgd2lsbCBuZXZlciBiZSB1c2VkIGluIGEgV2ViV29ya2VyIChpbmNyZWFzZXMgcGVyZm9ybWFuY2UpXG59O1xuZnVuY3Rpb24gZ2V0Q3VzdG9tRGV2aWNlSW5mbygpIHtcbiAgdmFyIF9uYXZpZ2F0b3I7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGlmICgoX25hdmlnYXRvciA9IG5hdmlnYXRvcikgIT09IG51bGwgJiYgX25hdmlnYXRvciAhPT0gdm9pZCAwICYmIF9uYXZpZ2F0b3IuYnJhdmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlcjogXCJCcmF2ZVwiXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVXNlckVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmNvbnN0IGhhbmRsZVJlZGlyZWN0UGFyYW1ldGVycyA9IChoYXNoLCBxdWVyeVBhcmFtZXRlcnMpID0+IHtcbiAgY29uc3QgaGFzaFBhcmFtZXRlcnMgPSB7fTtcbiAgY29uc3QgaGFzaFVybCA9IG5ldyBVUkwoYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vPyR7aGFzaC5zbGljZSgxKX1gKTtcbiAgaGFzaFVybC5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGhhc2hQYXJhbWV0ZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIGxldCBpbnN0YW5jZVBhcmFtZXRlcnMgPSB7fTtcbiAgbGV0IGVycm9yID0gXCJcIjtcbiAgaWYgKCFxdWVyeVBhcmFtZXRlcnMud2luZG93SWQpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMoaGFzaFBhcmFtZXRlcnMpLmxlbmd0aCA+IDAgJiYgaGFzaFBhcmFtZXRlcnMuc3RhdGUpIHtcbiAgICAgIGluc3RhbmNlUGFyYW1ldGVycyA9IEpTT04ucGFyc2Uoc2FmZWF0b2IoZGVjb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudChoYXNoUGFyYW1ldGVycy5zdGF0ZSkpKSkgfHwge307XG4gICAgICBlcnJvciA9IGhhc2hQYXJhbWV0ZXJzLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGhhc2hQYXJhbWV0ZXJzLmVycm9yIHx8IGVycm9yO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXMocXVlcnlQYXJhbWV0ZXJzKS5sZW5ndGggPiAwICYmIHF1ZXJ5UGFyYW1ldGVycy5zdGF0ZSkge1xuICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzID0gSlNPTi5wYXJzZShzYWZlYXRvYihkZWNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHF1ZXJ5UGFyYW1ldGVycy5zdGF0ZSkpKSkgfHwge307XG4gICAgICBpZiAocXVlcnlQYXJhbWV0ZXJzLmVycm9yKSBlcnJvciA9IHF1ZXJ5UGFyYW1ldGVycy5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlcnJvcixcbiAgICBpbnN0YW5jZVBhcmFtZXRlcnMsXG4gICAgaGFzaFBhcmFtZXRlcnNcbiAgfTtcbn07XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gIH0pO1xufVxuY29uc3QgaXNVbmF1dGhvcml6ZWRFcnJvciA9IGVycm9yID0+IHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDE7XG59O1xuXG5jbGFzcyBCYXNlS2V5cmluZ0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcgPSB7fSxcbiAgICBzdGF0ZVxuICB9KSB7XG4gICAgdmFyIF9zdGF0ZSR3YWxsZXRzO1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICB3YWxsZXRzOiAoX3N0YXRlJHdhbGxldHMgPSBzdGF0ZS53YWxsZXRzKSAhPT0gbnVsbCAmJiBfc3RhdGUkd2FsbGV0cyAhPT0gdm9pZCAwID8gX3N0YXRlJHdhbGxldHMgOiBbXVxuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvLyBmb3Igc2lnbmluZyBhdXRoIG1lc3NhZ2VcbiAgYXN5bmMgc2lnbkF1dGhNZXNzYWdlKGFkZHJlc3MsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gdGhpcy5zdGF0ZS53YWxsZXRzLmZpbmQoeCA9PiB4LmFkZHJlc3MgPT09IGFkZHJlc3MpO1xuICAgIGlmICgha2V5cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWRNZXNzYWdlID0gaGFzaE1lc3NhZ2UobWVzc2FnZSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgcmF3TWVzc2FnZVNpZyA9IGF3YWl0IHNpZ25NZXNzYWdlKGtleXJpbmcucHJpdmF0ZUtleSwgaGFzaGVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIHJhd01lc3NhZ2VTaWc7XG4gIH1cbn1cblxuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbi8vIGlnbm9yZSBzZXJ2ZXIgb3ZlcmxvYWQgZXJyb3JzXG5cIkdhdGV3YXkgdGltZW91dFwiLCBcIkVUSU1FRE9VVFwiLFxuLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbi8vIG9yIHRydW5jYXRlZCBqc29uIHJlc3BvbnNlc1xuXCJmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keVwiLFxuLy8gaWdub3JlIGVycm9ycyB3aGVyZSBodHRwIHJlcSBmYWlsZWQgdG8gZXN0YWJsaXNoXG5cIkZhaWxlZCB0byBmZXRjaFwiXTtcbmZ1bmN0aW9uIGNoZWNrRm9ySHR0cEVycm9ycyhmZXRjaFJlcykge1xuICAvLyBjaGVjayBmb3IgZXJyb3JzXG4gIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDU6XG4gICAgICB0aHJvdyBycGNFcnJvcnMubWV0aG9kTm90Rm91bmQoKTtcbiAgICBjYXNlIDQxODpcbiAgICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbCh7XG4gICAgICAgIG1lc3NhZ2U6IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY2F1c2U6IGZldGNoUmVzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGNhc2UgNTAzOlxuICAgIGNhc2UgNTA0OlxuICAgICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKHtcbiAgICAgICAgbWVzc2FnZTogYEdhdGV3YXkgdGltZW91dC4gVGhlIHJlcXVlc3QgdG9vayB0b28gbG9uZyB0byBwcm9jZXNzLmAgKyBgVGhpcyBjYW4gaGFwcGVuIHdoZW4gcXVlcnlpbmcgb3ZlciB0b28gd2lkZSBhIGJsb2NrIHJhbmdlLmBcbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBib2R5KSB7XG4gIC8vIGNoZWNrIGZvciBlcnJvciBjb2RlXG4gIGlmIChmZXRjaFJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbCh7XG4gICAgICBtZXNzYWdlOiBgTm9uLTIwMCBzdGF0dXMgY29kZTogJyR7ZmV0Y2hSZXMuc3RhdHVzfSdgLFxuICAgICAgZGF0YTogYm9keVxuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBycGMgZXJyb3JcbiAgaWYgKGJvZHkuZXJyb3IpIHtcbiAgICB0aHJvdyBycGNFcnJvcnMuaW50ZXJuYWwoe1xuICAgICAgZGF0YTogYm9keS5lcnJvclxuICAgIH0pO1xuICB9XG4gIC8vIHJldHVybiBzdWNjZXNzZnVsIHJlc3VsdFxuICByZXR1cm4gYm9keS5yZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoe1xuICByZXEsXG4gIHJwY1RhcmdldCxcbiAgb3JpZ2luSHR0cEhlYWRlcktleVxufSkge1xuICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHJwY1RhcmdldCk7XG5cbiAgLy8gcHJlcGFyZSBwYXlsb2FkXG4gIC8vIGNvcHkgb25seSBjYW5vbmljYWwganNvbiBycGMgcHJvcGVydGllc1xuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIGlkOiByZXEuaWQsXG4gICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgIHBhcmFtczogcmVxLnBhcmFtc1xuICB9O1xuXG4gIC8vIGV4dHJhY3QgJ29yaWdpbicgcGFyYW1ldGVyIGZyb20gcmVxdWVzdFxuICBjb25zdCBvcmlnaW5Eb21haW4gPSByZXEub3JpZ2luO1xuXG4gIC8vIHNlcmlhbGl6ZSByZXF1ZXN0IGJvZHlcbiAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcblxuICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBzZXJpYWxpemVkUGF5bG9hZFxuICB9O1xuXG4gIC8vIG9wdGlvbmFsOiBhZGQgcmVxdWVzdCBvcmlnaW4gYXMgaGVhZGVyXG4gIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgIGZldGNoUGFyYW1zLmhlYWRlcnNbb3JpZ2luSHR0cEhlYWRlcktleV0gPSBvcmlnaW5Eb21haW47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmZXRjaFVybDogcGFyc2VkVXJsLmhyZWYsXG4gICAgZmV0Y2hQYXJhbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoTWlkZGxld2FyZSh7XG4gIHJwY1RhcmdldCxcbiAgb3JpZ2luSHR0cEhlYWRlcktleVxufSkge1xuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgX25leHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBmZXRjaFVybCxcbiAgICAgIGZldGNoUGFyYW1zXG4gICAgfSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7XG4gICAgICByZXEsXG4gICAgICBycGNUYXJnZXQsXG4gICAgICBvcmlnaW5IdHRwSGVhZGVyS2V5XG4gICAgfSk7XG5cbiAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDU7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IDEwMDA7XG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmZXRjaFJlcyA9IGF3YWl0IGZldGNoKGZldGNoVXJsLCBmZXRjaFBhcmFtcyk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBodHRwIGVycnJvcnNcbiAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKTtcbiAgICAgICAgLy8gcGFyc2UgcmVzcG9uc2UgYm9keVxuICAgICAgICBjb25zdCBmZXRjaEJvZHkgPSBhd2FpdCBmZXRjaFJlcy5qc29uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGZldGNoQm9keSk7XG4gICAgICAgIC8vIHNldCByZXN1bHQgYW5kIGV4aXQgcmV0cnkgbG9vcFxuICAgICAgICByZXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gKGVyci5tZXNzYWdlIHx8IGVycikudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUocGhyYXNlID0+IGVyck1zZy5pbmNsdWRlcyhwaHJhc2UpKTtcbiAgICAgICAgLy8gcmUtdGhyb3cgZXJyb3IgaWYgbm90IHJldHJpYWJsZVxuICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBkZWxheSBiZWZvcmUgcmV0cnlpbmdcbiAgICAgIGF3YWl0IHRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmZXJyZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKF9yZXNvbHZlID0+IHtcbiAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlc29sdmUsXG4gICAgcHJvbWlzZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUoe1xuICBjYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0XG59KSB7XG4gIGNvbnN0IGluZmxpZ2h0UmVxdWVzdHMgPSB7fTtcbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXNvbHZlLFxuICAgICAgcHJvbWlzZVxuICAgIH0gPSBkZWZlcnJlZFByb21pc2UoKTtcbiAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMucHVzaChoYW5kbGVkUmVzID0+IHtcbiAgICAgIC8vIGFwcGVuZCBhIGNvcHkgb2YgdGhlIHJlc3VsdCBhbmQgZXJyb3IgdG8gdGhlIHJlc3BvbnNlXG4gICAgICByZXMucmVzdWx0ID0gY2xvbmVEZWVwKGhhbmRsZWRSZXMucmVzdWx0KTtcbiAgICAgIHJlcy5lcnJvciA9IGNsb25lRGVlcChoYW5kbGVkUmVzLmVycm9yKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVBY3RpdmVSZXF1ZXN0KHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgLy8gdXNlIHNldFRpbWVvdXQgc28gd2UgY2FuIHJlc29sdmUgb3VyIG9yaWdpbmFsIHJlcXVlc3QgZmlyc3RcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGhhbmRsZXIocmVzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gY2F0Y2ggZXJyb3Igc28gYWxsIHJlcXVlc3RzIGFyZSBoYW5kbGVkIGNvcnJlY3RseVxuICAgICAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgIC8vIGFsbG93IGNhY2ggdG8gYmUgc2tpcHBlZCBpZiBzbyBzcGVjaWZpZWRcbiAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG4gICAgLy8gZ2V0IGNhY2hlSWQsIGlmIGNhY2hlYWJsZVxuICAgIGNvbnN0IGNhY2hlSWQgPSBjYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0KHJlcSk7XG4gICAgLy8gaWYgbm90IGNhY2hlYWJsZSwgc2tpcFxuICAgIGlmICghY2FjaGVJZCkge1xuICAgICAgbG9nLmluZm8oXCJSZXF1ZXN0IGlzIG5vdCBjYWNoZWFibGUsIHByb2NlZWRpbmcuIHJlcSA9ICVvXCIsIHJlcSk7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgbWF0Y2hpbmcgcmVxdWVzdHNcbiAgICBsZXQgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAvLyBpZiBmb3VuZCwgd2FpdCBmb3IgdGhlIGFjdGl2ZSByZXF1ZXN0IHRvIGJlIGhhbmRsZWRcbiAgICBpZiAoYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAvLyBzZXR1cCB0aGUgcmVzcG9uc2UgbGlzdGVuZXIgYW5kIHdhaXQgZm9yIGl0IHRvIGJlIGNhbGxlZFxuICAgICAgLy8gaXQgd2lsbCBoYW5kbGUgY29weWluZyB0aGUgcmVzdWx0IGFuZCByZXF1ZXN0IGZpZWxkc1xuICAgICAgbG9nLmluZm8oXCJSdW5uaW5nICVpIGhhbmRsZXIocykgZm9yIHJlcXVlc3QgJW9cIiwgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmxlbmd0aCwgcmVxKTtcbiAgICAgIGF3YWl0IGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIHNldHVwIHJlc3BvbnNlIGhhbmRsZXIgYXJyYXkgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgPSBbXTtcbiAgICBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdID0gYWN0aXZlUmVxdWVzdEhhbmRsZXJzO1xuICAgIC8vIGFsbG93IHJlcXVlc3QgdG8gYmUgaGFuZGxlZCBub3JtYWxseVxuICAgIGxvZy5pbmZvKFwiQ2Fycnlpbmcgb3JpZ2luYWwgcmVxdWVzdCBmb3J3YXJkICVvXCIsIHJlcSk7XG4gICAgYXdhaXQgbmV4dCgpO1xuICAgIC8vIGNsZWFyIGluZmxpZ2h0IHJlcXVlc3RzXG4gICAgZGVsZXRlIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgLy8gc2NoZWR1bGUgYWN0aXZlUmVxdWVzdEhhbmRsZXJzIHRvIGJlIGhhbmRsZWRcbiAgICBsb2cuaW5mbyhcIlJ1bm5pbmcgJWkgY29sbGVjdGVkIGhhbmRsZXIocykgZm9yIHJlcXVlc3QgJW9cIiwgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmxlbmd0aCwgcmVxKTtcbiAgICBoYW5kbGVBY3RpdmVSZXF1ZXN0KHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKTtcbiAgICAvLyBjb21wbGV0ZVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxvZ2dlck1pZGRsZXdhcmUocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpIHtcbiAgICBuZXh0KGNhbGxiYWNrID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICBsb2cud2FybihcIkVycm9yIGluIFJQQyByZXNwb25zZTpcXG5cIiwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QuaXNUb3J1c0ludGVybmFsKSByZXR1cm47XG4gICAgICBsb2cuaW5mbyhgUlBDICgke29wdGlvbnMub3JpZ2lufSk6YCwgcmVxdWVzdCwgXCItPlwiLCByZXNwb25zZSk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPcmlnaW5NaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9yaWdpbk1pZGRsZXdhcmUocmVxdWVzdCwgXywgbmV4dCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmVxdWVzdC5vcmlnaW4gPSBvcHRpb25zLm9yaWdpbjtcbiAgICBuZXh0KCk7XG4gIH07XG59XG5cbmNvbnN0IGNyZWF0ZVJhbmRvbUlkID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuY29uc3QgQ0hBSU5fTkFNRVNQQUNFUyA9IHtcbiAgRUlQMTU1OiBcImVpcDE1NVwiLFxuICBTT0xBTkE6IFwic29sYW5hXCIsXG4gIENBU1BFUjogXCJjYXNwZXJcIixcbiAgWFJQTDogXCJ4cnBsXCIsXG4gIE9USEVSOiBcIm90aGVyXCJcbn07XG4vLyBlaXAxNTUgZm9yIGFsbCBldm0gY2hhaW5zXG5cbi8qKlxuICogQ3VzdG9tIG5ldHdvcmsgcHJvcGVydGllc1xuICogQGV4YW1wbGUgaXNFSVAxNTU5Q29tcGF0aWJsZTogdHJ1ZSBldGMuXG4gKi9cblxuLyoqXG4gKlxuICovXG5cbmNsYXNzIEJyb2FkY2FzdENoYW5uZWxIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbFByZWZpeCwgaW5zdGFuY2VJZCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJjXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbFwiLCB2b2lkIDApO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgY29uc3Qgd2luZG93SWQgPSBxdWVyeVBhcmFtZXRlcnMuZ2V0KFwid2luZG93SWRcIik7XG4gICAgdGhpcy5jaGFubmVsID0gYCR7Y2hhbm5lbFByZWZpeH1fJHtpbnN0YW5jZUlkfV8ke3dpbmRvd0lkfWA7XG4gICAgdGhpcy5iYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRoaXMuY2hhbm5lbCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICB9XG4gIGdldE1lc3NhZ2VGcm9tQ2hhbm5lbCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5iYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XG4gICAgICAgIHRoaXMuYmMuY2xvc2UoKTtcbiAgICAgICAgaWYgKGV2LmVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGV2LmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGV2LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdHlwZTogUE9QVVBfTE9BREVEXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFN0cmVhbVdpbmRvdyBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyxcbiAgICBzdGF0ZSA9IHt9XG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIC8vIGlmIHdpbmRvdyBoYXMgYmVlbiBjbG9zZWQgYnkgdXNlcnNcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbG9zZWRcIiwgZmFsc2UpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcbiAgICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXJcbiAgICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgIGxldCBwb3B1cFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLm9uY2UoYCR7dGhpcy5zdGF0ZS53aW5kb3dJZH06Y2xvc2VkYCwgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgLy8gV2luZG93IGlzIG5vdCBvcGVuIHlldFxuICAgICAgaWYgKCF0aGlzLnN0YXRlLndpbmRvd0lkKSB7XG4gICAgICAgIC8vIHNpbmNlLCB3ZSdyZSBvcGVuaW5nIHdpbmRvdyBub3csIG5vIG5lZWQgdG8gdGVsbCB3aW5kb3cgYW55dGhpbmdcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgIHdpbmRvd0lkOiByYW5kb21JZCgpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29uZmlnLmhhbmRsZVdpbmRvd0Jsb2NrQWxlcnQgIT09IFwiZnVuY3Rpb25cIikgcmVqZWN0KG5ldyBFcnJvcihcImhhbmRsZVdpbmRvd0Jsb2NrQWxlcnQgaXMgbm90IGEgZnVuY3Rpb25cIikpO1xuICAgICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlci5vbmNlKGAke3RoaXMuc3RhdGUud2luZG93SWR9OmlmcmFtZS1vcGVuZWRgLCAoKSA9PiB7XG4gICAgICAgICAgLy8gdGhpcyBtZWFucyBpZnJhbWUgaXMgZnVsbCBzY3JlZW4gbm93XG4gICAgICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgYmxvY2sgYWxlcnRzIGF0IGEgdGltZS4gc28sIHdlIGRvbid0IHNldCBpZnJhbWUgdG8gY2xvc2UgYWZ0ZXIgaGFuZGxpbmcgdGhpcyBoZXJlXG4gICAgICAgICAgdGhpcy5jb25maWcuaGFuZGxlV2luZG93QmxvY2tBbGVydCh7XG4gICAgICAgICAgICB3aW5kb3dJZDogdGhpcy5zdGF0ZS53aW5kb3dJZCxcbiAgICAgICAgICAgIGZpbmFsVXJsOiB0aGlzLnN0YXRlLnVybC5ocmVmXG4gICAgICAgICAgfSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUZWxsIHRoZSBvdGhlciBwYXJ0eSB0byBtYXhpbWl6ZSB0aGUgaWZyYW1lXG4gICAgICAgIGNvbW11bmljYXRpb25FbmdpbmUuZW1pdChcIm5vdGlmaWNhdGlvblwiLCB7XG4gICAgICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuSUZSQU1FX1NUQVRVUyxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGlzRnVsbFNjcmVlbjogdHJ1ZSxcbiAgICAgICAgICAgIHJpZDogdGhpcy5zdGF0ZS53aW5kb3dJZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIGEgcHJlLW9wZW5lZCB3aW5kb3cuIHNvLCB3ZSBuZWVkIHRvIHRlbGwgaXQgdG8gcmVkaXJlY3QgdG8gY29ycmVjdCB1cmwuIGl0J3MgY3VycmVudGx5IHdhaXRpbmcgb24gL3JlZGlyZWN0IGFuZCB1c2VzIGBSZWRpcmVjdEhhbmRsZXJgIGNvZGVcbiAgICAgICAgLy8gU2VuZCB0aGlzIHdpbmRvdyB3aXRoIGB3aW5kb3dJZGAgdGhlIHVybCB0byBvcGVuIHZpYSBiY1xuICAgICAgICBjb25zdCBjaGFubmVsTmFtZSA9IGAke0JST0FEQ0FTVF9DSEFOTkVMUy5SRURJUkVDVF9DSEFOTkVMfV8ke3RoaXMuY29uZmlnLmluc3RhbmNlSWR9XyR7dGhpcy5zdGF0ZS53aW5kb3dJZH1gO1xuICAgICAgICBjb25zdCBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGNoYW5uZWxOYW1lLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIGJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIGV2ID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9nLmluZm8oZXYsIGByZWNlaXZpbmcgZGF0YSBvbiBjaGFubmVsOiAke2JjLm5hbWV9YCk7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9ID0gZXY7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gUG9wdXAgc2F5cyBzb21lIGVycm9yLiBzbywgd2Ugc2F5IGl0J3Mgbm90IHJlYWxseSBvcGVuZWRcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgIH0gPSBldi5kYXRhO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFBPUFVQX0xPQURFRCkge1xuICAgICAgICAgICAgICBwb3B1cFN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICBhd2FpdCBiYy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLnN0YXRlLnVybC5ocmVmLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJcIiAvLyBObyBuZWVkIG9mIGEgbXNnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZy4gc28sIHdlIGNsb3NlIHRoYXQgd2luZG93XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBXZSBkb24ndCBrbm93IGlmIHRoZSBvdGhlciBlbmQgaXMgcmVhZHkgdG8gcmVjZWl2ZSB0aGlzIG1zZy4gU28sIHdlIGtlZXAgd3JpdGluZyB1bnRpbCBpdCByZWNlaXZlcyBhbmQgc2VuZHMgYmFjayBzb21ldGhpbmdcbiAgICAgICAgLy8gd2UgbmVlZCBiYWNrb2ZmIHN0cmF0ZWd5XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gd2FpdCBmb3IgZmlyc3QgYXR0ZW1wdCB0byBzdWNjZWVkL2ZhaWwgdW50aWwgdGhlIHNlY29uZCBhdHRlbXB0XG4gICAgICAgIC8vIElmIHdlIGdldCA0MjksIHdlIG5lZWQgdG8gd2FpdCBmb3IgYSB3aGlsZSBhbmQgdGhlbiB0cnkgYWdhaW5cblxuICAgICAgICBjb25zdCBwb3N0TXNnID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIHRoaXMgbmV2ZXIgdGhyb3dzXG4gICAgICAgICAgY29uc3QgbG9jYWxSZXNwb25zZSA9IGF3YWl0IGJjLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogU0VUVVBfQ09NUExFVEVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbG9jYWxSZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGN1cnJlbnREZWxheSA9IGJjLnR5cGUgPT09IFwic2VydmVyXCIgPyAxMDAwIDogMjAwO1xuICAgICAgICBjb25zdCByZWN1cnNpdmVGbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBpZiAoIXBvcHVwU3VjY2VzcyAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUmVzcG9uc2UgPSBhd2FpdCBwb3N0TXNnKCk7XG4gICAgICAgICAgICBpZiAoYmMudHlwZSA9PT0gXCJzZXJ2ZXJcIikge1xuICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGxvY2FsUmVzcG9uc2U7XG4gICAgICAgICAgICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciBhIHdoaWxlIGFuZCB0aGVuIHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgIGN1cnJlbnREZWxheSA9IE1hdGgucm91bmQoY3VycmVudERlbGF5ICogMS41KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5KTtcbiAgICAgICAgICAgIGF3YWl0IHJlY3Vyc2l2ZUZuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZWN1cnNpdmVGbigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW11bmljYXRpb25FbmdpbmVcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29tbXVuaWNhdGlvbkVuZ2luZS5lbWl0KFwibm90aWZpY2F0aW9uXCIsIHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLkNMT1NFX1dJTkRPVyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB3aW5kb3dJZDogdGhpcy5zdGF0ZS53aW5kb3dJZFxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qXG5TY2VuYXJpb3M6XG4xLiBPcGVuIGEgbm9ybWFsIHBvcHVwIHdpbmRvdyBhbmQgbm8gY29tbXVuaWNhdGlvbiB3aXRoIGl0IC0gVXNlIFBvcHVwSGFuZGxlclxuMi4gT3BlbiBhIHBvcHVwIHdpbmRvdyBhbmQgY29tbXVuaWNhdGUgd2l0aCBpdCAtIFVzZSBQb3B1cFdpdGhCY0hhbmRsZXIgKGNhbiBpbml0aWF0ZSBjb21tdW5pY2F0aW9uIGJ5IHdhaXRpbmcgZm9yIHdpbmRvdyB0byBvcGVuIG9yIG5vdClcblxuMy4gSWYgd2luZG93IGlzIGFscmVhZHkgb3BlbmVkLCBwYXNzIGluIHdpbmRvd0lkIHRvIHRoZSBwb3B1cCBoYW5kbGVyLiBcbiAgIFRoaXMgd2lsbCBlc3RhYmxpc2ggY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBwb3B1cCB3aW5kb3cgYW5kIHNlbmRzIGl0IGEgbmV3IHVybCB0byByZWRpcmVjdCB0b1xuXG5cbklmIHlvdSdyZSB0cnlpbmcgdG8gb3BlbiBhIHdpbmRvdyBhbmQgaXQgZ2V0cyBibG9ja2VkIChoYXBwZW5zIGlmIHlvdSdyZSBpbiBpZnJhbWUgb3IgZGVsYXkgYi93IGNsaWNrIGFuZCBvcGVuaW5nIHdpbmRvdyksXG4gIFN0cmVhbVdpbmRvdyBpcyBpbnZva2VkIGFuZCBpdCB3cml0ZXMgaW4gYSBjaGFubmVsIHRvIGRpc3BsYXkgYSBtZXNzYWdlIHRvIHRoZSB1c2VyXG5cbk9uY2UgdXNlciBjbGlja3Mgb24gdGhhdCBtb2RhbC9kaWFsb2csIHdlIHByZS1vcGVuIHRoZSB3aW5kb3cgYW5kIHBhc3MgaW4gdGhlIHdpbmRvd0lkIChnb2VzIHRvIDMpXG4qL1xuXG4vKipcbiAqIEhhbmRsZXMgcG9wdXAgd2luZG93IG1hbmFnZW1lbnQuXG4gKiBGb3IgYnJvYWRjYXN0IGNoYW5uZWwgY29tbXVuaWNhdGlvbiwgdXNlIHVybCB3aXRoIGBpbnN0YW5jZUlkYCBjb2RlZCBpbnRvIHN0YXRlIHBhcmFtZXRlci5cbiAqIFRoaXMgc3RhdGUgcGFyYW1ldGVyIHdpbGwgYmUgcGFzc2VkIGFjcm9zcyByZWRpcmVjdHMgYWNjb3JkaW5nIHRvIE9BdXRoIHNwZWMuXG4gKi9cbmNsYXNzIFBvcHVwSGFuZGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyxcbiAgICBzdGF0ZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICAvLyB0aGlzLmlkID0gcmFuZG9tSWQoKVxuICAgIC8vIEFkZCBpbiBkYXBwIHN0b3JhZ2Uga2V5IHRvIGFsbCBwb3B1cHMgYXMgYSBoYXNoIHBhcmFtZXRlclxuICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgIGZlYXR1cmVzOiBnZXRQb3B1cEZlYXR1cmVzKEZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XKSxcbiAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgIGNvbW11bmljYXRpb25FbmdpbmU6IG51bGwsXG4gICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlcjogbnVsbCxcbiAgICAgIHRpbWVvdXQ6IDMwMDAwLFxuICAgICAgaW5zdGFuY2VJZDogXCJcIixcbiAgICAgIGhhbmRsZVdpbmRvd0Jsb2NrQWxlcnQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgd2luZG93VGltZXI6IG51bGwsXG4gICAgICB3aW5kb3c6IG51bGwsXG4gICAgICBpQ2xvc2VkV2luZG93OiBmYWxzZSxcbiAgICAgIHdpbmRvd0lkOiBcIlwiLFxuICAgICAgdXJsOiBzdGF0ZS51cmxcbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuX3NldHVwVGltZXIoKTtcbiAgfVxuICBhc3luYyBvcGVuKCkge1xuICAgIC8vIGlmIHdpbmRvdyBpcyBhbHJlYWR5IG9wZW5cbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGNvbW11bmljYXRpb25FbmdpbmUsXG4gICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlclxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCB7XG4gICAgICB3aW5kb3dJZCxcbiAgICAgIHVybFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIE5vIHdpbmRvdyBoYXMgYmVlbiBwcmUtb3BlbmVkXG4gICAgaWYgKCF3aW5kb3dJZCkge1xuICAgICAgLy8gdHJ5IHRvIG9wZW4gYSB3aW5kb3cgZmlyc3RcbiAgICAgIGxldCBsb2NhbFdpbmRvdyA9IHdpbmRvdy5vcGVuKHVybC5ocmVmLCB0YXJnZXQsIGZlYXR1cmVzKTtcbiAgICAgIGxldCBmaW5hbFdpbmRvd0lkID0gXCJcIjtcbiAgICAgIGlmICghbG9jYWxXaW5kb3cpIHtcbiAgICAgICAgLy8gaWYgaXQncyBibG9ja2VkLCBvcGVuIFN0cmVhbVdpbmRvd1xuICAgICAgICBjb25zdCBzdHJlYW1XaW5kb3cgPSBuZXcgU3RyZWFtV2luZG93KHtcbiAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgIGNvbW11bmljYXRpb25FbmdpbmUsXG4gICAgICAgICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlcixcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IHRoaXMuY29uZmlnLmluc3RhbmNlSWQsXG4gICAgICAgICAgICBoYW5kbGVXaW5kb3dCbG9ja0FsZXJ0OiB0aGlzLmNvbmZpZy5oYW5kbGVXaW5kb3dCbG9ja0FsZXJ0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgdXJsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtV2luZG93Lm9wZW4oKTtcbiAgICAgICAgZmluYWxXaW5kb3dJZCA9IHN0cmVhbVdpbmRvdy5zdGF0ZS53aW5kb3dJZDtcbiAgICAgICAgbG9jYWxXaW5kb3cgPSBzdHJlYW1XaW5kb3c7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgIHdpbmRvdzogbG9jYWxXaW5kb3csXG4gICAgICAgIHdpbmRvd0lkOiBmaW5hbFdpbmRvd0lkIHx8IHJhbmRvbUlkKClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBIHdpbmRvdyBoYXMgYmVlbiBwcmUtb3BlbmVkIHdpdGggYSBxdWVyeSBwYXJhbWV0ZXIgYHdpbmRvd0lkYFxuICAgIGNvbnN0IGxvY2FsV2luZG93ID0gbmV3IFN0cmVhbVdpbmRvdyh7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcbiAgICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIsXG4gICAgICAgIGluc3RhbmNlSWQ6IHRoaXMuY29uZmlnLmluc3RhbmNlSWQsXG4gICAgICAgIGhhbmRsZVdpbmRvd0Jsb2NrQWxlcnQ6IHRoaXMuY29uZmlnLmhhbmRsZVdpbmRvd0Jsb2NrQWxlcnRcbiAgICAgIH0sXG4gICAgICBzdGF0ZToge1xuICAgICAgICB1cmwsXG4gICAgICAgIHdpbmRvd0lkXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgd2luZG93OiBsb2NhbFdpbmRvdyxcbiAgICAgIHdpbmRvd0lkOiBsb2NhbFdpbmRvdy5zdGF0ZS53aW5kb3dJZFxuICAgIH0pO1xuICAgIGF3YWl0IGxvY2FsV2luZG93Lm9wZW4oKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBpQ2xvc2VkV2luZG93OiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgd2luZG93XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHdpbmRvdykgd2luZG93LmNsb3NlKCk7XG4gIH1cbiAgX3NldHVwVGltZXIoKSB7XG4gICAgY29uc3QgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aW5kb3csXG4gICAgICAgIHdpbmRvd1RpbWVyLFxuICAgICAgICBpQ2xvc2VkV2luZG93XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmNsb3NlZCkge1xuICAgICAgICBpZiAod2luZG93VGltZXIpIGNsZWFySW50ZXJ2YWwod2luZG93VGltZXIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWlDbG9zZWRXaW5kb3cpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBpQ2xvc2VkV2luZG93OiBmYWxzZSxcbiAgICAgICAgICAgIHdpbmRvdzogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cgPT09IG51bGwgJiYgd2luZG93VGltZXIpIGNsZWFySW50ZXJ2YWwod2luZG93VGltZXIpO1xuICAgIH0sIDUwMCk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgd2luZG93VGltZXI6IHRpbWVyXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gQWx3YXlzIGxpc3RlbmluZyBjaGFubmVscy4gSGVuY2UsIG5vIHdpbmRvdyBpZFxuY2xhc3MgUG9wdXBTdG9yZUNoYW5uZWwge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaW5zdGFuY2VJZCxcbiAgICBoYW5kbGVMb2dvdXQsXG4gICAgaGFuZGxlQWNjb3VudEltcG9ydCxcbiAgICBoYW5kbGVOZXR3b3JrQ2hhbmdlLFxuICAgIGhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZSxcbiAgICBoYW5kbGVUaGVtZUNoYW5nZVxuICB9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlTG9nb3V0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlQWNjb3VudEltcG9ydFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU5ldHdvcmtDaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVUaGVtZUNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluc3RhbmNlSWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkO1xuICAgIHRoaXMuaGFuZGxlTG9nb3V0ID0gaGFuZGxlTG9nb3V0O1xuICAgIHRoaXMuaGFuZGxlQWNjb3VudEltcG9ydCA9IGhhbmRsZUFjY291bnRJbXBvcnQ7XG4gICAgdGhpcy5oYW5kbGVOZXR3b3JrQ2hhbmdlID0gaGFuZGxlTmV0d29ya0NoYW5nZTtcbiAgICB0aGlzLmhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZSA9IGhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZTtcbiAgICB0aGlzLmhhbmRsZVRoZW1lQ2hhbmdlID0gaGFuZGxlVGhlbWVDaGFuZ2U7XG4gIH1cbiAgc2V0dXBTdG9yZUNoYW5uZWxzKCkge1xuICAgIHRoaXMubG9nb3V0Q2hhbm5lbCgpO1xuICAgIHRoaXMuaW1wb3J0QWNjb3VudENoYW5uZWwoKTtcbiAgICB0aGlzLm5ldHdvcmtDaGFuZ2VDaGFubmVsKCk7XG4gICAgdGhpcy5zZWxlY3RlZEFkZHJlc3NDaGFuZ2VDaGFubmVsKCk7XG4gICAgdGhpcy50aGVtZUNoYW5nZWRDaGFubmVsKCk7XG4gIH1cbiAgbG9nb3V0Q2hhbm5lbCgpIHtcbiAgICBjb25zdCBsb2dvdXRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9MT0dPVVRfQ0hBTk5FTH1fJHt0aGlzLmluc3RhbmNlSWR9YCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIGxvZ291dENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xuICAgICAgdmFyIF9ldiRkYXRhO1xuICAgICAgbG9nLmluZm8oXCJyZWNlaXZlZCBsb2dvdXQgbWVzc2FnZVwiLCBldik7XG4gICAgICBpZiAoIWV2LmVycm9yICYmICgoX2V2JGRhdGEgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGEudHlwZSkgPT09IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTLkxPR09VVCkge1xuICAgICAgICBsb2cuaW5mbyhcIkxvZ2dpbmcgT3V0XCIpO1xuICAgICAgICB0aGlzLmhhbmRsZUxvZ291dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGltcG9ydEFjY291bnRDaGFubmVsKCkge1xuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9BQ0NPVU5UX0lNUE9SVF9DSEFOTkVMfV8ke3RoaXMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xuICAgICAgdmFyIF9ldiRkYXRhMjtcbiAgICAgIGlmICghZXYuZXJyb3IgJiYgKChfZXYkZGF0YTIgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhMi50eXBlKSA9PT0gQlJPQURDQVNUX0NIQU5ORUxTX01TR1MuQUNDT1VOVF9JTVBPUlRFRCkge1xuICAgICAgICB2YXIgX2V2JGRhdGEzO1xuICAgICAgICB0aGlzLmhhbmRsZUFjY291bnRJbXBvcnQoKF9ldiRkYXRhMyA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGEzLnByaXZLZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5ldHdvcmtDaGFuZ2VDaGFubmVsKCkge1xuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9ORVRXT1JLX0NIQU5HRV9DSEFOTkVMfV8ke3RoaXMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xuICAgICAgdmFyIF9ldiRkYXRhNDtcbiAgICAgIGlmICghZXYuZXJyb3IgJiYgKChfZXYkZGF0YTQgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhNC50eXBlKSA9PT0gQlJPQURDQVNUX0NIQU5ORUxTX01TR1MuTkVUV09SS19DSEFOR0UpIHtcbiAgICAgICAgdmFyIF9ldiRkYXRhNTtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrQ2hhbmdlKChfZXYkZGF0YTUgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhNS5uZXR3b3JrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0aGVtZUNoYW5nZWRDaGFubmVsKCkge1xuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLlRIRU1FX0NIQU5HRX1fJHt0aGlzLmluc3RhbmNlSWR9YCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ID0+IHtcbiAgICAgIHZhciBfZXYkZGF0YTY7XG4gICAgICBsb2cuaW5mbyh7XG4gICAgICAgIGV2XG4gICAgICB9KTtcbiAgICAgIGlmICghZXYuZXJyb3IgJiYgKChfZXYkZGF0YTYgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhNi50eXBlKSA9PT0gQlJPQURDQVNUX0NIQU5ORUxTX01TR1MuU0VUX1RIRU1FKSB7XG4gICAgICAgIHZhciBfZXYkZGF0YTc7XG4gICAgICAgIHRoaXMuaGFuZGxlVGhlbWVDaGFuZ2UoKF9ldiRkYXRhNyA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhNyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE3LnRoZW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZWxlY3RlZEFkZHJlc3NDaGFuZ2VDaGFubmVsKCkge1xuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9TRUxFQ1RFRF9BRERSRVNTX0NIQU5ORUx9XyR7dGhpcy5pbnN0YW5jZUlkfWAsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldiA9PiB7XG4gICAgICB2YXIgX2V2JGRhdGE4O1xuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhOCA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE4LnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5TRUxFQ1RFRF9BRERSRVNTX0NIQU5HRSkge1xuICAgICAgICB2YXIgX2V2JGRhdGE5O1xuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZSgoX2V2JGRhdGE5ID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGE5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTkuc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVwV2l0aEJjSGFuZGxlciBpcyBhIFBvcHVwSGFuZGxlciB3aGljaCB1c2VzIGJyb2FkY2FzdCBjaGFubmVsIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIHBvcHVwIHdpbmRvdy5cbiAqL1xuY2xhc3MgUG9wdXBXaXRoQmNIYW5kbGVyIGV4dGVuZHMgUG9wdXBIYW5kbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyxcbiAgICBzdGF0ZSxcbiAgICBjaGFubmVsUHJlZml4XG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxQcmVmaXhcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNoYW5uZWxQcmVmaXggPSBjaGFubmVsUHJlZml4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIHRoZSBkYXRhIGZyb20gcG9wdXAgd2luZG93IGFuZCBjbG9zZXMgdGhlIHdpbmRvd1xuICAgKiBAcGFyYW0gc3VjY2Vzc0V4dHJhRm4gLSBFeHRyYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGRhdGEgaXMgcmVjZWl2ZWRcbiAgICogQHJldHVybnMgVGhlIGRhdGEgdG8gYmUgcmVjZWl2ZWRcbiAgICovXG4gIGhhbmRsZShzdWNjZXNzRXh0cmFGbikge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYCR7dGhpcy5jaGFubmVsUHJlZml4fV8ke3RoaXMuY29uZmlnLmluc3RhbmNlSWR9XyR7dGhpcy5zdGF0ZS53aW5kb3dJZH1gO1xuICAgIGNvbnN0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoY2hhbm5lbE5hbWUsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2xvc2VMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBVc2VyRXJyb3IoXCJ1c2VyIGNsb3NlZCBwb3B1cFwiKSk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKFwiY2xvc2VcIiwgY2xvc2VMaXN0ZW5lcik7XG4gICAgICBiYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XG4gICAgICAgIGxvZy5pbmZvKGV2LCBgcmVjZWl2aW5nIGRhdGEgb24gY2hhbm5lbDogJHtiYy5uYW1lfWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICAgIH0gPSBldjtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN1Y2Nlc3NFeHRyYUZuKSBhd2FpdCBzdWNjZXNzRXh0cmFGbi5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9wZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9nLmluZm8oYG9wZW5lZCB3aW5kb3cgJHtiYy5uYW1lfWApO1xuICAgICAgICAvLyBPcGVuZWQgd2luZG93LiB5YXkuICBsZXQgdGhlIGJjIGV2ZW50cyBkbyB0aGVpciBqb2JcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIsIFwic29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgb3BlbmluZyB3aW5kb3dcIik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgaWYgd2UgaGF2ZSB0byBzZW5kIGxhcmdlIHBheWxvYWRzIHdoaWNoIGRvbid0IGZpdCBpbiBxdWVyeS9oYXNoIHBhcmFtcy5cbiAgICogV2FpdHMgZm9yIGFjayB0aGF0IHBvcHVwIHdpbmRvdyBpcyByZWFkeSB0byByZWNlaXZlIGRhdGEuXG4gICAqIFJlY2VpdmVzIHRoZSBkYXRhIGZyb20gcG9wdXAgd2luZG93IGFuZCBjbG9zZXMgdGhlIHdpbmRvd1xuICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBkYXRhIHRvIGJlIHNlbnQgdG8gdGhlIHBvcHVwIHdpbmRvdyBvbmNlIHdlIGhhdmUgYWNrIHRoYXQgd2luZG93IGlzIHJlYWR5IHRvIHJlY2VpdmUgZGF0YVxuICAgKiBAcGFyYW0gc3VjY2Vzc0V4dHJhRm4gLSBFeHRyYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGRhdGEgaXMgcmVjZWl2ZWRcbiAgICogQHJldHVybnMgVGhlIGRhdGEgdG8gYmUgcmVjZWl2ZWRcbiAgICovXG4gIGhhbmRsZVdpdGhIYW5kc2hha2UocGF5bG9hZCwgc3VjY2Vzc0V4dHJhRm4pIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IGAke3RoaXMuY2hhbm5lbFByZWZpeH1fJHt0aGlzLmNvbmZpZy5pbnN0YW5jZUlkfV8ke3RoaXMuc3RhdGUud2luZG93SWR9YDtcbiAgICBjb25zdCBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGNoYW5uZWxOYW1lLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNsb3NlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgIHJlamVjdChuZXcgVXNlckVycm9yKFwidXNlciBjbG9zZWQgcG9wdXBcIikpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY2xvc2VMaXN0ZW5lcik7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xuICAgICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvZy5pbmZvKGV2LCBgcmVjZWl2aW5nIGRhdGEgb24gY2hhbm5lbDogJHtiYy5uYW1lfWApO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICAgIH0gPSBldjtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRG8gaGFuZHNoYWtlXG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdHlwZSA9IFwiXCJcbiAgICAgICAgICB9ID0gZGF0YTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gUE9QVVBfTE9BREVEKSB7XG4gICAgICAgICAgICAvLyBIYWNrIHdpdGggZ2VuZXJpYyB0byB1c2UgdGhlIHNhbWUgdHlwZSBmb3IgYm90aCBzZW5kIGFuZCByZWNlaXZlXG4gICAgICAgICAgICBhd2FpdCBiYy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGRhdGE6IHBheWxvYWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gUE9QVVBfUkVTVUxUKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc0V4dHJhRm4pIGF3YWl0IHN1Y2Nlc3NFeHRyYUZuLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgLy8gTXVzdCBvbmx5IGNsb3NlIHRoZSBiYyBhZnRlciByZXN1bHQgaXMgZG9uZVxuICAgICAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9wZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9nLmluZm8oYG9wZW5lZCB3aW5kb3cgJHtiYy5uYW1lfWApO1xuICAgICAgICAvLyBPcGVuZWQgd2luZG93LiB5YXkuICBsZXQgdGhlIGJjIGV2ZW50cyBkbyB0aGVpciBqb2JcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIsIFwic29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgb3BlbmluZyB3aW5kb3dcIik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgUmVkaXJlY3RIYW5kbGVyIHtcbiAgLy8gcHJpdmF0ZSBoYXNoUGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuICBjb25zdHJ1Y3RvcihpbnN0YW5jZUlkKSB7XG4gICAgLy8gcHJpdmF0ZSBlcnJvcjogc3RyaW5nO1xuICAgIC8vIHRoaXMgaXMgc2Vzc2lvbmlkIHBvc3QgbG9naW5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnN0YW5jZUlkXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmluYWxRdWVyeVBhcmFtc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5zdGFuY2VQYXJhbWV0ZXJzXCIsIHZvaWQgMCk7XG4gICAgY29uc3Qge1xuICAgICAgaGFzaFxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICBxdWVyeVBhcmFtZXRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5maW5hbFF1ZXJ5UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBpbnN0YW5jZVBhcmFtZXRlcnNcbiAgICB9ID0gaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzKGhhc2gsIHRoaXMuZmluYWxRdWVyeVBhcmFtcyk7XG4gICAgLy8gdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuaW5zdGFuY2VQYXJhbWV0ZXJzID0gaW5zdGFuY2VQYXJhbWV0ZXJzO1xuICAgIC8vIHRoaXMuaGFzaFBhcmFtZXRlcnMgPSBoYXNoUGFyYW1ldGVycztcbiAgICB0aGlzLmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkO1xuICB9XG4gIGFzeW5jIGhhbmRsZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaW5hbFF1ZXJ5UGFyYW1zLFxuICAgICAgICBpbnN0YW5jZVBhcmFtZXRlcnNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgbGV0IGJjO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdXNlZCBmb3IgbG9naW4gY2FzZS4gdGhlcmUncyBubyB3aW5kb3dJZCBoZXJlXG4gICAgICAgIC8vIGlmICghZmluYWxRdWVyeVBhcmFtcy53aW5kb3dJZCkge1xuICAgICAgICAvLyAgIGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLlJFRElSRUNUX0NIQU5ORUx9XyR7aW5zdGFuY2VQYXJhbWV0ZXJzLmluc3RhbmNlSWR9YCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICAvLyAgIGJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIChldikgPT4ge1xuICAgICAgICAvLyAgICAgaWYgKGV2LmVycm9yKSB7XG4gICAgICAgIC8vICAgICAgIHJlamVjdChldi5lcnJvcik7XG4gICAgICAgIC8vICAgICAgIHdpbmRvdy5jbG9zZSgpO1xuICAgICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAvLyAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICAvLyAgICAgICBsb2cuaW5mbyhcInBvc3RlZFwiLCB7IGZpbmFsUXVlcnlQYXJhbXMsIGhhc2hQYXJhbWV0ZXJzLCBpbnN0YW5jZVBhcmFtZXRlcnMgfSk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgfSk7XG4gICAgICAgIC8vICAgYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAvLyAgICAgZGF0YToge1xuICAgICAgICAvLyAgICAgICBpbnN0YW5jZVBhcmFtczogaW5zdGFuY2VQYXJhbWV0ZXJzLFxuICAgICAgICAvLyAgICAgICBoYXNoUGFyYW1zOiBoYXNoUGFyYW1ldGVycyxcbiAgICAgICAgLy8gICAgICAgcXVlcnlQYXJhbXM6IGZpbmFsUXVlcnlQYXJhbXMsXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAgZXJyb3IsXG4gICAgICAgIC8vICAgfSk7XG5cbiAgICAgICAgLy8gICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gICAgIHJlc29sdmUoKTtcbiAgICAgICAgLy8gICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgLy8gICB9LCA1MDAwKTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgJHtCUk9BRENBU1RfQ0hBTk5FTFMuUkVESVJFQ1RfQ0hBTk5FTH1fJHt0aGlzLmluc3RhbmNlSWQgfHwgaW5zdGFuY2VQYXJhbWV0ZXJzLmluc3RhbmNlSWR9XyR7ZmluYWxRdWVyeVBhcmFtcy53aW5kb3dJZCB8fCBpbnN0YW5jZVBhcmFtZXRlcnMud2luZG93SWR9YDtcbiAgICAgICAgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChjaGFubmVsTmFtZSwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICBiYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgIH0gPSBldi5kYXRhO1xuICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZSA9PT0gU0VUVVBfQ09NUExFVEUpIHtcbiAgICAgICAgICAgIGF3YWl0IGJjLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBmaW5hbFF1ZXJ5UGFyYW1zLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFBPUFVQX0xPQURFRFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2LmVycm9yICYmIGV2LmVycm9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoZXYuZXJyb3IpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLmluZm8oZXJyLCBcInNvbWV0aGluZyB3ZW50IHdyb25nXCIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgaWYgKGJjKSBiYy5jbG9zZSgpO1xuICAgICAgICB3aW5kb3cuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG52YXIgSFRUUF9NRVRIT0QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEhUVFBfTUVUSE9EKSB7XG4gIEhUVFBfTUVUSE9EW0hUVFBfTUVUSE9EW1wiR0VUXCJdID0gMF0gPSBcIkdFVFwiO1xuICBIVFRQX01FVEhPRFtIVFRQX01FVEhPRFtcIlBPU1RcIl0gPSAxXSA9IFwiUE9TVFwiO1xuICBIVFRQX01FVEhPRFtIVFRQX01FVEhPRFtcIlBVVFwiXSA9IDJdID0gXCJQVVRcIjtcbiAgSFRUUF9NRVRIT0RbSFRUUF9NRVRIT0RbXCJQQVRDSFwiXSA9IDNdID0gXCJQQVRDSFwiO1xuICBIVFRQX01FVEhPRFtIVFRQX01FVEhPRFtcIkRFTEVURVwiXSA9IDRdID0gXCJERUxFVEVcIjtcbiAgcmV0dXJuIEhUVFBfTUVUSE9EO1xufShIVFRQX01FVEhPRCB8fCB7fSk7XG5jb25zdCBjb25zdHJ1Y3RBdXRoSGVhZGVycyA9ICh7XG4gIGp3dFRva2VuLFxuICBwdWJsaWNBZGRyZXNzXG59KSA9PiB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyczoge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2p3dFRva2VufWAsXG4gICAgICBcInB1YmxpYy1hZGRyZXNzXCI6IHB1YmxpY0FkZHJlc3NcbiAgICB9XG4gIH07XG59O1xuY29uc3Qgd2l0aFVuYXV0aG9yaXplZEhhbmRsZXIgPSBhc3luYyAoZm4sIGVtaXR0ZXIpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZuKCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGlzVW5hdXRob3JpemVkRXJyb3IoZSkpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdChDb250cm9sbGVyRXZlbnRzLlVzZXJVbmF1dGhvcml6ZWQpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59O1xuY29uc3Qgand0VG9rZW5FeHBpcmVkID0gand0ID0+IHtcbiAgY29uc3QgZGVjb2RlZCA9IGp3dERlY29kZShqd3QpO1xuICBjb25zdCBqd3RFeHBpcnkgPSBkZWNvZGVkLmV4cCAqIDEwMDA7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHJldHVybiBjdXJyZW50VGltZSA+PSBqd3RFeHBpcnk7XG59O1xuY29uc3QgV1NBcGlDbGllbnQgPSAoYmFzZUFwaVVybCwgZW1pdHRlcikgPT4ge1xuICBjb25zdCBhdXRoUmVxdWVzdCA9IChtZXRob2QsIHVybCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSA9PiB7XG4gICAgaWYgKGp3dFRva2VuRXhwaXJlZChhdXRoQ3JlZGVudGlhbHMuand0VG9rZW4pKSB7XG4gICAgICBlbWl0dGVyLmVtaXQoQ29udHJvbGxlckV2ZW50cy5Vc2VyVW5hdXRob3JpemVkKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiA0MDEsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiVW5hdXRob3JpemVkXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH0sIGNvbnN0cnVjdEF1dGhIZWFkZXJzKGF1dGhDcmVkZW50aWFscykpO1xuICAgIGlmIChtZXRob2QgPT09IEhUVFBfTUVUSE9ELkdFVCkge1xuICAgICAgcmV0dXJuIHdpdGhVbmF1dGhvcml6ZWRIYW5kbGVyKCgpID0+IGdldCh1cmwsIGhlYWRlcnMsIGN1c3RvbU9wdGlvbnMpLCBlbWl0dGVyKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gSFRUUF9NRVRIT0QuUE9TVCkge1xuICAgICAgcmV0dXJuIHdpdGhVbmF1dGhvcml6ZWRIYW5kbGVyKCgpID0+IHBvc3QodXJsLCBkYXRhLCBoZWFkZXJzLCBjdXN0b21PcHRpb25zKSwgZW1pdHRlcik7XG4gICAgfVxuICAgIGlmIChtZXRob2QgPT09IEhUVFBfTUVUSE9ELlBVVCkge1xuICAgICAgcmV0dXJuIHdpdGhVbmF1dGhvcml6ZWRIYW5kbGVyKCgpID0+IHB1dCh1cmwsIGRhdGEsIGhlYWRlcnMsIGN1c3RvbU9wdGlvbnMpLCBlbWl0dGVyKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gSFRUUF9NRVRIT0QuUEFUQ0gpIHtcbiAgICAgIHJldHVybiB3aXRoVW5hdXRob3JpemVkSGFuZGxlcigoKSA9PiBwYXRjaCh1cmwsIGRhdGEsIGhlYWRlcnMsIGN1c3RvbU9wdGlvbnMpLCBlbWl0dGVyKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gSFRUUF9NRVRIT0QuREVMRVRFKSB7XG4gICAgICByZXR1cm4gd2l0aFVuYXV0aG9yaXplZEhhbmRsZXIoKCkgPT4gcmVtb3ZlKHVybCwgZGF0YSwgaGVhZGVycywgY3VzdG9tT3B0aW9ucyksIGVtaXR0ZXIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhdXRoR2V0OiAodXJsLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpID0+IGF1dGhSZXF1ZXN0KEhUVFBfTUVUSE9ELkdFVCwgYCR7YmFzZUFwaVVybH0vJHt1cmx9YCwge30sIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucyksXG4gICAgYXV0aFBvc3Q6ICh1cmwsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucykgPT4gYXV0aFJlcXVlc3QoSFRUUF9NRVRIT0QuUE9TVCwgYCR7YmFzZUFwaVVybH0vJHt1cmx9YCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSxcbiAgICBhdXRoUHV0OiAodXJsLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpID0+IGF1dGhSZXF1ZXN0KEhUVFBfTUVUSE9ELlBVVCwgYCR7YmFzZUFwaVVybH0vJHt1cmx9YCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSxcbiAgICBhdXRoUGF0Y2g6ICh1cmwsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucykgPT4gYXV0aFJlcXVlc3QoSFRUUF9NRVRIT0QuUEFUQ0gsIGAke2Jhc2VBcGlVcmx9LyR7dXJsfWAsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucyksXG4gICAgYXV0aFJlbW92ZTogKHVybCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSA9PiBhdXRoUmVxdWVzdChIVFRQX01FVEhPRC5ERUxFVEUsIGAke2Jhc2VBcGlVcmx9LyR7dXJsfWAsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucylcbiAgfTtcbn07XG5cbmNvbnN0IEFDVElWSVRZX0FDVElPTiA9IHtcbiAgQUNUSVZJVFlfQUNUSU9OX0FMTDogXCJ3YWxsZXRBY3Rpdml0eS5hbGxUcmFuc2FjdGlvbnNcIixcbiAgQUNUSVZJVFlfQUNUSU9OX1NFTkQ6IFwid2FsbGV0QWN0aXZpdHkuc2VuZFwiLFxuICBBQ1RJVklUWV9BQ1RJT05fUkVDRUlWRTogXCJ3YWxsZXRBY3Rpdml0eS5yZWNlaXZlXCIsXG4gIEFDVElWSVRZX0FDVElPTl9UT1BVUDogXCJ3YWxsZXRBY3Rpdml0eS50b3B1cFwiXG59O1xuY29uc3QgQUNDT1VOVF9DQVRFR09SWSA9IHtcbiAgTk9STUFMOiBcIm5vcm1hbFwiLFxuICBUSFJFU0hPTEQ6IFwidGhyZXNob2xkXCIsXG4gIElNUE9SVEVEOiBcImltcG9ydGVkXCIsXG4gIC8vIHdlIGhhdmUgcHJpdmF0ZSBrZXkgaGVyZVxuICBBUFBfU0NPUEVEOiBcImFwcF9zY29wZWRcIixcbiAgQUNDT1VOVF9BQlNUUkFDVElPTjogXCJhY2NvdW50X2Fic3RyYWN0aW9uXCIsXG4gIEVYVEVSTkFMOiBcImV4dGVybmFsXCIsXG4gIC8vIGxpa2UgbWV0YW1hc2ssIHdhbGxldCBjb25uZWN0XG4gIE1QQzogXCJtcGNcIixcbiAgU0ZBOiBcInNmYVwiXG59O1xuXG4vKipcbiAqIFByZWZlcmVuY2VzIGNvbnRyb2xsZXIgc3RhdGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSBhZGRyZXNzIC0gYWRkcmVzcyBvZiB0aGUgdXNlclxuICogQHBhcmFtIGp3dFRva2VuIC0gaWYgand0IHRva2VuIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiBmZXRjaGluZyBmcm9tIGJhY2tlbmRcbiAqIEBwYXJhbSBjYWxsZWRGcm9tRW1iZWQgLSBpZiBjYWxsZWQgZnJvbSBlbWJlZFxuICogQHBhcmFtIHVzZXJJbmZvIC0gb3B0aW9uYWwgdXNlciBpbmZvXG4gKiBAcGFyYW0gcmVoeWRyYXRlIC0gUmVoeWRyYXRlIHRoZSBwcmVmZXJlbmNlcyBmcm9tIHRoZSBsb2NhbCBzdG9yYWdlXG4gKi9cblxuLy8gQnkgZGVmYXVsdCwgcG9sbCBldmVyeSAzIG1pbnV0ZXNcbmNvbnN0IERFRkFVTFRfSU5URVJWQUwgPSAxODAgKiAxMDAwO1xuY29uc3QgREVGQVVMVF9QUkVGRVJFTkNFUyA9IHtcbiAgc2VsZWN0ZWRDdXJyZW5jeTogXCJVU0RcIixcbiAgdGhlbWU6IFwiZGFya1wiLFxuICBsb2NhbGU6IFwiZW5cIixcbiAgYWNjb3VudFR5cGU6IEFDQ09VTlRfQ0FURUdPUlkuTk9STUFMLFxuICBjb250YWN0czogW10sXG4gIGp3dFRva2VuOiBcIlwiLFxuICBmZXRjaGVkUGFzdFR4OiBbXSxcbiAgcGFzdFRyYW5zYWN0aW9uczogW10sXG4gIHBheW1lbnRUeDogW10sXG4gIGRlZmF1bHRQdWJsaWNBZGRyZXNzOiBcIlwiLFxuICBjdXN0b21Ub2tlbnM6IFtdLFxuICBjdXN0b21OZnRzOiBbXSxcbiAgY3Jhc2hSZXBvcnQ6IHRydWUsXG4gIHVzZXJJbmZvOiB7XG4gICAgYWdncmVnYXRlVmVyaWZpZXI6IFwiXCIsXG4gICAgZW1haWw6IFwiXCIsXG4gICAgbmFtZTogXCJcIixcbiAgICBwcm9maWxlSW1hZ2U6IFwiXCIsXG4gICAgdHlwZU9mTG9naW46IExPR0lOX1BST1ZJREVSLkdPT0dMRSxcbiAgICB2ZXJpZmllcjogXCJcIixcbiAgICB2ZXJpZmllcklkOiBcIlwiXG4gIH1cbn07XG5cbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHN0b3JlcyBzaGFyZWQgc2V0dGluZ3MgYW5kIGV4cG9zZXMgY29udmVuaWVuY2UgbWV0aG9kc1xuICovXG5jbGFzcyBCYXNlUHJlZmVyZW5jZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFByZWZlcmVuY2VzQ29udHJvbGxlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcsXG4gICAgc3RhdGUsXG4gICAgZGVmYXVsdFByZWZlcmVuY2VzLFxuICAgIHNpZ25BdXRoTWVzc2FnZSxcbiAgICB2YWxpZGF0ZVNpZ25NZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBcIlByZWZlcmVuY2VzQ29udHJvbGxlclwiKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZnJhbWVPcmlnaW5cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3c0FwaUNsaWVudFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpZ25BdXRoTWVzc2FnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbGlkYXRlU2lnbk1lc3NhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0UHJlZmVyZW5jZXNcIiwgdm9pZCAwKTtcbiAgICBpZiAoIWNvbmZpZy5hcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByZWZlcmVuY2VzQ29udHJvbGxlciAtIG5vIGFwaSBzcGVjaWZpZWQgaW4gY29uZmlnLlwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICBpZGVudGl0aWVzOiB7fSxcbiAgICAgIHNlbGVjdGVkQWRkcmVzczogXCJcIixcbiAgICAgIGxhc3RFcnJvck1lc3NhZ2U6IFwiXCIsXG4gICAgICBsYXN0U3VjY2Vzc01lc3NhZ2U6IFwiXCJcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgIGFwaTogY29uZmlnLmFwaSxcbiAgICAgIHBvbGxJbnRlcnZhbDogREVGQVVMVF9JTlRFUlZBTFxuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy5kZWZhdWx0UHJlZmVyZW5jZXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfUFJFRkVSRU5DRVMpLCBkZWZhdWx0UHJlZmVyZW5jZXMpO1xuICAgIHRoaXMuc2lnbkF1dGhNZXNzYWdlID0gc2lnbkF1dGhNZXNzYWdlO1xuICAgIHRoaXMudmFsaWRhdGVTaWduTWVzc2FnZSA9IHZhbGlkYXRlU2lnbk1lc3NhZ2U7XG4gICAgdGhpcy53c0FwaUNsaWVudCA9IFdTQXBpQ2xpZW50KHRoaXMuY29uZmlnLmFwaSwgdGhpcyk7XG4gIH1cbiAgc2V0SWZyYW1lT3JpZ2luKG9yaWdpbikge1xuICAgIHRoaXMuaWZyYW1lT3JpZ2luID0gb3JpZ2luO1xuICB9XG4gIGdldEFkZHJlc3NTdGF0ZShhZGRyZXNzKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gYWRkcmVzcyB8fCB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pZGVudGl0aWVzW3NlbGVjdGVkQWRkcmVzc107XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBzZWxlY3RlZCBhZGRyZXNzXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RlZEFkZHJlc3MgLSBjYXNwZXIgYWNjb3VudCBoYXNoXG4gICAqL1xuICBzZXRTZWxlY3RlZEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgc2VsZWN0ZWRBZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VXNlcihhZGRyZXNzKSB7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aEdldChcInVzZXI/ZmV0Y2hUeD1mYWxzZVwiLCB0aGlzLmF1dGhDcmVkZW50aWFscyhhZGRyZXNzKSwge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHVzZXIuZGF0YTtcbiAgfVxuICBhc3luYyBjcmVhdGVVc2VyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlbGVjdGVkQ3VycmVuY3ksXG4gICAgICB0aGVtZSxcbiAgICAgIHZlcmlmaWVyLFxuICAgICAgdmVyaWZpZXJJZCxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBpZFRva2VuLFxuICAgICAgdHlwZSxcbiAgICAgIHdlYjNBdXRoTmV0d29ya1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdXNlclBheWxvYWQgPSB7XG4gICAgICBkZWZhdWx0X2N1cnJlbmN5OiBzZWxlY3RlZEN1cnJlbmN5LFxuICAgICAgdGhlbWUsXG4gICAgICB2ZXJpZmllcixcbiAgICAgIHZlcmlmaWVyX2lkOiB2ZXJpZmllcklkLFxuICAgICAgbG9jYWxlLFxuICAgICAgaWRUb2tlbixcbiAgICAgIGFjY291bnRfdHlwZTogdHlwZSxcbiAgICAgIHdlYjNhdXRoX25ldHdvcms6IHdlYjNBdXRoTmV0d29ya1xuICAgIH07XG4gICAgYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUG9zdChcInVzZXJcIiwgdXNlclBheWxvYWQsIHRoaXMuYXV0aENyZWRlbnRpYWxzKGFkZHJlc3MpLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRoZW1lLFxuICAgICAgZGVmYXVsdFB1YmxpY0FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICBzZWxlY3RlZEN1cnJlbmN5LFxuICAgICAgbG9jYWxlLFxuICAgICAgYWNjb3VudFR5cGU6IHR5cGVcbiAgICB9LCBhZGRyZXNzKTtcbiAgfVxuICBhc3luYyBzdG9yZVVzZXJMb2dpbihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2ZXJpZmllcklkLFxuICAgICAgdmVyaWZpZXIsXG4gICAgICBvcHRpb25zLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIGlkVG9rZW4sXG4gICAgICB3ZWIzQXV0aENsaWVudElkLFxuICAgICAgd2ViM0F1dGhOZXR3b3JrLFxuICAgICAgc2Vzc2lvblB1YktleSxcbiAgICAgIGxvZ2luTW9kZVxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFvcHRpb25zLnJlaHlkcmF0ZSkge1xuICAgICAgY29uc3QgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgY29uc3Qgc3BlY2lhbEJyb3dzZXIgPSBnZXRDdXN0b21EZXZpY2VJbmZvKCk7XG4gICAgICBjb25zdCByZWNvcmRMb2dpblBheWxvYWQgPSB7XG4gICAgICAgIG9zOiBicm93c2VyLmdldE9TTmFtZSgpLFxuICAgICAgICBvc192ZXJzaW9uOiBicm93c2VyLmdldE9TVmVyc2lvbigpIHx8IFwidW5pZGVudGlmaWVkXCIsXG4gICAgICAgIGJyb3dzZXI6IChzcGVjaWFsQnJvd3NlciA9PT0gbnVsbCB8fCBzcGVjaWFsQnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BlY2lhbEJyb3dzZXIuYnJvd3NlcikgfHwgYnJvd3Nlci5nZXRCcm93c2VyTmFtZSgpIHx8IFwidW5pZGVudGlmaWVkXCIsXG4gICAgICAgIGJyb3dzZXJfdmVyc2lvbjogYnJvd3Nlci5nZXRCcm93c2VyVmVyc2lvbigpIHx8IFwidW5pZGVudGlmaWVkXCIsXG4gICAgICAgIHBsYXRmb3JtOiBicm93c2VyLmdldFBsYXRmb3JtKCkudHlwZSB8fCBcImRlc2t0b3BcIixcbiAgICAgICAgaG9zdG5hbWU6IHRoaXMuaWZyYW1lT3JpZ2luLFxuICAgICAgICB2ZXJpZmllcixcbiAgICAgICAgdmVyaWZpZXJfaWQ6IHZlcmlmaWVySWQsXG4gICAgICAgIGlkVG9rZW4sXG4gICAgICAgIHdlYjNhdXRoX2NsaWVudF9pZDogd2ViM0F1dGhDbGllbnRJZCxcbiAgICAgICAgd2ViM2F1dGhfbmV0d29yazogd2ViM0F1dGhOZXR3b3JrLFxuICAgICAgICBzZXNzaW9uX3B1Yl9rZXk6IHNlc3Npb25QdWJLZXksXG4gICAgICAgIGxvZ2luX21vZGU6IGxvZ2luTW9kZVxuICAgICAgfTtcbiAgICAgIGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBvc3QoXCJ1c2VyL3JlY29yZExvZ2luXCIsIHJlY29yZExvZ2luUGF5bG9hZCwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoYWRkcmVzcyksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2V0Q3Jhc2hSZXBvcnQoaXNFbmFibGVkKSB7XG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTtcbiAgICBpZiAoaXNFbmFibGVkID09PSAoKF90aGlzJGdldEFkZHJlc3NTdGF0ZSA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKCkpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlLmNyYXNoUmVwb3J0KSkgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBhdGNoKFwidXNlclwiLCB7XG4gICAgICAgIGVuYWJsZV9jcmFzaF9yZXBvcnRlcjogaXNFbmFibGVkXG4gICAgICB9LCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgY3Jhc2hSZXBvcnQ6IGlzRW5hYmxlZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2V0VXNlclRoZW1lKHRoZW1lKSB7XG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTI7XG4gICAgaWYgKHRoZW1lID09PSAoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTIgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGUyLnRoZW1lKSkgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBhdGNoKFwidXNlclwiLCB7XG4gICAgICAgIHRoZW1lXG4gICAgICB9LCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgdGhlbWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNldFVzZXJMb2NhbGUobG9jYWxlKSB7XG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTM7XG4gICAgaWYgKGxvY2FsZSA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGUzID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMy5sb2NhbGUpKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBhdGNoKFwidXNlclwiLCB7XG4gICAgICAgIGxvY2FsZVxuICAgICAgfSwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGxvY2FsZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIHNldCBsb2NhbGVcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZXRTZWxlY3RlZEN1cnJlbmN5KHBheWxvYWQpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNDtcbiAgICBpZiAocGF5bG9hZC5zZWxlY3RlZEN1cnJlbmN5ID09PSAoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTQgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGU0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGU0LnNlbGVjdGVkQ3VycmVuY3kpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUGF0Y2goXCJ1c2VyXCIsIHtcbiAgICAgICAgZGVmYXVsdF9jdXJyZW5jeTogcGF5bG9hZC5zZWxlY3RlZEN1cnJlbmN5XG4gICAgICB9LCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgc2VsZWN0ZWRDdXJyZW5jeTogcGF5bG9hZC5zZWxlY3RlZEN1cnJlbmN5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBhZGRDb250YWN0KGNvbnRhY3QpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTU7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBvc3QoXCJjb250YWN0XCIsIGNvbnRhY3QsIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBjb250YWN0czogWy4uLigoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTUgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGU1LmNvbnRhY3RzKSB8fCBbXSksIHJlc3BvbnNlLmRhdGFdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gYWRkIGNvbnRhY3RcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBkZWxldGVDb250YWN0KGNvbnRhY3RJZCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNjtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUmVtb3ZlKGBjb250YWN0LyR7Y29udGFjdElkfWAsIHt9LCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBmaW5hbENvbnRhY3RzID0gKF90aGlzJGdldEFkZHJlc3NTdGF0ZTYgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGU2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGU2LmNvbnRhY3RzLmZpbHRlcihjb250YWN0ID0+IGNvbnRhY3QuaWQgIT09IHJlc3BvbnNlLmRhdGEuaWQpO1xuICAgICAgaWYgKGZpbmFsQ29udGFjdHMpIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBjb250YWN0czogWy4uLmZpbmFsQ29udGFjdHNdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZGVsZXRlIGNvbnRhY3RcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyByZXZva2VEaXNjb3JkKGlkVG9rZW4pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBvc3QoXCJyZXZva2UvZGlzY29yZFwiLCB7XG4gICAgICAgIHRva2VuOiBpZFRva2VuXG4gICAgICB9LCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBsb2cuaW5mbyhyZXNwKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcGF0Y2hQYXN0VHgoYm9keSwgYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBhdGNoKFwidHJhbnNhY3Rpb25cIiwgYm9keSwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoYWRkcmVzcyksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxvZy5pbmZvKFwic3VjY2Vzc2Z1bGx5IHBhdGNoZWRcIiwgcmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gcGF0Y2ggdHhcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwb3N0UGFzdFR4KHR4LCBhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUG9zdChcInRyYW5zYWN0aW9uXCIsIHR4LCB0aGlzLmF1dGhDcmVkZW50aWFscyhhZGRyZXNzKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbG9nLmluZm8oXCJzdWNjZXNzZnVsbHkgcG9zdGVkIHR4XCIsIHJlc3BvbnNlKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yLCBcInVuYWJsZSB0byBpbnNlcnQgdHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFdhbGxldE9yZGVycyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoR2V0KFwidHJhbnNhY3Rpb25cIiwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoYWRkcmVzcyksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5zdWNjZXNzID8gcmVzcG9uc2UuZGF0YSA/IHJlc3BvbnNlLmRhdGEgOiBbXSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZ2V0IHdhbGxldCBvcmRlcnMgdHhcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRUb3BVcE9yZGVycyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoR2V0KFwidHJhbnNhY3Rpb25cIiwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoYWRkcmVzcyksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhIHx8IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZmV0Y2ggcGFzdCBUb3AgdXAgb3JkZXJzXCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0QmlsbEJvYXJkRGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhHZXQoXCJiaWxsYm9hcmRcIiwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLnN1Y2Nlc3MgPyByZXNwb25zZS5kYXRhIDogW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBnZXQgYmlsbGJvYXJkIGRhdGFcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRNZXNzYWdlRm9yU2lnbmluZyhwdWJsaWNBZGRyZXNzLCB3ZWIzQXV0aElkVG9rZW4pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5jb25maWcuYXBpfS9hdXRoL21lc3NhZ2VgLCB7XG4gICAgICBwdWJsaWNfYWRkcmVzczogcHVibGljQWRkcmVzcyxcbiAgICAgIGlkX3Rva2VuOiB3ZWIzQXV0aElkVG9rZW5cbiAgICB9LCB7fSwge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLm1lc3NhZ2U7XG4gIH1cbiAgYXN5bmMgZ2V0VHdpdHRlcklkKHBheWxvYWQpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhHZXQoYHR3aXR0ZXI/c2NyZWVuX25hbWU9JHtwYXlsb2FkLm5pY2t9YCwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGAke3BheWxvYWQudHlwZU9mTG9naW4udG9Mb3dlckNhc2UoKX18JHtyZXMuZGF0YS50b1N0cmluZygpfWA7XG4gIH1cbiAgYXN5bmMgc2VuZEVtYWlsKHBheWxvYWQpIHtcbiAgICByZXR1cm4gdGhpcy53c0FwaUNsaWVudC5hdXRoUG9zdChcInRyYW5zYWN0aW9uL3NlbmRlbWFpbFwiLCBwYXlsb2FkLmVtYWlsT2JqZWN0LCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgfVxuICBhc3luYyByZWZyZXNoSnd0KCkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gYXdhaXQgdGhpcy5nZXRNZXNzYWdlRm9yU2lnbmluZyhhZGRyZXNzKTtcbiAgICBhd2FpdCB0aGlzLnZhbGlkYXRlU2lnbk1lc3NhZ2UobWVzc2FnZVRvU2lnbik7XG4gICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IHRoaXMuc2lnbkF1dGhNZXNzYWdlKGFkZHJlc3MsIG1lc3NhZ2VUb1NpZ24pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L2F1dGgvdmVyaWZ5YCwge1xuICAgICAgY2hhbGxlbmdlOiBtZXNzYWdlVG9TaWduLFxuICAgICAgcHVibGljX2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICBzaWduZWRfbWVzc2FnZTogc2lnbmVkTWVzc2FnZVxuICAgIH0sIHt9LCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgIGp3dFRva2VuOiByZXNwb25zZS50b2tlblxuICAgIH0sIGFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIGdldERhcHBMaXN0KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aEdldChcImRhcHBzXCIsIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5zdWNjZXNzID8gcmVzcG9uc2UuZGF0YSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZ2V0IGRhcHBzIGxpc3RcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJhdGVneVxuICAgKiBGb3IgYWNjb3VudCB0eXBlOiB0aHJlc2hvbGQsIG5vcm1hbCAod2ViM2F1dGggbG9naW4pXG4gICAqIGlkVG9rZW4gZnJvbSB3ZWIzYXV0aCBsb2dpbiBtdXN0IGJlIHByZXNlbnQuIFdlIHVzZSBpdCBkaXJlY3RseVxuICAgKlxuICAgKiBGb3IgYWNjb3VudCB0eXBlOiBhcHBfc2NvcGVkLCBJTVBPUlRFRFxuICAgKiBpZFRva2VuIGZyb20gd2ViM2F1dGggbG9naW4gbXVzdCBiZSBwcmVzZW50LiBXZSByZXF1ZXN0IGEgbWVzc2FnZSBmb3Igc2lnbmluZyB1c2luZyB0aGUgaWRUb2tlblxuICAgKiBhbmQgc2lnbiBpdCB1c2luZyB0aGUgcHJpdmF0ZSBrZXkgb2YgdGhlIGFjY291bnQuIFdlIHRoZW4gc2VuZCB0aGUgc2lnbmVkIG1lc3NhZ2UgdG8gdGhlIGJhY2tlbmRcbiAgICogdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgYW5kIHJldHVybiBhIG5ldyBqd3RUb2tlbiB0aGF0IGluY2x1ZGVzIHRoZSBhcHBfc2NvcGVkIGFkZHJlc3NcbiAgICpcbiAgICogRm9yIGFjY291bnQgdHlwZTogQWNjb3VudCBhYnN0cmFjdGlvblxuICAgKiBpZFRva2VuIGZyb20gd2ViM2F1dGggbG9naW4gbXVzdCBiZSBwcmVzZW50LiBXZSB1c2UgaXQgdG8gZXhjaGFuZ2UgZm9yIGEgbmV3IGp3dFRva2VuLlxuICAgKiBCZWNhdXNlIGJhY2tlbmQgY2FuIGRlcml2ZSBBQSBhZGRyZXNzIGZyb20gcHVibGljIGFkZHJlc3MgYW5kIGlzc3VlIHRoaXMgdG9rZW4gZWFzaWx5LlxuICAgKlxuICAgKiBGb3IgYWNjb3VudCB0eXBlOiBleHRlcm5hbFxuICAgKiBpZFRva2VuIGZyb20gd2ViM2F1dGggYGF1dGhlbnRpY2F0ZVVzZXJgIChzaXd3KSBsb2dpbiBtdXN0IGJlIHByZXNlbnQuIFdlIHVzZSBpdCBkaXJlY3RseVxuICAgKi9cbiAgYXN5bmMgaW5pdChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzLFxuICAgICAgdXNlckluZm8sXG4gICAgICBpZFRva2VuLFxuICAgICAgbWV0YWRhdGEgPSB7fSxcbiAgICAgIHR5cGVcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmICh0aGlzLmdldEFkZHJlc3NTdGF0ZShhZGRyZXNzKSkgcmV0dXJuO1xuICAgIGxldCBqd3RUb2tlbjtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQUNDT1VOVF9DQVRFR09SWS5JTVBPUlRFRDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaWRUb2tlbikgdGhyb3cgbmV3IEVycm9yKFwiV2ViM0F1dGggaWRUb2tlbiBtdXN0IGJlIHByZXNlbnRcIik7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZVRvU2lnbiA9IGF3YWl0IHRoaXMuZ2V0TWVzc2FnZUZvclNpZ25pbmcoYWRkcmVzcywgaWRUb2tlbik7XG4gICAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZVNpZ25NZXNzYWdlKG1lc3NhZ2VUb1NpZ24pO1xuICAgICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCB0aGlzLnNpZ25BdXRoTWVzc2FnZShhZGRyZXNzLCBtZXNzYWdlVG9TaWduKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5jb25maWcuYXBpfS9hdXRoL3ZlcmlmeWAsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgY2hhbGxlbmdlOiBtZXNzYWdlVG9TaWduLFxuICAgICAgICAgICAgYWNjb3VudF90eXBlOiB0eXBlLFxuICAgICAgICAgICAgcHVibGljX2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBzaWduZWRfbWVzc2FnZTogc2lnbmVkTWVzc2FnZSxcbiAgICAgICAgICAgIHZlcmlmaWVyOiB1c2VySW5mby5hZ2dyZWdhdGVWZXJpZmllciB8fCB1c2VySW5mby52ZXJpZmllcixcbiAgICAgICAgICAgIHZlcmlmaWVyX2lkOiB1c2VySW5mby52ZXJpZmllcklkXG4gICAgICAgICAgfSwgbWV0YWRhdGEpLCB7fSwge1xuICAgICAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgand0VG9rZW4gPSByZXNwb25zZS50b2tlbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBBQ0NPVU5UX0NBVEVHT1JZLkVYVEVSTkFMOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFpZFRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJTSVdXIGlkVG9rZW4gbXVzdCBiZSBwcmVzZW50XCIpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L2F1dGgvdmVyaWZ5YCwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICBhY2NvdW50X3R5cGU6IHR5cGUsXG4gICAgICAgICAgICBwdWJsaWNfYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIGlkX3Rva2VuOiBpZFRva2VuLFxuICAgICAgICAgICAgdmVyaWZpZXI6IHVzZXJJbmZvLmFnZ3JlZ2F0ZVZlcmlmaWVyIHx8IHVzZXJJbmZvLnZlcmlmaWVyLFxuICAgICAgICAgICAgdmVyaWZpZXJfaWQ6IHVzZXJJbmZvLnZlcmlmaWVySWRcbiAgICAgICAgICB9LCBtZXRhZGF0YSksIHt9LCB7XG4gICAgICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBqd3RUb2tlbiA9IHJlc3BvbnNlLnRva2VuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFDQ09VTlRfQ0FURUdPUlkuQUNDT1VOVF9BQlNUUkFDVElPTjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaWRUb2tlbikgdGhyb3cgbmV3IEVycm9yKFwiV2ViM0F1dGggaWRUb2tlbiBtdXN0IGJlIHByZXNlbnRcIik7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vYXV0aC92ZXJpZnlgLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIHB1YmxpY19hZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgaWRfdG9rZW46IGlkVG9rZW4sXG4gICAgICAgICAgICB2ZXJpZmllcjogdXNlckluZm8uYWdncmVnYXRlVmVyaWZpZXIgfHwgdXNlckluZm8udmVyaWZpZXIsXG4gICAgICAgICAgICB2ZXJpZmllcl9pZDogdXNlckluZm8udmVyaWZpZXJJZCxcbiAgICAgICAgICAgIGFjY291bnRfdHlwZTogdHlwZVxuICAgICAgICAgIH0sIG1ldGFkYXRhKSwge30sIHtcbiAgICAgICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGp3dFRva2VuID0gcmVzcG9uc2UudG9rZW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQUNDT1VOVF9DQVRFR09SWS5NUEM6XG4gICAgICBjYXNlIEFDQ09VTlRfQ0FURUdPUlkuU0ZBOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFtZXRhZGF0YS5zaWduYXR1cmVzKSB0aHJvdyBuZXcgRXJyb3IoXCJNUEMgc2lnbmF0dXJlcyBtdXN0IGJlIHByZXNlbnRcIik7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vYXV0aC92ZXJpZnlgLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIHB1YmxpY19hZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgdmVyaWZpZXI6IHVzZXJJbmZvLmFnZ3JlZ2F0ZVZlcmlmaWVyIHx8IHVzZXJJbmZvLnZlcmlmaWVyLFxuICAgICAgICAgICAgdmVyaWZpZXJfaWQ6IHVzZXJJbmZvLnZlcmlmaWVySWQsXG4gICAgICAgICAgICBhY2NvdW50X3R5cGU6IHR5cGVcbiAgICAgICAgICB9LCBtZXRhZGF0YSksIHt9LCB7XG4gICAgICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBqd3RUb2tlbiA9IHJlc3BvbnNlLnRva2VuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFDQ09VTlRfQ0FURUdPUlkuTk9STUFMOlxuICAgICAgY2FzZSBBQ0NPVU5UX0NBVEVHT1JZLlRIUkVTSE9MRDpcbiAgICAgIGNhc2UgQUNDT1VOVF9DQVRFR09SWS5BUFBfU0NPUEVEOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKCFpZFRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJXZWIzQXV0aCBpZFRva2VuIG11c3QgYmUgcHJlc2VudFwiKTtcbiAgICAgICAgand0VG9rZW4gPSBpZFRva2VuO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBqd3RUb2tlbixcbiAgICAgIHVzZXJJbmZvLFxuICAgICAgYWNjb3VudFR5cGU6IHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdm9pZCAwID8gdHlwZSA6IHRoaXMuZGVmYXVsdFByZWZlcmVuY2VzLmFjY291bnRUeXBlXG4gICAgfSwgYWRkcmVzcyk7XG4gIH1cbiAgdXBkYXRlU3RhdGUocHJlZmVyZW5jZXMsIGFkZHJlc3MpIHtcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBhZGRyZXNzIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKHNlbGVjdGVkQWRkcmVzcykgfHwgY2xvbmVEZWVwKHRoaXMuZGVmYXVsdFByZWZlcmVuY2VzKTtcbiAgICBjb25zdCBtZXJnZWRTdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VycmVudFN0YXRlKSwgcHJlZmVyZW5jZXMpO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIGlkZW50aXRpZXM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5zdGF0ZS5pZGVudGl0aWVzKSwge30sIHtcbiAgICAgICAgW3NlbGVjdGVkQWRkcmVzc106IG1lcmdlZFN0YXRlXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWRTdGF0ZTtcbiAgfVxuICBhdXRoQ3JlZGVudGlhbHMoYWRkcmVzcykge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU3O1xuICAgIGNvbnN0IHNlbGVjdGVkQWRkcmVzcyA9IGFkZHJlc3MgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZEFkZHJlc3M7XG4gICAgY29uc3Qgand0VG9rZW4gPSAoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTcgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZShzZWxlY3RlZEFkZHJlc3MpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGU3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGU3Lmp3dFRva2VuKSB8fCBcIlwiO1xuICAgIHJldHVybiB7XG4gICAgICBqd3RUb2tlbixcbiAgICAgIHB1YmxpY0FkZHJlc3M6IHNlbGVjdGVkQWRkcmVzc1xuICAgIH07XG4gIH1cbiAgaGVhZGVycyhhZGRyZXNzKSB7XG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTg7XG4gICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gYWRkcmVzcyB8fCB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICByZXR1cm4gZ2V0SGVhZGVycygoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTggPSB0aGlzLmdldEFkZHJlc3NTdGF0ZShzZWxlY3RlZEFkZHJlc3MpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGU4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGU4Lmp3dFRva2VuKSB8fCBcIlwiLCBzZWxlY3RlZEFkZHJlc3MpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgdHJhbnNhY3Rpb24uIEVhY2ggc3RhdHVzIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2FjdGlvbiBpbnRlcm5hbGx5XG4gKiBpbiB0aGUgd2FsbGV0LiBTb21lIG9mIHRoZXNlIGNvcnJlc3BvbmQgd2l0aCB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBuZXR3b3JrLCBidXRcbiAqIHNvbWUgYXJlIHdhbGxldC1zcGVjaWZpYy5cbiAqL1xuXG5sZXQgVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiYXBwcm92ZWRcIl0gPSBcImFwcHJvdmVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiY2FuY2VsbGVkXCJdID0gXCJjYW5jZWxsZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJjYW5jZWxsaW5nXCJdID0gXCJjYW5jZWxsaW5nXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiY29uZmlybWVkXCJdID0gXCJjb25maXJtZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJmYWlsZWRcIl0gPSBcImZhaWxlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImZpbmFsaXplZFwiXSA9IFwiZmluYWxpemVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wicHJvY2Vzc2VkXCJdID0gXCJwcm9jZXNzZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJzaWduZWRcIl0gPSBcInNpZ25lZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcInN1Ym1pdHRlZFwiXSA9IFwic3VibWl0dGVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1widW5hcHByb3ZlZFwiXSA9IFwidW5hcHByb3ZlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImRyb3BwZWRcIl0gPSBcImRyb3BwZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJleHBpcmVkXCJdID0gXCJleHBpcmVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wicGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXM7XG59KHt9KTtcbmNvbnN0IFRSQU5TQUNUSU9OX1RZUEVTID0ge1xuICBDQU5DRUw6IFwiY2FuY2VsXCIsXG4gIFJFVFJZOiBcInJldHJ5XCIsXG4gIENPTlRSQUNUX0lOVEVSQUNUSU9OOiBcImNvbnRyYWN0SW50ZXJhY3Rpb25cIixcbiAgREVQTE9ZX0NPTlRSQUNUOiBcImNvbnRyYWN0RGVwbG95bWVudFwiLFxuICBXQVNNX0JBU0VEX0RFUExPWTogXCJ3YXNtQmFzZWREZXBsb3lcIixcbiAgU1RBTkRBUkRfVFJBTlNBQ1RJT046IFwidHJhbnNhY3Rpb25cIixcbiAgU1RBTkRBUkRfUEFZTUVOVF9UUkFOU0FDVElPTjogXCJwYXltZW50X3RyYW5zYWN0aW9uXCIsXG4gIC8vIHNwZWNpZmljIHRvIGNoYWlucyBsaWtlIHNvbGFuYSBhbmQgY2FzcGVyXG4gIFNFTlRfRVRIRVI6IFwic2VudEV0aGVyXCIsXG4gIFRPS0VOX01FVEhPRF9UUkFOU0ZFUjogXCJ0cmFuc2ZlclwiLFxuICBUT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTTogXCJ0cmFuc2ZlckZyb21cIixcbiAgVE9LRU5fTUVUSE9EX0FQUFJPVkU6IFwiYXBwcm92ZVwiLFxuICBDT0xMRUNUSUJMRV9NRVRIT0RfU0FGRV9UUkFOU0ZFUl9GUk9NOiBcInNhZmVUcmFuc2ZlckZyb21cIixcbiAgU0VUX0FQUFJPVkFMX0ZPUl9BTEw6IFwic2V0QXBwcm92YWxGb3JBbGxcIlxufTtcbmNvbnN0IFRYX0VWRU5UUyA9IHtcbiAgVFhfV0FSTklORzogXCJ0eDp3YXJuaW5nXCIsXG4gIFRYX0VSUk9SOiBcInR4OmVycm9yXCIsXG4gIFRYX0ZBSUxFRDogXCJ0eDpmYWlsZWRcIixcbiAgVFhfQ09ORklSTUVEOiBcInR4OmNvbmZpcm1lZFwiLFxuICBUWF9EUk9QUEVEOiBcInR4OmRyb3BwZWRcIixcbiAgVFhfRVhQSVJFRDogXCJ0eDpleHBpcmVkXCIsXG4gIFRYX1NUQVRVU19VUERBVEU6IFwidHg6c3RhdHVzX3VwZGF0ZVwiLFxuICBUWF9VTkFQUFJPVkVEOiBcInR4OnVuYXBwcm92ZWRcIixcbiAgVFhfUkVUUlk6IFwidHg6cmV0cnlcIixcbiAgVFhfQkxPQ0tfVVBEQVRFOiBcInR4OmJsb2NrX3VwZGF0ZVwiXG59O1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNvbnRyb2xsZXIgY29uZmlndXJhdGlvblxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY29udHJvbGxlciBzdGF0ZVxuICovXG5cbi8qKlxuICogUmVzdWx0XG4gKlxuICogcmVzdWx0IC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBuZXcgdHJhbnNhY3Rpb24gaGFzaFxuICogdHJhbnNhY3Rpb25NZXRhIC0gTWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIG5ldyB0cmFuc2FjdGlvblxuICovXG5cbmNsYXNzIEJhc2VUcmFuc2FjdGlvblN0YXRlTWFuYWdlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyxcbiAgICBzdGF0ZSxcbiAgICBnZXRDdXJyZW50Q2hhaW5JZFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRDdXJyZW50Q2hhaW5JZFwiLCB2b2lkIDApO1xuICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgIHR4SGlzdG9yeUxpbWl0OiA0MFxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICB0cmFuc2FjdGlvbnM6IHt9LFxuICAgICAgdW5hcHByb3ZlZFR4czoge30sXG4gICAgICBjdXJyZW50TmV0d29ya1R4c0xpc3Q6IFtdXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLmdldEN1cnJlbnRDaGFpbklkID0gZ2V0Q3VycmVudENoYWluSWQ7XG4gIH1cbiAgZ2V0VW5hcHByb3ZlZFR4TGlzdCgpIHtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgIHJldHVybiBwaWNrQnkodGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMsIHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZCAmJiB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrKHRyYW5zYWN0aW9uLCBjaGFpbklkKSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb24odHhJZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zYWN0aW9uc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbnNbdHhJZF07XG4gIH1cbiAgdXBkYXRlVHJhbnNhY3Rpb24odHhNZXRhKSB7XG4gICAgLy8gY29tbWl0IHR4TWV0YSB0byBzdGF0ZVxuICAgIGNvbnN0IHR4SWQgPSB0eE1ldGEuaWQ7XG4gICAgdHhNZXRhLnVwZGF0ZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zKSwge30sIHtcbiAgICAgICAgW3R4SWRdOiB0eE1ldGFcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2V0VHhTdGF0dXNSZWplY3RlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQpO1xuICAgIHRoaXMuX2RlbGV0ZVRyYW5zYWN0aW9uKHR4SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbXBsZW1lbnRpbmcgY29udHJvbGxlciBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbmFsaXR5IGFuZCBhZGQgY3VzdG9tIGxvZ2ljICsgY2FsbCBzdXBlci4oKVxuICAgKi9cbiAgc2V0VHhTdGF0dXNVbmFwcHJvdmVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy51bmFwcHJvdmVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c0FwcHJvdmVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5hcHByb3ZlZCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNTaWduZWQodHhJZCwgaXNGaW5hbFN0ZXApIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5zaWduZWQsIGlzRmluYWxTdGVwKTtcbiAgfVxuICBzZXRUeFN0YXR1c1N1Ym1pdHRlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c0Ryb3BwZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmRyb3BwZWQpO1xuICB9XG4gIHNldFR4U3RhdHVzRXhwaXJlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuZXhwaXJlZCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNDb25maXJtZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNGYWlsZWQodHhJZCwgZXJyb3JfKSB7XG4gICAgY29uc3QgZXJyb3IgPSAhZXJyb3JfID8gbmV3IEVycm9yKFwiSW50ZXJuYWwgdG9ydXMgZmFpbHVyZVwiKSA6IGVycm9yXztcbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIHR4TWV0YS5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24odHhNZXRhKTtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB0byBkZXRlcm1pbmUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGluIGEgZmluYWwgc3RhdGVcbiAgICogQHBhcmFtIHN0YXR1cyAtIFRyYW5zYWN0aW9uIHN0YXR1c1xuICAgKiBAcmV0dXJucyBib29sZWFuIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiBhIGZpbmFsIHN0YXRlXG4gICAqL1xuICBpc0ZpbmFsU3RhdGUoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5jb25maXJtZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5jYW5jZWxsZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5leHBpcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgb3V0IHRoZSB1bmFwcHJvdmVkIHRyYW5zYWN0aW9ucyBmcm9tIHN0YXRlXG4gICAqL1xuICBjbGVhclVuYXBwcm92ZWRUeHMoKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zOiBvbWl0QnkodGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMsIHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZClcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiB3aWxsIGFwcGVuZCBuZXcgdHJhbnNhY3Rpb25zIHRvIG9sZCB0eG5zLlxuICAgKi9cbiAgX2FkZFRyYW5zYWN0aW9uc1RvU3RhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMucmVkdWNlKChyZXN1bHQsIG5ld1R4KSA9PiB7XG4gICAgICAgIHJlc3VsdFtuZXdUeC5pZF0gPSBuZXdUeDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHdpbGwgc2V0IG5ldyB0eG5zLCBvdmVycmlkZSBleGlzdGluZyBpZiBhbnkgaW4gc3RhdGUuXG4gICAqL1xuICBfc2V0VHJhbnNhY3Rpb25zVG9TdGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5yZWR1Y2UoKHJlc3VsdCwgbmV3VHgpID0+IHtcbiAgICAgICAgcmVzdWx0W25ld1R4LmlkXSA9IG5ld1R4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pXG4gICAgfSk7XG4gIH1cbiAgX2RlbGV0ZVRyYW5zYWN0aW9uKHRhcmdldFRyYW5zYWN0aW9uSWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBkZWxldGUgdHJhbnNhY3Rpb25zW3RhcmdldFRyYW5zYWN0aW9uSWRdO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIF9kZWxldGVUcmFuc2FjdGlvbnModGFyZ2V0VHJhbnNhY3Rpb25JZHMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICB0YXJnZXRUcmFuc2FjdGlvbklkcy5mb3JFYWNoKHRyYW5zYWN0aW9uSWQgPT4ge1xuICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkXTtcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBfc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgc3RhdHVzLCBpc0ZpbmFsU3RlcCkge1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgaWYgKCF0eE1ldGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHhNZXRhLnN0YXR1cyA9IHN0YXR1cztcbiAgICAvLyBvbmx5IHVwZGF0aW5nIHN0YXR1cyBzbyBubyB2YWxpZGF0aW9uIHJlcXVpcmVkIG9uIHR4bi5cbiAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKHR4TWV0YSk7XG4gICAgdGhpcy5lbWl0KFRYX0VWRU5UUy5UWF9TVEFUVVNfVVBEQVRFLCB7XG4gICAgICB0eElkLFxuICAgICAgc3RhdHVzXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuaXNGaW5hbFN0YXRlKHN0YXR1cykgfHwgaXNGaW5hbFN0ZXApIHtcbiAgICAgIHRoaXMuZW1pdChgJHt0eE1ldGEuaWR9OmZpbmlzaGVkYCwgdHhNZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KGAke3R4TWV0YS5pZH06JHtzdGF0dXN9YCwgdHhJZCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEFDQ09VTlRfQ0FURUdPUlksIEFDVElWSVRZX0FDVElPTiwgQUNUSVZJVFlfQUNUSU9OX0FDQ0VQVF9ORlRfT0ZGRVIsIEFDVElWSVRZX0FDVElPTl9BTEwsIEFDVElWSVRZX0FDVElPTl9CVVJOLCBBQ1RJVklUWV9BQ1RJT05fQ0FOQ0VMX05GVF9PRkZFUiwgQUNUSVZJVFlfQUNUSU9OX0NSRUFURV9ORlRfT0ZGRVIsIEFDVElWSVRZX0FDVElPTl9DUkVBVEVfVFJVU1RMSU5FLCBBQ1RJVklUWV9BQ1RJT05fUkVDRUlWRSwgQUNUSVZJVFlfQUNUSU9OX1JFTU9WRV9UUlVTVExJTkUsIEFDVElWSVRZX0FDVElPTl9TRU5ELCBBQ1RJVklUWV9BQ1RJT05fVE9QVVAsIEFDVElWSVRZX1BFUklPRF9BTEwsIEFDVElWSVRZX1BFUklPRF9NT05USF9PTkUsIEFDVElWSVRZX1BFUklPRF9NT05USF9TSVgsIEFDVElWSVRZX1BFUklPRF9XRUVLX09ORSwgQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExFRCwgQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExJTkcsIEFDVElWSVRZX1NUQVRVU19QRU5ESU5HLCBBQ1RJVklUWV9TVEFUVVNfU1VDQ0VTU0ZVTCwgQUNUSVZJVFlfU1RBVFVTX1VOU1VDQ0VTU0ZVTCwgQlJPQURDQVNUX0NIQU5ORUxTLCBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUywgQlVUVE9OX1BPU0lUSU9OLCBCYXNlQmxvY2tUcmFja2VyLCBCYXNlQ29udHJvbGxlciwgQmFzZUN1cnJlbmN5Q29udHJvbGxlciwgQmFzZUVtYmVkQ29udHJvbGxlciwgQmFzZUtleXJpbmdDb250cm9sbGVyLCBCYXNlUHJlZmVyZW5jZXNDb250cm9sbGVyLCBCYXNlVHJhbnNhY3Rpb25TdGF0ZU1hbmFnZXIsIEJyb2FkY2FzdENoYW5uZWxIYW5kbGVyLCBDSEFJTl9OQU1FU1BBQ0VTLCBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUywgQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLCBDT05GSVJNQVRJT05fU1RSQVRFR1ksIENvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLCBDb250cm9sbGVyRXZlbnRzLCBERUZBVUxUX1BSRUZFUkVOQ0VTLCBGRUFUVVJFU19DT05GSVJNX1dJTkRPVywgRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1csIEZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVywgRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVywgTE9HSU5fUFJPVklERVIsIFBBWU1FTlRfUFJPVklERVIsIFBPUFVQX0xPQURFRCwgUE9QVVBfUkVTVUxULCBQUk9WSURFUl9KUlBDX01FVEhPRFMsIFBST1ZJREVSX05PVElGSUNBVElPTlMsIFBvcHVwSGFuZGxlciwgUG9wdXBTdG9yZUNoYW5uZWwsIFBvcHVwV2l0aEJjSGFuZGxlciwgUmVkaXJlY3RIYW5kbGVyLCBTRVRVUF9DT01QTEVURSwgU3RyZWFtV2luZG93LCBUUkFOU0FDVElPTl9UWVBFUywgVFhfRVZFTlRTLCBUcmFuc2FjdGlvblN0YXR1cywgVXNlckVycm9yLCBXU0FwaUNsaWVudCwgYWRkcmVzc1NsaWNlciwgYXV0aFNlcnZlciwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMsIGNsb25lRGVlcCwgY29uY2F0U2lnLCBjcmVhdGVDaGFuZ2VQcm92aWRlck1pZGRsZXdhcmVNaWRkbGV3YXJlLCBjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZSwgY3JlYXRlRXZlbnRFbWl0dGVyUHJveHksIGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSwgY3JlYXRlRmV0Y2hNaWRkbGV3YXJlLCBjcmVhdGVHZW5lcmljSlJQQ01pZGRsZXdhcmUsIGNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlLCBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlLCBjcmVhdGVPcmlnaW5NaWRkbGV3YXJlLCBjcmVhdGVSYW5kb21JZCwgY3JlYXRlU3dhcHBhYmxlUHJveHksIGNyZWF0ZVRvcHVwTWlkZGxld2FyZSwgZm9ybWF0RGF0ZSwgZm9ybWF0U21hbGxOdW1iZXJzLCBmb3JtYXRUaW1lLCBnZXRDdXN0b21EZXZpY2VJbmZvLCBnZXRIZWFkZXJzLCBnZXRQb3B1cEZlYXR1cmVzLCBnZXRUeFN0YXR1c1RleHQsIGhhbmRsZVJlZGlyZWN0UGFyYW1ldGVycywgaGFzaE1lc3NhZ2UsIGludFRvSGV4LCBpc1VuYXV0aG9yaXplZEVycm9yLCBvbWl0QnksIHBhZFdpdGhaZXJvZXMsIHBpY2tCeSwgcmFuZG9tSWQsIHNpZ25DaGFsbGVuZ2UsIHNpZ25NZXNzYWdlLCBzaWduaWZpY2FudERpZ2l0cywgc2xlZXAsIHRpbWVvdXQkMSBhcyB0aW1lb3V0LCB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrLCB2ZXJpZnlTaWduZWRDaGFsbGVuZ2UgfTtcbiJdLCJuYW1lcyI6WyJfb2JqZWN0U3ByZWFkIiwiX2RlZmluZVByb3BlcnR5IiwiU2FmZUV2ZW50RW1pdHRlciIsImNyZWF0ZUFzeW5jTWlkZGxld2FyZSIsIm1lcmdlTWlkZGxld2FyZSIsImNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSIsIkpSUENFbmdpbmUiLCJwcm92aWRlckZyb21FbmdpbmUiLCJycGNFcnJvcnMiLCJwb3N0IiwiZ2V0IiwicHV0IiwicGF0Y2giLCJyZW1vdmUiLCJsb2ciLCJmcm9tU2lnbmVkIiwiYnl0ZXNUb0JpZ0ludCIsInRvVW5zaWduZWQiLCJzdHJpcEhleFByZWZpeCIsImJpZ0ludFRvSGV4IiwiYWRkSGV4UHJlZml4IiwiaGFzaFBlcnNvbmFsTWVzc2FnZSIsImVjc2lnbiIsImJpZ0ludFRvQnl0ZXMiLCJzYWZlYXRvYiIsIkJpZ051bWJlciIsIkJyb2FkY2FzdENoYW5uZWwiLCJib3dzZXIiLCJqd3REZWNvZGUiLCJCYXNlQ29udHJvbGxlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwic3RhdGUiLCJkZWZhdWx0Q29uZmlnIiwiZGVmYXVsdFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwiaW5pdGlhbENvbmZpZyIsImludGVybmFsQ29uZmlnIiwiaW50ZXJuYWxTdGF0ZSIsImNvbmZpZ3VyZSIsIm92ZXJ3cml0ZSIsImZ1bGxVcGRhdGUiLCJPYmplY3QiLCJhc3NpZ24iLCJrZXkiLCJ1cGRhdGUiLCJlbWl0IiwiaW5pdGlhbGl6ZSIsInNlYyIsImNhbGN1bGF0ZVN1bSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwiYmxvY2tUcmFja2VyRXZlbnRzIiwiQmFzZUJsb2NrVHJhY2tlciIsIl9jdXJyZW50QmxvY2siLCJpZGVtcG90ZW5jeUtleSIsIl9pc1J1bm5pbmciLCJibG9ja1Jlc2V0RHVyYXRpb24iLCJfb25OZXdMaXN0ZW5lciIsImJpbmQiLCJfb25SZW1vdmVMaXN0ZW5lciIsIl9yZXNldEN1cnJlbnRCbG9jayIsIl9zZXR1cEludGVybmFsRXZlbnRzIiwiaXNSdW5uaW5nIiwiZ2V0Q3VycmVudEJsb2NrIiwiZ2V0TGF0ZXN0QmxvY2siLCJsYXRlc3RCbG9jayIsIlByb21pc2UiLCJyZXNvbHZlIiwib25jZSIsImJsb2NrIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZXZlbnROYW1lIiwiX3N0YXJ0IiwiX2VuZCIsIl9uZXdQb3RlbnRpYWxMYXRlc3QiLCJuZXdCbG9jayIsImN1cnJlbnRCbG9jayIsIl9zZXRDdXJyZW50QmxvY2siLCJyZW1vdmVMaXN0ZW5lciIsIm9uIiwiX21heWJlU3RhcnQiLCJfZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCIsIl9tYXliZUVuZCIsIl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCIsIl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0IiwibWFwIiwibGlzdGVuZXJDb3VudCIsInJlZHVjZSIsIm9sZEJsb2NrIiwiX2Jsb2NrUmVzZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsInVucmVmIiwiY2xlYXJUaW1lb3V0IiwiZmlsdGVyTm9vcCIsImludGVybmFsRXZlbnRzIiwiZXh0ZXJuYWxFdmVudEZpbHRlciIsIm5hbWUiLCJpbmNsdWRlcyIsImdldFJhd0xpc3RlbmVycyIsImV2ZW50RW1pdHRlciIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVycyIsImNyZWF0ZUV2ZW50RW1pdHRlclByb3h5IiwiaW5pdGlhbFRhcmdldCIsIm9wdHMiLCJmaW5hbE9wdHMiLCJldmVudEZpbHRlciIsIkVycm9yIiwidGFyZ2V0Iiwic2V0VGFyZ2V0IiwibmV3VGFyZ2V0Iiwib2xkVGFyZ2V0IiwiZXZlbnROYW1lcyIsImZpbHRlciIsImZvckVhY2giLCJoYW5kbGVyIiwicHJveHkiLCJQcm94eSIsIl8iLCJzZXQiLCJ2YWx1ZSIsImNyZWF0ZVN3YXBwYWJsZVByb3h5IiwiUE9MTElOR19JTlRFUlZBTCIsIkJhc2VDdXJyZW5jeUNvbnRyb2xsZXIiLCJjdXJyZW50Q3VycmVuY3kiLCJjb252ZXJzaW9uUmF0ZSIsImNvbnZlcnNpb25EYXRlIiwibmF0aXZlQ3VycmVuY3kiLCJwb2xsSW50ZXJ2YWwiLCJnZXROYXRpdmVDdXJyZW5jeSIsInNldE5hdGl2ZUN1cnJlbmN5IiwidGlja2VyIiwiZ2V0Q3VycmVudEN1cnJlbmN5Iiwic2V0Q3VycmVudEN1cnJlbmN5IiwiZ2V0Q29udmVyc2lvblJhdGUiLCJzZXRDb252ZXJzaW9uUmF0ZSIsImdldENvbnZlcnNpb25EYXRlIiwic2V0Q29udmVyc2lvbkRhdGUiLCJGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XIiwiaGVpZ2h0Iiwid2lkdGgiLCJGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1ciLCJGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVyIsIkZFQVRVUkVTX0NPTkZJUk1fV0lORE9XIiwiUE9QVVBfTE9BREVEIiwiUE9QVVBfUkVTVUxUIiwiU0VUVVBfQ09NUExFVEUiLCJBQ1RJVklUWV9BQ1RJT05fQUxMIiwiQUNUSVZJVFlfQUNUSU9OX1NFTkQiLCJBQ1RJVklUWV9BQ1RJT05fQlVSTiIsIkFDVElWSVRZX0FDVElPTl9SRUNFSVZFIiwiQUNUSVZJVFlfQUNUSU9OX1RPUFVQIiwiQUNUSVZJVFlfQUNUSU9OX0NSRUFURV9UUlVTVExJTkUiLCJBQ1RJVklUWV9BQ1RJT05fUkVNT1ZFX1RSVVNUTElORSIsIkFDVElWSVRZX0FDVElPTl9DUkVBVEVfTkZUX09GRkVSIiwiQUNUSVZJVFlfQUNUSU9OX0FDQ0VQVF9ORlRfT0ZGRVIiLCJBQ1RJVklUWV9BQ1RJT05fQ0FOQ0VMX05GVF9PRkZFUiIsIkFDVElWSVRZX1BFUklPRF9BTEwiLCJBQ1RJVklUWV9QRVJJT0RfV0VFS19PTkUiLCJBQ1RJVklUWV9QRVJJT0RfTU9OVEhfT05FIiwiQUNUSVZJVFlfUEVSSU9EX01PTlRIX1NJWCIsIkFDVElWSVRZX1NUQVRVU19TVUNDRVNTRlVMIiwiQUNUSVZJVFlfU1RBVFVTX1VOU1VDQ0VTU0ZVTCIsIkFDVElWSVRZX1NUQVRVU19QRU5ESU5HIiwiQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExFRCIsIkFDVElWSVRZX1NUQVRVU19DQU5DRUxMSU5HIiwiQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TIiwiSUZSQU1FX1NUQVRVUyIsIkNMT1NFX1dJTkRPVyIsIlVTRVJfTE9HR0VEX0lOIiwiVVNFUl9MT0dHRURfT1VUIiwiQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMiLCJMT0dPVVQiLCJXQUxMRVRfSU5TVEFOQ0VfSUQiLCJVU0VSX0lORk8iLCJTRVRfUFJPVklERVIiLCJUT1BVUCIsIkNMT1NFRF9XSU5ET1ciLCJXSU5ET1dfQkxPQ0tFRCIsIkdFVF9QUk9WSURFUl9TVEFURSIsIkxPR0lOX1dJVEhfUFJJVkFURV9LRVkiLCJTSE9XX1dBTExFVF9DT05ORUNUIiwiU0hPV19DSEVDS09VVCIsIlNIT1dfV0FMTEVUX1VJIiwiTE9HSU5fV0lUSF9TRVNTSU9OX0lEIiwiUFJPVklERVJfSlJQQ19NRVRIT0RTIiwiUFJPVklERVJfTk9USUZJQ0FUSU9OUyIsIkFDQ09VTlRTX0NIQU5HRUQiLCJDSEFJTl9DSEFOR0VEIiwiVU5MT0NLX1NUQVRFX0NIQU5HRUQiLCJCUk9BRENBU1RfQ0hBTk5FTFMiLCJSRURJUkVDVF9DSEFOTkVMIiwiUFJPVklERVJfQ0hBTkdFX0NIQU5ORUwiLCJUUkFOU0FDVElPTl9DSEFOTkVMIiwiTUVTU0FHRV9DSEFOTkVMIiwiV0FMTEVUX0xPR09VVF9DSEFOTkVMIiwiV0FMTEVUX1NFTEVDVEVEX0FERFJFU1NfQ0hBTk5FTCIsIldBTExFVF9ORVRXT1JLX0NIQU5HRV9DSEFOTkVMIiwiV0FMTEVUX0FDQ09VTlRfSU1QT1JUX0NIQU5ORUwiLCJUSEVNRV9DSEFOR0UiLCJUT1BfVVBfQ0hBTk5FTCIsIkJST0FEQ0FTVF9DSEFOTkVMU19NU0dTIiwiQUNDT1VOVF9JTVBPUlRFRCIsIlNFTEVDVEVEX0FERFJFU1NfQ0hBTkdFIiwiTkVUV09SS19DSEFOR0UiLCJTRVRfVEhFTUUiLCJDb250cm9sbGVyRXZlbnRzIiwiY3JlYXRlQ2hhbmdlUHJvdmlkZXJNaWRkbGV3YXJlTWlkZGxld2FyZSIsImNoYW5nZVByb3ZpZGVyIiwicmVxdWVzdCIsInJlc3BvbnNlIiwibmV4dCIsIm1ldGhvZCIsInJlc3VsdCIsImNyZWF0ZVRvcHVwTWlkZGxld2FyZSIsInRvcHVwIiwiY3JlYXRlR2VuZXJpY0pSUENNaWRkbGV3YXJlIiwidGFyZ2V0TWV0aG9kIiwidW5kZWZpbmVkIiwiY3JlYXRlQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUiLCJwcm92aWRlckhhbmRsZXJzIiwiZ2V0VXNlckluZm8iLCJnZXRXYWxsZXRJbnN0YW5jZUlkIiwibG9nb3V0Iiwic2V0SUZyYW1lU3RhdHVzIiwiaGFuZGxlV2luZG93UnBjIiwiZ2V0UHJvdmlkZXJTdGF0ZSIsImxvZ2luV2l0aFByaXZhdGVLZXkiLCJzaG93V2FsbGV0Q29ubmVjdCIsInNob3dDaGVja291dCIsInNob3dXYWxsZXRVaSIsInNob3dXaW5kb3dCbG9ja0FsZXJ0IiwibG9naW5XaXRoU2Vzc2lvbklkIiwiQmFzZUVtYmVkQ29udHJvbGxlciIsImlzSUZyYW1lRnVsbFNjcmVlbiIsIm9hdXRoTW9kYWxWaXNpYmlsaXR5IiwibG9naW5JblByb2dyZXNzIiwiZGFwcE1ldGFkYXRhIiwiaWNvbiIsIndlYjNBdXRoQ2xpZW50SWQiLCJ3ZWIzQXV0aE5ldHdvcmsiLCJ3aGl0ZUxhYmVsIiwiY29uZmlybWF0aW9uU3RyYXRlZ3kiLCJpbml0aWFsaXplUHJvdmlkZXIiLCJoYW5kbGVycyIsImVuZ2luZSIsImNvbW11bmljYXRpb25NaWRkbGV3YXJlIiwicHVzaCIsImNvbW11bmljYXRpb25Qcm92aWRlciIsInNldENvbW11bmljYXRpb25Qcm92aWRlciIsIl9jb21tdW5pY2F0aW9uUHJvdmlkZXJQcm94eSIsIkNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyIiwiYXJncyIsImVuZCIsInBhcmFtcyIsIndpbmRvd0lkIiwiQlVUVE9OX1BPU0lUSU9OIiwiQk9UVE9NX0xFRlQiLCJUT1BfTEVGVCIsIkJPVFRPTV9SSUdIVCIsIlRPUF9SSUdIVCIsIkNPTkZJUk1BVElPTl9TVFJBVEVHWSIsIlBPUFVQIiwiTU9EQUwiLCJBVVRPX0FQUFJPVkUiLCJERUZBVUxUIiwiTE9HSU5fUFJPVklERVIiLCJHT09HTEUiLCJGQUNFQk9PSyIsIlJFRERJVCIsIkRJU0NPUkQiLCJUV0lUQ0giLCJBUFBMRSIsIkxJTkUiLCJHSVRIVUIiLCJLQUtBTyIsIkxJTktFRElOIiwiVFdJVFRFUiIsIldFSUJPIiwiV0VDSEFUIiwiRU1BSUxfUEFTU1dPUkRMRVNTIiwiU01TX1BBU1NXT1JETEVTUyIsIlBBWU1FTlRfUFJPVklERVIiLCJNT09OUEFZIiwiV1lSRSIsIlJBTVBORVRXT1JLIiwiWEFOUE9PTCIsIk1FUkNVUllPIiwiVFJBTlNBSyIsIm9taXRCeSIsIm9iamVjdCIsInByZWRpY2F0ZSIsImVudHJpZXMiLCJwaWNrQnkiLCJjbG9uZURlZXAiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJlcnJvciIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImF1dGhTZXJ2ZXIiLCJzaWduQ2hhbGxlbmdlIiwicGF5bG9hZCIsImNoYWluTmFtZXNwYWNlIiwidCIsImhlYWRlciIsIm5ldHdvcmsiLCJkYXRhIiwicmVzIiwic3VjY2VzcyIsImNoYWxsZW5nZSIsInZlcmlmeVNpZ25lZENoYWxsZW5nZSIsInNpZ25lZE1lc3NhZ2UiLCJpc3N1ZXIiLCJzZXNzaW9uVGltZSIsImNsaWVudElkIiwiYXVkaWVuY2UiLCJhZGRpdGlvbmFsTWV0YWRhdGEiLCJfd2luZG93JGxvY2F0aW9uIiwic2lnRGF0YSIsInNpZ25hdHVyZSIsInMiLCJtZXNzYWdlIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsInRpbWVvdXQiLCJpZFRva2VuUmVzIiwiaGVhZGVycyIsImNsaWVudF9pZCIsIndhbGxldF9wcm92aWRlciIsIndlYjNhdXRoX25ldHdvcmsiLCJ0b2tlbiIsImdldFR4U3RhdHVzVGV4dCIsInR4U3RhdHVzIiwiaW50VG9IZXgiLCJpIiwiaGV4IiwidG9TdHJpbmciLCJyYW5kb21JZCIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsInBhZFdpdGhaZXJvZXMiLCJoZXhTdHJpbmciLCJ0YXJnZXRMZW5ndGgiLCJ0ZXN0IiwiU3RyaW5nIiwicHJvdG90eXBlIiwicGFkU3RhcnQiLCJjYWxsIiwiY29uY2F0U2lnIiwidiIsInIiLCJyU2lnIiwic1NpZyIsInZTaWciLCJyU3RyIiwiQnVmZmVyIiwiZnJvbSIsInNTdHIiLCJ2U3RyIiwiY29uY2F0IiwidGltZW91dCQxIiwiZHVyYXRpb24iLCJ0aW1lb3V0UmVmIiwiZ2V0SGVhZGVycyIsImp3dCIsInB1YmxpY0FkZHJlc3MiLCJBdXRob3JpemF0aW9uIiwiZm9ybWF0U21hbGxOdW1iZXJzIiwibnVtYmVyIiwiY3VycmVuY3kiLCJub1RpbGRlIiwiZmluYWxOdW1iZXIiLCJpc0JpZ051bWJlciIsInRvTnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwidGlsZGUiLCJ0b1VwcGVyQ2FzZSIsImFkZHJlc3NTbGljZXIiLCJhZGRyZXNzIiwic2xpY2VMZW5ndGgiLCJsZW5ndGgiLCJzaWduaWZpY2FudERpZ2l0cyIsInBlcmMiLCJsZW5ndGhfIiwiaW5wdXQiLCJpc1plcm8iLCJ0aW1lcyIsImRlcHRoIiwiZ3RlIiwiY2VpbCIsImxvZzEwIiwiZGl2Iiwic2hpZnQiLCJwb3ciLCJyb3VuZGVkTnVtYmVyIiwicm91bmQiLCJmb3JtYXREYXRlIiwiaW5wdXREYXRlIiwibW9udGhMaXN0IiwiZGF0ZSIsIkRhdGUiLCJkYXkiLCJnZXREYXRlIiwibW9udGgiLCJnZXRNb250aCIsInllYXIiLCJnZXRGdWxsWWVhciIsImZvcm1hdFRpbWUiLCJ0aW1lIiwidG9UaW1lU3RyaW5nIiwidHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayIsInRyYW5zYWN0aW9uIiwiY2hhaW5JZCIsImhhc2hNZXNzYWdlIiwiYnVmZmVyZWRNZXNzYWdlIiwiZWwiLCJzaWduTWVzc2FnZSIsInByaXZhdGVLZXkiLCJwcml2S2V5IiwibXNnU2lnIiwicmF3TXNnU2lnIiwiZ2V0UG9wdXBGZWF0dXJlcyIsInciLCJoIiwiZHVhbFNjcmVlbkxlZnQiLCJzY3JlZW5MZWZ0Iiwic2NyZWVuWCIsImR1YWxTY3JlZW5Ub3AiLCJzY3JlZW5Ub3AiLCJzY3JlZW5ZIiwiaW5uZXJXaWR0aCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJzY3JlZW4iLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsInN5c3RlbVpvb20iLCJsZWZ0IiwiYWJzIiwidG9wIiwiZmVhdHVyZXMiLCJicm9hZGNhc3RDaGFubmVsT3B0aW9ucyIsInR5cGUiLCJ3ZWJXb3JrZXJTdXBwb3J0IiwiZ2V0Q3VzdG9tRGV2aWNlSW5mbyIsIl9uYXZpZ2F0b3IiLCJuYXZpZ2F0b3IiLCJicmF2ZSIsImJyb3dzZXIiLCJVc2VyRXJyb3IiLCJoYW5kbGVSZWRpcmVjdFBhcmFtZXRlcnMiLCJoYXNoIiwicXVlcnlQYXJhbWV0ZXJzIiwiaGFzaFBhcmFtZXRlcnMiLCJoYXNoVXJsIiwiVVJMIiwib3JpZ2luIiwic2VhcmNoUGFyYW1zIiwiaW5zdGFuY2VQYXJhbWV0ZXJzIiwia2V5cyIsImRlY29kZVVSSUNvbXBvbmVudCIsImVycm9yX2Rlc2NyaXB0aW9uIiwic2xlZXAiLCJtcyIsImlzVW5hdXRob3JpemVkRXJyb3IiLCJSZXNwb25zZSIsInN0YXR1cyIsIkJhc2VLZXlyaW5nQ29udHJvbGxlciIsIl9zdGF0ZSR3YWxsZXRzIiwid2FsbGV0cyIsInNpZ25BdXRoTWVzc2FnZSIsImtleXJpbmciLCJmaW5kIiwieCIsImhhc2hlZE1lc3NhZ2UiLCJyYXdNZXNzYWdlU2lnIiwiUkVUUklBQkxFX0VSUk9SUyIsImNoZWNrRm9ySHR0cEVycm9ycyIsImZldGNoUmVzIiwibWV0aG9kTm90Rm91bmQiLCJpbnRlcm5hbCIsImNhdXNlIiwicGFyc2VSZXNwb25zZSIsImJvZHkiLCJjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEiLCJyZXEiLCJycGNUYXJnZXQiLCJvcmlnaW5IdHRwSGVhZGVyS2V5IiwicGFyc2VkVXJsIiwiaWQiLCJqc29ucnBjIiwib3JpZ2luRG9tYWluIiwic2VyaWFsaXplZFBheWxvYWQiLCJmZXRjaFBhcmFtcyIsIkFjY2VwdCIsImZldGNoVXJsIiwiaHJlZiIsImNyZWF0ZUZldGNoTWlkZGxld2FyZSIsIl9uZXh0IiwibWF4QXR0ZW1wdHMiLCJyZXRyeUludGVydmFsIiwiYXR0ZW1wdCIsImZldGNoIiwiZmV0Y2hCb2R5IiwianNvbiIsImVyciIsImVyck1zZyIsImlzUmV0cmlhYmxlIiwic29tZSIsInBocmFzZSIsImRlZmVycmVkUHJvbWlzZSIsInByb21pc2UiLCJfcmVzb2x2ZSIsImNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlIiwiY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdCIsImluZmxpZ2h0UmVxdWVzdHMiLCJjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlciIsImFjdGl2ZVJlcXVlc3RIYW5kbGVycyIsImhhbmRsZWRSZXMiLCJoYW5kbGVBY3RpdmVSZXF1ZXN0Iiwic2tpcENhY2hlIiwiY2FjaGVJZCIsImluZm8iLCJjcmVhdGVMb2dnZXJNaWRkbGV3YXJlIiwib3B0aW9ucyIsImxvZ2dlck1pZGRsZXdhcmUiLCJjYWxsYmFjayIsIndhcm4iLCJpc1RvcnVzSW50ZXJuYWwiLCJjcmVhdGVPcmlnaW5NaWRkbGV3YXJlIiwib3JpZ2luTWlkZGxld2FyZSIsImNyZWF0ZVJhbmRvbUlkIiwic3Vic3RyaW5nIiwiQ0hBSU5fTkFNRVNQQUNFUyIsIkVJUDE1NSIsIlNPTEFOQSIsIkNBU1BFUiIsIlhSUEwiLCJPVEhFUiIsIkJyb2FkY2FzdENoYW5uZWxIYW5kbGVyIiwiY2hhbm5lbFByZWZpeCIsImluc3RhbmNlSWQiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJjaGFubmVsIiwiYmMiLCJnZXRNZXNzYWdlRnJvbUNoYW5uZWwiLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZXYiLCJjbG9zZSIsInBvc3RNZXNzYWdlIiwiU3RyZWFtV2luZG93Iiwib3BlbiIsImNvbW11bmljYXRpb25FbmdpbmUiLCJjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlciIsInBvcHVwU3VjY2VzcyIsImNsb3NlZCIsImhhbmRsZVdpbmRvd0Jsb2NrQWxlcnQiLCJmaW5hbFVybCIsInVybCIsInRoZW4iLCJjYXRjaCIsImlzRnVsbFNjcmVlbiIsInJpZCIsImNoYW5uZWxOYW1lIiwicG9zdE1zZyIsImxvY2FsUmVzcG9uc2UiLCJjdXJyZW50RGVsYXkiLCJyZWN1cnNpdmVGbiIsInNlcnZlclJlc3BvbnNlIiwiUG9wdXBIYW5kbGVyIiwid2luZG93VGltZXIiLCJpQ2xvc2VkV2luZG93IiwiX3NldHVwVGltZXIiLCJsb2NhbFdpbmRvdyIsImZpbmFsV2luZG93SWQiLCJzdHJlYW1XaW5kb3ciLCJ0aW1lciIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIlBvcHVwU3RvcmVDaGFubmVsIiwiaGFuZGxlTG9nb3V0IiwiaGFuZGxlQWNjb3VudEltcG9ydCIsImhhbmRsZU5ldHdvcmtDaGFuZ2UiLCJoYW5kbGVTZWxlY3RlZEFkZHJlc3NDaGFuZ2UiLCJoYW5kbGVUaGVtZUNoYW5nZSIsInNldHVwU3RvcmVDaGFubmVscyIsImxvZ291dENoYW5uZWwiLCJpbXBvcnRBY2NvdW50Q2hhbm5lbCIsIm5ldHdvcmtDaGFuZ2VDaGFubmVsIiwic2VsZWN0ZWRBZGRyZXNzQ2hhbmdlQ2hhbm5lbCIsInRoZW1lQ2hhbmdlZENoYW5uZWwiLCJfZXYkZGF0YSIsIndhbGxldEFjY291bnRJbXBvcnRDaGFubmVsIiwiX2V2JGRhdGEyIiwiX2V2JGRhdGEzIiwiX2V2JGRhdGE0IiwiX2V2JGRhdGE1IiwiX2V2JGRhdGE2IiwiX2V2JGRhdGE3IiwidGhlbWUiLCJfZXYkZGF0YTgiLCJfZXYkZGF0YTkiLCJzZWxlY3RlZEFkZHJlc3MiLCJQb3B1cFdpdGhCY0hhbmRsZXIiLCJoYW5kbGUiLCJzdWNjZXNzRXh0cmFGbiIsImNsb3NlTGlzdGVuZXIiLCJoYW5kbGVXaXRoSGFuZHNoYWtlIiwiUmVkaXJlY3RIYW5kbGVyIiwiZmluYWxRdWVyeVBhcmFtcyIsIkhUVFBfTUVUSE9EIiwiY29uc3RydWN0QXV0aEhlYWRlcnMiLCJqd3RUb2tlbiIsIndpdGhVbmF1dGhvcml6ZWRIYW5kbGVyIiwiZm4iLCJlbWl0dGVyIiwiZSIsIlVzZXJVbmF1dGhvcml6ZWQiLCJqd3RUb2tlbkV4cGlyZWQiLCJkZWNvZGVkIiwiand0RXhwaXJ5IiwiZXhwIiwiY3VycmVudFRpbWUiLCJnZXRUaW1lIiwiV1NBcGlDbGllbnQiLCJiYXNlQXBpVXJsIiwiYXV0aFJlcXVlc3QiLCJhdXRoQ3JlZGVudGlhbHMiLCJjdXN0b21PcHRpb25zIiwic3RhdHVzVGV4dCIsIkdFVCIsIlBPU1QiLCJQVVQiLCJQQVRDSCIsIkRFTEVURSIsImF1dGhHZXQiLCJhdXRoUG9zdCIsImF1dGhQdXQiLCJhdXRoUGF0Y2giLCJhdXRoUmVtb3ZlIiwiQUNUSVZJVFlfQUNUSU9OIiwiQUNDT1VOVF9DQVRFR09SWSIsIk5PUk1BTCIsIlRIUkVTSE9MRCIsIklNUE9SVEVEIiwiQVBQX1NDT1BFRCIsIkFDQ09VTlRfQUJTVFJBQ1RJT04iLCJFWFRFUk5BTCIsIk1QQyIsIlNGQSIsIkRFRkFVTFRfSU5URVJWQUwiLCJERUZBVUxUX1BSRUZFUkVOQ0VTIiwic2VsZWN0ZWRDdXJyZW5jeSIsImxvY2FsZSIsImFjY291bnRUeXBlIiwiY29udGFjdHMiLCJmZXRjaGVkUGFzdFR4IiwicGFzdFRyYW5zYWN0aW9ucyIsInBheW1lbnRUeCIsImRlZmF1bHRQdWJsaWNBZGRyZXNzIiwiY3VzdG9tVG9rZW5zIiwiY3VzdG9tTmZ0cyIsImNyYXNoUmVwb3J0IiwidXNlckluZm8iLCJhZ2dyZWdhdGVWZXJpZmllciIsImVtYWlsIiwicHJvZmlsZUltYWdlIiwidHlwZU9mTG9naW4iLCJ2ZXJpZmllciIsInZlcmlmaWVySWQiLCJCYXNlUHJlZmVyZW5jZXNDb250cm9sbGVyIiwiZGVmYXVsdFByZWZlcmVuY2VzIiwidmFsaWRhdGVTaWduTWVzc2FnZSIsImFwaSIsImlkZW50aXRpZXMiLCJsYXN0RXJyb3JNZXNzYWdlIiwibGFzdFN1Y2Nlc3NNZXNzYWdlIiwid3NBcGlDbGllbnQiLCJzZXRJZnJhbWVPcmlnaW4iLCJpZnJhbWVPcmlnaW4iLCJnZXRBZGRyZXNzU3RhdGUiLCJzZXRTZWxlY3RlZEFkZHJlc3MiLCJnZXRVc2VyIiwidXNlciIsInVzZUFQSUtleSIsImNyZWF0ZVVzZXIiLCJpZFRva2VuIiwidXNlclBheWxvYWQiLCJkZWZhdWx0X2N1cnJlbmN5IiwidmVyaWZpZXJfaWQiLCJhY2NvdW50X3R5cGUiLCJ1cGRhdGVTdGF0ZSIsInN0b3JlVXNlckxvZ2luIiwic2Vzc2lvblB1YktleSIsImxvZ2luTW9kZSIsInJlaHlkcmF0ZSIsImdldFBhcnNlciIsInVzZXJBZ2VudCIsInNwZWNpYWxCcm93c2VyIiwicmVjb3JkTG9naW5QYXlsb2FkIiwib3MiLCJnZXRPU05hbWUiLCJvc192ZXJzaW9uIiwiZ2V0T1NWZXJzaW9uIiwiZ2V0QnJvd3Nlck5hbWUiLCJicm93c2VyX3ZlcnNpb24iLCJnZXRCcm93c2VyVmVyc2lvbiIsInBsYXRmb3JtIiwiZ2V0UGxhdGZvcm0iLCJ3ZWIzYXV0aF9jbGllbnRfaWQiLCJzZXNzaW9uX3B1Yl9rZXkiLCJsb2dpbl9tb2RlIiwic2V0Q3Jhc2hSZXBvcnQiLCJpc0VuYWJsZWQiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGUiLCJlbmFibGVfY3Jhc2hfcmVwb3J0ZXIiLCJzZXRVc2VyVGhlbWUiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGUyIiwic2V0VXNlckxvY2FsZSIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZTMiLCJzZXRTZWxlY3RlZEN1cnJlbmN5IiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNCIsImFkZENvbnRhY3QiLCJjb250YWN0IiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNSIsImRlbGV0ZUNvbnRhY3QiLCJjb250YWN0SWQiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGU2IiwiZmluYWxDb250YWN0cyIsInJldm9rZURpc2NvcmQiLCJyZXNwIiwicGF0Y2hQYXN0VHgiLCJwb3N0UGFzdFR4IiwidHgiLCJnZXRXYWxsZXRPcmRlcnMiLCJnZXRUb3BVcE9yZGVycyIsImdldEJpbGxCb2FyZERhdGEiLCJnZXRNZXNzYWdlRm9yU2lnbmluZyIsIndlYjNBdXRoSWRUb2tlbiIsInB1YmxpY19hZGRyZXNzIiwiaWRfdG9rZW4iLCJnZXRUd2l0dGVySWQiLCJuaWNrIiwic2VuZEVtYWlsIiwiZW1haWxPYmplY3QiLCJyZWZyZXNoSnd0IiwibWVzc2FnZVRvU2lnbiIsInNpZ25lZF9tZXNzYWdlIiwiZ2V0RGFwcExpc3QiLCJpbml0IiwibWV0YWRhdGEiLCJzaWduYXR1cmVzIiwicHJlZmVyZW5jZXMiLCJjdXJyZW50U3RhdGUiLCJtZXJnZWRTdGF0ZSIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZTciLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGU4IiwiVHJhbnNhY3Rpb25TdGF0dXMiLCJUUkFOU0FDVElPTl9UWVBFUyIsIkNBTkNFTCIsIlJFVFJZIiwiQ09OVFJBQ1RfSU5URVJBQ1RJT04iLCJERVBMT1lfQ09OVFJBQ1QiLCJXQVNNX0JBU0VEX0RFUExPWSIsIlNUQU5EQVJEX1RSQU5TQUNUSU9OIiwiU1RBTkRBUkRfUEFZTUVOVF9UUkFOU0FDVElPTiIsIlNFTlRfRVRIRVIiLCJUT0tFTl9NRVRIT0RfVFJBTlNGRVIiLCJUT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTSIsIlRPS0VOX01FVEhPRF9BUFBST1ZFIiwiQ09MTEVDVElCTEVfTUVUSE9EX1NBRkVfVFJBTlNGRVJfRlJPTSIsIlNFVF9BUFBST1ZBTF9GT1JfQUxMIiwiVFhfRVZFTlRTIiwiVFhfV0FSTklORyIsIlRYX0VSUk9SIiwiVFhfRkFJTEVEIiwiVFhfQ09ORklSTUVEIiwiVFhfRFJPUFBFRCIsIlRYX0VYUElSRUQiLCJUWF9TVEFUVVNfVVBEQVRFIiwiVFhfVU5BUFBST1ZFRCIsIlRYX1JFVFJZIiwiVFhfQkxPQ0tfVVBEQVRFIiwiQmFzZVRyYW5zYWN0aW9uU3RhdGVNYW5hZ2VyIiwiZ2V0Q3VycmVudENoYWluSWQiLCJ0eEhpc3RvcnlMaW1pdCIsInRyYW5zYWN0aW9ucyIsInVuYXBwcm92ZWRUeHMiLCJjdXJyZW50TmV0d29ya1R4c0xpc3QiLCJnZXRVbmFwcHJvdmVkVHhMaXN0IiwidW5hcHByb3ZlZCIsImdldFRyYW5zYWN0aW9uIiwidHhJZCIsInVwZGF0ZVRyYW5zYWN0aW9uIiwidHhNZXRhIiwidXBkYXRlZF9hdCIsInRvSVNPU3RyaW5nIiwic2V0VHhTdGF0dXNSZWplY3RlZCIsIl9zZXRUcmFuc2FjdGlvblN0YXR1cyIsInJlamVjdGVkIiwiX2RlbGV0ZVRyYW5zYWN0aW9uIiwic2V0VHhTdGF0dXNVbmFwcHJvdmVkIiwic2V0VHhTdGF0dXNBcHByb3ZlZCIsImFwcHJvdmVkIiwic2V0VHhTdGF0dXNTaWduZWQiLCJpc0ZpbmFsU3RlcCIsInNpZ25lZCIsInNldFR4U3RhdHVzU3VibWl0dGVkIiwic3VibWl0dGVkIiwic2V0VHhTdGF0dXNEcm9wcGVkIiwiZHJvcHBlZCIsInNldFR4U3RhdHVzRXhwaXJlZCIsImV4cGlyZWQiLCJzZXRUeFN0YXR1c0NvbmZpcm1lZCIsImNvbmZpcm1lZCIsInNldFR4U3RhdHVzRmFpbGVkIiwiZXJyb3JfIiwiZmFpbGVkIiwiaXNGaW5hbFN0YXRlIiwiY2FuY2VsbGVkIiwiY2xlYXJVbmFwcHJvdmVkVHhzIiwiX2FkZFRyYW5zYWN0aW9uc1RvU3RhdGUiLCJuZXdUeCIsIl9zZXRUcmFuc2FjdGlvbnNUb1N0YXRlIiwidGFyZ2V0VHJhbnNhY3Rpb25JZCIsIl9kZWxldGVUcmFuc2FjdGlvbnMiLCJ0YXJnZXRUcmFuc2FjdGlvbklkcyIsInRyYW5zYWN0aW9uSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BroadcastChannel: () => (/* binding */ BroadcastChannel$1),\n/* harmony export */   IndexedDbMethod: () => (/* binding */ IndexeDbMethod),\n/* harmony export */   LocalStorageMethod: () => (/* binding */ LocalstorageMethod),\n/* harmony export */   NativeMethod: () => (/* binding */ NativeMethod),\n/* harmony export */   OPEN_BROADCAST_CHANNELS: () => (/* binding */ OPEN_BROADCAST_CHANNELS),\n/* harmony export */   ServerMethod: () => (/* binding */ ServerMethod),\n/* harmony export */   chooseMethod: () => (/* binding */ chooseMethod),\n/* harmony export */   enforceOptions: () => (/* binding */ enforceOptions)\n/* harmony export */ });\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! oblivious-set */ \"(ssr)/./node_modules/oblivious-set/dist/esm/src/index.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"(ssr)/./node_modules/socket.io-client/build/esm-debug/index.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n/* harmony import */ var _toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/metadata-helpers */ \"(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\");\n\n\n\n\n\n// import Bowser from 'bowser';\n/**\n * returns true if the given object is a promise\n */ function isPromise(obj) {\n    if (obj && typeof obj.then === \"function\") {\n        return true;\n    } else {\n        return false;\n    }\n}\nPromise.resolve(false);\nPromise.resolve(true);\nconst PROMISE_RESOLVED_VOID = Promise.resolve();\nfunction sleep(time, resolveWith) {\n    if (!time) time = 0;\n    return new Promise((res)=>setTimeout(()=>res(resolveWith), time));\n}\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/8084248\n */ function randomToken() {\n    return Math.random().toString(36).substring(2);\n}\nlet lastMs = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */ function microSeconds$5() {\n    let ret = Date.now() * 1000; // milliseconds to microseconds\n    if (ret <= lastMs) {\n        ret = lastMs + 1;\n    }\n    lastMs = ret;\n    return ret;\n}\n// the problem is only in iframes. we should default to server in case of iframes.\n// storage scoping is present in all browsers now\n// Safari and other browsers support native Broadcast channel now. It's in LS.\n// test here: https://pubkey.github.io/broadcast-channel/e2e.html?methodType=native\n// https://caniuse.com/broadcastchannel\n// export function are3PCSupported() {\n//     if (typeof navigator === 'undefined') return false;\n//     const browserInfo = Bowser.parse(navigator.userAgent);\n//     log.info(JSON.stringify(browserInfo), 'current browser info');\n//     let thirdPartyCookieSupport = true;\n//     // brave\n//     if (navigator.brave) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     // All webkit & gecko engine instances use itp (intelligent tracking prevention -\n//     // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)\n//     if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     return thirdPartyCookieSupport;\n// }\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_0___default().getLogger(\"broadcast-channel\");\nlog.setLevel(\"error\");\nconst microSeconds$4 = microSeconds$5;\nconst type$4 = \"native\";\nfunction create$4(channelName) {\n    const state = {\n        time: microSeconds$5(),\n        messagesCallback: null,\n        bc: new BroadcastChannel(channelName),\n        subFns: [] // subscriberFunctions\n    };\n    state.bc.onmessage = (msg)=>{\n        if (state.messagesCallback) {\n            state.messagesCallback(msg.data);\n        }\n    };\n    return state;\n}\nfunction close$4(channelState) {\n    channelState.bc.close();\n    channelState.subFns = [];\n}\nfunction postMessage$4(channelState, messageJson) {\n    try {\n        channelState.bc.postMessage(messageJson, false);\n        return PROMISE_RESOLVED_VOID;\n    } catch (err) {\n        return Promise.reject(err);\n    }\n}\nfunction onMessage$4(channelState, fn1) {\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$4() {\n    /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */ if (true) return false;\n    if (typeof BroadcastChannel === \"function\") {\n        if (BroadcastChannel._pubkey) {\n            throw new Error(\"BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill\");\n        }\n        return true;\n    } else return false;\n}\nfunction averageResponseTime$4() {\n    return 150;\n}\nvar NativeMethod = {\n    create: create$4,\n    close: close$4,\n    onMessage: onMessage$4,\n    postMessage: postMessage$4,\n    canBeUsed: canBeUsed$4,\n    type: type$4,\n    averageResponseTime: averageResponseTime$4,\n    microSeconds: microSeconds$4\n};\nfunction fillOptionsWithDefaults() {\n    let originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = JSON.parse(JSON.stringify(originalOptions));\n    // main\n    if (typeof options.webWorkerSupport === \"undefined\") options.webWorkerSupport = true;\n    // indexed-db\n    if (!options.idb) options.idb = {};\n    //  after this time the messages get deleted\n    if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n    if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n    //  handles abrupt db onclose events.\n    if (originalOptions.idb && typeof originalOptions.idb.onclose === \"function\") options.idb.onclose = originalOptions.idb.onclose;\n    // localstorage\n    if (!options.localstorage) options.localstorage = {};\n    if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n    // server\n    if (!options.server) options.server = {};\n    if (!options.server.url) options.server.url = \"https://session.web3auth.io\";\n    if (!options.server.removeTimeout) options.server.removeTimeout = 1000 * 60 * 5; // 5 minutes\n    // custom methods\n    if (originalOptions.methods) options.methods = originalOptions.methods;\n    return options;\n}\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n *\n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */ const microSeconds$3 = microSeconds$5;\nconst DB_PREFIX = \"pubkey.broadcast-channel-0-\";\nconst OBJECT_STORE_ID = \"messages\";\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */ const TRANSACTION_SETTINGS = {\n    durability: \"relaxed\"\n};\nconst type$3 = \"idb\";\nfunction getIdb() {\n    if (typeof indexedDB !== \"undefined\") return indexedDB;\n    if (false) {}\n    return false;\n}\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */ function commitIndexedDBTransaction(tx) {\n    if (tx.commit) {\n        tx.commit();\n    }\n}\nfunction createDatabase(channelName) {\n    const IndexedDB = getIdb();\n    // create table\n    const dbName = DB_PREFIX + channelName;\n    /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */ const openRequest = IndexedDB.open(dbName);\n    openRequest.onupgradeneeded = (ev)=>{\n        const db = ev.target.result;\n        db.createObjectStore(OBJECT_STORE_ID, {\n            keyPath: \"id\",\n            autoIncrement: true\n        });\n    };\n    const dbPromise = new Promise((res, rej)=>{\n        openRequest.onerror = (ev)=>rej(ev);\n        openRequest.onsuccess = ()=>{\n            res(openRequest.result);\n        };\n    });\n    return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */ function writeMessage(db, readerUuid, messageJson) {\n    const time = Date.now();\n    const writeObject = {\n        uuid: readerUuid,\n        time,\n        data: messageJson\n    };\n    const tx = db.transaction([\n        OBJECT_STORE_ID\n    ], \"readwrite\", TRANSACTION_SETTINGS);\n    return new Promise((res, rej)=>{\n        tx.oncomplete = ()=>res();\n        tx.onerror = (ev)=>rej(ev);\n        const objectStore = tx.objectStore(OBJECT_STORE_ID);\n        objectStore.add(writeObject);\n        commitIndexedDBTransaction(tx);\n    });\n}\nfunction getAllMessages(db) {\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    return new Promise((res)=>{\n        objectStore.openCursor().onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                ret.push(cursor.value);\n                //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n                cursor.continue();\n            } else {\n                commitIndexedDBTransaction(tx);\n                res(ret);\n            }\n        };\n    });\n}\nfunction getMessagesHigherThan(db, lastCursorId) {\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n    /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */ if (objectStore.getAll) {\n        const getAllRequest = objectStore.getAll(keyRangeValue);\n        return new Promise((res, rej)=>{\n            getAllRequest.onerror = (err)=>rej(err);\n            getAllRequest.onsuccess = function(e) {\n                res(e.target.result);\n            };\n        });\n    }\n    function openCursor() {\n        // Occasionally Safari will fail on IDBKeyRange.bound, this\n        // catches that error, having it open the cursor to the first\n        // item. When it gets data it will advance to the desired key.\n        try {\n            keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n            return objectStore.openCursor(keyRangeValue);\n        } catch (e) {\n            return objectStore.openCursor();\n        }\n    }\n    return new Promise((res, rej)=>{\n        const openCursorRequest = openCursor();\n        openCursorRequest.onerror = (err)=>rej(err);\n        openCursorRequest.onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                if (cursor.value.id < lastCursorId + 1) {\n                    cursor.continue(lastCursorId + 1);\n                } else {\n                    ret.push(cursor.value);\n                    cursor.continue();\n                }\n            } else {\n                commitIndexedDBTransaction(tx);\n                res(ret);\n            }\n        };\n    });\n}\nfunction removeMessagesById(db, ids) {\n    const tx = db.transaction([\n        OBJECT_STORE_ID\n    ], \"readwrite\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    return Promise.all(ids.map((id)=>{\n        const deleteRequest = objectStore.delete(id);\n        return new Promise((res)=>{\n            deleteRequest.onsuccess = ()=>res();\n        });\n    }));\n}\nfunction getOldMessages(db, ttl) {\n    const olderThen = Date.now() - ttl;\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    return new Promise((res)=>{\n        objectStore.openCursor().onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                const msgObk = cursor.value;\n                if (msgObk.time < olderThen) {\n                    ret.push(msgObk);\n                    //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n                    cursor.continue();\n                } else {\n                    // no more old messages,\n                    commitIndexedDBTransaction(tx);\n                    res(ret);\n                    return;\n                }\n            } else {\n                res(ret);\n            }\n        };\n    });\n}\nfunction cleanOldMessages(db, ttl) {\n    return getOldMessages(db, ttl).then((tooOld)=>{\n        return removeMessagesById(db, tooOld.map((msg)=>msg.id));\n    });\n}\nfunction create$3(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    return createDatabase(channelName).then((db)=>{\n        const state = {\n            closed: false,\n            lastCursorId: 0,\n            channelName,\n            options,\n            uuid: randomToken(),\n            /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */ eMIs: new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.idb.ttl * 2),\n            // ensures we do not read messages in parrallel\n            writeBlockPromise: PROMISE_RESOLVED_VOID,\n            messagesCallback: null,\n            readQueuePromises: [],\n            db,\n            time: microSeconds$5()\n        };\n        /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */ db.onclose = function() {\n            state.closed = true;\n            if (options.idb.onclose) options.idb.onclose();\n        };\n        /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */ _readLoop(state);\n        return state;\n    });\n}\nfunction _readLoop(state) {\n    if (state.closed) return;\n    readNewMessages(state).then(()=>sleep(state.options.idb.fallbackInterval)).then(()=>_readLoop(state));\n}\nfunction _filterMessage(msgObj, state) {\n    if (msgObj.uuid === state.uuid) return false; // send by own\n    if (state.eMIs.has(msgObj.id)) return false; // already emitted\n    if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n    return true;\n}\n/**\n * reads all new messages from the database and emits them\n */ function readNewMessages(state) {\n    // channel already closed\n    if (state.closed) return PROMISE_RESOLVED_VOID;\n    // if no one is listening, we do not need to scan for new messages\n    if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n    return getMessagesHigherThan(state.db, state.lastCursorId).then((newerMessages)=>{\n        const useMessages = newerMessages/**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */ .filter((msgObj)=>!!msgObj).map((msgObj)=>{\n            if (msgObj.id > state.lastCursorId) {\n                state.lastCursorId = msgObj.id;\n            }\n            return msgObj;\n        }).filter((msgObj)=>_filterMessage(msgObj, state)).sort((msgObjA, msgObjB)=>msgObjA.time - msgObjB.time); // sort by time\n        useMessages.forEach((msgObj)=>{\n            if (state.messagesCallback) {\n                state.eMIs.add(msgObj.id);\n                state.messagesCallback(msgObj.data);\n            }\n        });\n        return PROMISE_RESOLVED_VOID;\n    });\n}\nfunction close$3(channelState) {\n    channelState.closed = true;\n    channelState.db.close();\n}\nfunction postMessage$3(channelState, messageJson) {\n    channelState.writeBlockPromise = channelState.writeBlockPromise.then(()=>writeMessage(channelState.db, channelState.uuid, messageJson)).then(()=>{\n        if (randomInt(0, 10) === 0) {\n            /* await (do not await) */ cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n        }\n    });\n    return channelState.writeBlockPromise;\n}\nfunction onMessage$3(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n    readNewMessages(channelState);\n}\nfunction canBeUsed$3() {\n    const idb = getIdb();\n    if (!idb) return false;\n    return true;\n}\nfunction averageResponseTime$3(options) {\n    return options.idb.fallbackInterval * 2;\n}\nvar IndexeDbMethod = {\n    getIdb,\n    createDatabase,\n    create: create$3,\n    close: close$3,\n    onMessage: onMessage$3,\n    postMessage: postMessage$3,\n    canBeUsed: canBeUsed$3,\n    type: type$3,\n    averageResponseTime: averageResponseTime$3,\n    microSeconds: microSeconds$3,\n    writeMessage,\n    getAllMessages,\n    cleanOldMessages,\n    getMessagesHigherThan,\n    getOldMessages\n};\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */ const microSeconds$2 = microSeconds$5;\nconst KEY_PREFIX$1 = \"pubkey.broadcastChannel-\";\nconst type$2 = \"localstorage\";\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */ function getLocalStorage() {\n    let localStorage;\n    if (true) return null;\n    try {\n        localStorage = window.localStorage;\n        localStorage = window[\"ie8-eventlistener/storage\"] || window.localStorage;\n    } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n    }\n    return localStorage;\n}\nfunction storageKey$1(channelName) {\n    return KEY_PREFIX$1 + channelName;\n}\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */ function postMessage$2(channelState, messageJson) {\n    return new Promise((res)=>{\n        sleep().then(()=>{\n            const key = storageKey$1(channelState.channelName);\n            const writeObj = {\n                token: randomToken(),\n                time: Date.now(),\n                data: messageJson,\n                uuid: channelState.uuid\n            };\n            const value = JSON.stringify(writeObj);\n            getLocalStorage().setItem(key, value);\n            /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */ const ev = document.createEvent(\"Event\");\n            ev.initEvent(\"storage\", true, true);\n            ev.key = key;\n            ev.newValue = value;\n            window.dispatchEvent(ev);\n            res();\n        });\n    });\n}\nfunction addStorageEventListener(channelName, fn1) {\n    const key = storageKey$1(channelName);\n    const listener = (ev)=>{\n        if (ev.key === key) {\n            fn1(JSON.parse(ev.newValue));\n        }\n    };\n    window.addEventListener(\"storage\", listener);\n    return listener;\n}\nfunction removeStorageEventListener(listener) {\n    window.removeEventListener(\"storage\", listener);\n}\nfunction create$2(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    if (!canBeUsed$2()) {\n        throw new Error(\"BroadcastChannel: localstorage cannot be used\");\n    }\n    const uuid = randomToken();\n    /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */ const eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.localstorage.removeTimeout);\n    const state = {\n        channelName,\n        uuid,\n        time: microSeconds$5(),\n        eMIs\n    };\n    state.listener = addStorageEventListener(channelName, (msgObj)=>{\n        if (!state.messagesCallback) return; // no listener\n        if (msgObj.uuid === uuid) return; // own message\n        if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n        if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n        eMIs.add(msgObj.token);\n        state.messagesCallback(msgObj.data);\n    });\n    return state;\n}\nfunction close$2(channelState) {\n    removeStorageEventListener(channelState.listener);\n}\nfunction onMessage$2(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$2() {\n    const ls = getLocalStorage();\n    if (!ls) return false;\n    try {\n        const key = \"__broadcastchannel_check\";\n        ls.setItem(key, \"works\");\n        ls.removeItem(key);\n    } catch (e) {\n        // Safari 10 in private mode will not allow write access to local\n        // storage and fail with a QuotaExceededError. See\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n        return false;\n    }\n    return true;\n}\nfunction averageResponseTime$2() {\n    const defaultTime = 120;\n    const userAgent = navigator.userAgent.toLowerCase();\n    if (userAgent.includes(\"safari\") && !userAgent.includes(\"chrome\")) {\n        // safari is much slower so this time is higher\n        return defaultTime * 2;\n    }\n    return defaultTime;\n}\nvar LocalstorageMethod = {\n    getLocalStorage,\n    create: create$2,\n    close: close$2,\n    onMessage: onMessage$2,\n    postMessage: postMessage$2,\n    canBeUsed: canBeUsed$2,\n    type: type$2,\n    averageResponseTime: averageResponseTime$2,\n    microSeconds: microSeconds$2,\n    storageKey: storageKey$1,\n    addStorageEventListener,\n    removeStorageEventListener\n};\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */ const microSeconds$1 = microSeconds$5;\nconst KEY_PREFIX = \"pubkey.broadcastChannel-\";\nconst type$1 = \"server\";\nlet SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nconst runningChannels = new Set();\nfunction storageKey(channelName) {\n    return KEY_PREFIX + channelName;\n}\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */ function postMessage$1(channelState, messageJson) {\n    return new Promise((res, rej)=>{\n        sleep().then(async ()=>{\n            const key = storageKey(channelState.channelName);\n            const channelEncPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(key, \"utf8\"));\n            const encData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.encryptData)(channelEncPrivKey.toString(\"hex\"), {\n                token: randomToken(),\n                time: Date.now(),\n                data: messageJson,\n                uuid: channelState.uuid\n            });\n            const body = {\n                sameOriginCheck: true,\n                sameIpCheck: true,\n                key: (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(channelEncPrivKey).toString(\"hex\"),\n                data: encData,\n                signature: (await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.sign)(channelEncPrivKey, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(encData, \"utf8\")))).toString(\"hex\")\n            };\n            if (channelState.timeout) body.timeout = channelState.timeout;\n            return fetch(channelState.serverUrl + \"/channel/set\", {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: {\n                    \"Content-Type\": \"application/json; charset=utf-8\"\n                }\n            }).then(res).catch(rej);\n        });\n    });\n}\nfunction getSocketInstance(serverUrl) {\n    if (SOCKET_CONN_INSTANCE) {\n        return SOCKET_CONN_INSTANCE;\n    }\n    const SOCKET_CONN = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(serverUrl, {\n        transports: [\n            \"websocket\",\n            \"polling\"\n        ],\n        // use WebSocket first, if available\n        withCredentials: true,\n        reconnectionDelayMax: 10000,\n        reconnectionAttempts: 10\n    });\n    SOCKET_CONN.on(\"connect_error\", (err)=>{\n        // revert to classic upgrade\n        SOCKET_CONN.io.opts.transports = [\n            \"polling\",\n            \"websocket\"\n        ];\n        log.error(\"connect error\", err);\n    });\n    SOCKET_CONN.on(\"connect\", async ()=>{\n        const { engine } = SOCKET_CONN.io;\n        log.debug(\"initially connected to\", engine.transport.name); // in most cases, prints \"polling\"\n        engine.once(\"upgrade\", ()=>{\n            // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n            log.debug(\"upgraded\", engine.transport.name); // in most cases, prints \"websocket\"\n        });\n        engine.once(\"close\", (reason)=>{\n            // called when the underlying connection is closed\n            log.debug(\"connection closed\", reason);\n        });\n    });\n    SOCKET_CONN.on(\"error\", (err)=>{\n        log.error(\"socket errored\", err);\n        SOCKET_CONN.disconnect();\n    });\n    SOCKET_CONN_INSTANCE = SOCKET_CONN;\n    return SOCKET_CONN;\n}\nfunction setupSocketConnection(serverUrl, channelState, fn1) {\n    const socketConn = getSocketInstance(serverUrl);\n    const key = storageKey(channelState.channelName);\n    const channelEncPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(key, \"utf8\"));\n    const channelPubKey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(channelEncPrivKey).toString(\"hex\");\n    if (socketConn.connected) {\n        socketConn.emit(\"check_auth_status\", channelPubKey, {\n            sameOriginCheck: true,\n            sameIpCheck: true\n        });\n    } else {\n        socketConn.once(\"connect\", ()=>{\n            log.debug(\"connected with socket\");\n            socketConn.emit(\"check_auth_status\", channelPubKey, {\n                sameOriginCheck: true,\n                sameIpCheck: true\n            });\n        });\n    }\n    const reconnect = ()=>{\n        socketConn.once(\"connect\", async ()=>{\n            if (runningChannels.has(channelState.channelName)) {\n                socketConn.emit(\"check_auth_status\", channelPubKey, {\n                    sameOriginCheck: true,\n                    sameIpCheck: true\n                });\n            }\n        });\n    };\n    const visibilityListener = ()=>{\n        // if channel is closed, then remove the listener.\n        if (!socketConn || !runningChannels.has(channelState.channelName)) {\n            document.removeEventListener(\"visibilitychange\", visibilityListener);\n            return;\n        }\n        // if not connected, then wait for connection and ping server for latest msg.\n        if (!socketConn.connected && document.visibilityState === \"visible\") {\n            reconnect();\n        }\n    };\n    const listener = async (ev)=>{\n        try {\n            const decData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.decryptData)(channelEncPrivKey.toString(\"hex\"), ev);\n            log.info(decData);\n            fn1(decData);\n        } catch (error) {\n            log.error(error);\n        }\n    };\n    socketConn.on(\"disconnect\", ()=>{\n        log.debug(\"socket disconnected\");\n        if (runningChannels.has(channelState.channelName)) {\n            log.error(\"socket disconnected unexpectedly, reconnecting socket\");\n            reconnect();\n        }\n    });\n    socketConn.on(`${channelPubKey}_success`, listener);\n    if (typeof document !== \"undefined\") document.addEventListener(\"visibilitychange\", visibilityListener);\n    return socketConn;\n}\nfunction create$1(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    const uuid = randomToken();\n    /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */ const eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.server.removeTimeout);\n    const state = {\n        channelName,\n        uuid,\n        eMIs,\n        // emittedMessagesIds\n        serverUrl: options.server.url,\n        time: microSeconds$5()\n    };\n    if (options.server.timeout) state.timeout = options.server.timeout;\n    setupSocketConnection(options.server.url, state, (msgObj)=>{\n        if (!state.messagesCallback) return; // no listener\n        if (msgObj.uuid === state.uuid) return; // own message\n        if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n        // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n        state.eMIs.add(msgObj.token);\n        state.messagesCallback(msgObj.data);\n    });\n    runningChannels.add(channelName);\n    return state;\n}\nfunction close$1(channelState) {\n    runningChannels.delete(channelState.channelName);\n// give 2 sec for all msgs which are in transit to be consumed\n// by receiver.\n// window.setTimeout(() => {\n//     removeStorageEventListener(channelState);\n//     SOCKET_CONN_INSTANCE = null;\n// }, 1000);\n}\nfunction onMessage$1(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$1() {\n    return true;\n}\nfunction averageResponseTime$1() {\n    const defaultTime = 500;\n    // TODO: Maybe increase it based on operation\n    return defaultTime;\n}\nvar ServerMethod = {\n    create: create$1,\n    close: close$1,\n    onMessage: onMessage$1,\n    postMessage: postMessage$1,\n    canBeUsed: canBeUsed$1,\n    type: type$1,\n    averageResponseTime: averageResponseTime$1,\n    microSeconds: microSeconds$1\n};\nconst microSeconds = microSeconds$5;\nconst type = \"simulate\";\nconst SIMULATE_CHANNELS = new Set();\nconst SIMULATE_DELAY_TIME = 5;\nfunction create(channelName) {\n    const state = {\n        time: microSeconds$5(),\n        name: channelName,\n        messagesCallback: null\n    };\n    SIMULATE_CHANNELS.add(state);\n    return state;\n}\nfunction close(channelState) {\n    SIMULATE_CHANNELS.delete(channelState);\n}\nfunction postMessage(channelState, messageJson) {\n    return new Promise((res)=>setTimeout(()=>{\n            const channelArray = Array.from(SIMULATE_CHANNELS);\n            channelArray.forEach((channel)=>{\n                if (channel.name === channelState.name && // has same name\n                channel !== channelState && // not own channel\n                !!channel.messagesCallback && // has subscribers\n                channel.time < messageJson.time // channel not created after postMessage() call\n                ) {\n                    channel.messagesCallback(messageJson);\n                }\n            });\n            res();\n        }, SIMULATE_DELAY_TIME));\n}\nfunction onMessage(channelState, fn1) {\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed() {\n    return true;\n}\nfunction averageResponseTime() {\n    return SIMULATE_DELAY_TIME;\n}\nvar SimulateMethod = {\n    create,\n    close,\n    onMessage,\n    postMessage,\n    canBeUsed,\n    type,\n    averageResponseTime,\n    microSeconds\n};\n// order is important\nconst METHODS = [\n    NativeMethod,\n    // fastest\n    IndexeDbMethod,\n    LocalstorageMethod,\n    ServerMethod\n];\nfunction chooseMethod(options) {\n    let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n    // directly chosen\n    if (options.type) {\n        if (options.type === \"simulate\") {\n            // only use simulate-method if directly chosen\n            return SimulateMethod;\n        }\n        const ret = chooseMethods.find((m)=>m.type === options.type);\n        if (!ret) throw new Error(\"method-type \" + options.type + \" not found\");\n        else return ret;\n    }\n    /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */ if (!options.webWorkerSupport) {\n        chooseMethods = chooseMethods.filter((m)=>m.type !== \"idb\");\n    }\n    const useMethod = chooseMethods.find((method)=>method.canBeUsed(options));\n    if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map((m)=>m.type))}`);\n    else return useMethod;\n}\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */ const OPEN_BROADCAST_CHANNELS = new Set();\nlet lastId = 0;\nconst BroadcastChannel$1 = function(name, options) {\n    // identifier of the channel to debug stuff\n    this.id = lastId++;\n    OPEN_BROADCAST_CHANNELS.add(this);\n    this.name = name;\n    if (ENFORCED_OPTIONS) {\n        options = ENFORCED_OPTIONS;\n    }\n    this.options = fillOptionsWithDefaults(options);\n    this.method = chooseMethod(this.options);\n    // isListening\n    this._iL = false;\n    /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */ this._onML = null;\n    /**\n   * _addEventListeners\n   */ this._addEL = {\n        message: [],\n        internal: []\n    };\n    /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */ this._uMP = new Set();\n    /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */ this._befC = [];\n    /**\n   * _preparePromise\n   */ this._prepP = null;\n    _prepareChannel(this);\n};\n// STATICS\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */ BroadcastChannel$1._pubkey = true;\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */ let ENFORCED_OPTIONS;\nfunction enforceOptions(options) {\n    ENFORCED_OPTIONS = options;\n}\n// PROTOTYPE\nBroadcastChannel$1.prototype = {\n    postMessage (msg) {\n        if (this.closed) {\n            throw new Error(\"BroadcastChannel.postMessage(): \" + \"Cannot post message after channel has closed \" + /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */ JSON.stringify(msg));\n        }\n        return _post(this, \"message\", msg);\n    },\n    postInternal (msg) {\n        return _post(this, \"internal\", msg);\n    },\n    set onmessage (fn){\n        const time = this.method.microSeconds();\n        const listenObj = {\n            time,\n            fn\n        };\n        _removeListenerObject(this, \"message\", this._onML);\n        if (fn && typeof fn === \"function\") {\n            this._onML = listenObj;\n            _addListenerObject(this, \"message\", listenObj);\n        } else {\n            this._onML = null;\n        }\n    },\n    addEventListener (type, fn1) {\n        const time = this.method.microSeconds();\n        const listenObj = {\n            time,\n            fn: fn1\n        };\n        _addListenerObject(this, type, listenObj);\n    },\n    removeEventListener (type, fn1) {\n        const obj = this._addEL[type].find((obj)=>obj.fn === fn1);\n        _removeListenerObject(this, type, obj);\n    },\n    close () {\n        if (this.closed) {\n            return;\n        }\n        OPEN_BROADCAST_CHANNELS.delete(this);\n        this.closed = true;\n        const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n        this._onML = null;\n        this._addEL.message = [];\n        return awaitPrepare// wait until all current sending are processed\n        .then(()=>Promise.all(Array.from(this._uMP)))// run before-close hooks\n        .then(()=>Promise.all(this._befC.map((fn1)=>fn1())))// close the channel\n        .then(()=>this.method.close(this._state));\n    },\n    get type () {\n        return this.method.type;\n    },\n    get isClosed () {\n        return this.closed;\n    }\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */ function _post(broadcastChannel, type, msg) {\n    const time = broadcastChannel.method.microSeconds();\n    const msgObj = {\n        time,\n        type,\n        data: msg\n    };\n    const awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n    return awaitPrepare.then(()=>{\n        const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n        // add/remove to unsend messages list\n        broadcastChannel._uMP.add(sendPromise);\n        sendPromise.catch().then(()=>broadcastChannel._uMP.delete(sendPromise));\n        return sendPromise;\n    });\n}\nfunction _prepareChannel(channel) {\n    const maybePromise = channel.method.create(channel.name, channel.options);\n    if (isPromise(maybePromise)) {\n        channel._prepP = maybePromise;\n        maybePromise.then((s)=>{\n            // used in tests to simulate slow runtime\n            /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/ channel._state = s;\n        });\n    } else {\n        channel._state = maybePromise;\n    }\n}\nfunction _hasMessageListeners(channel) {\n    if (channel._addEL.message.length > 0) return true;\n    if (channel._addEL.internal.length > 0) return true;\n    return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n    channel._addEL[type].push(obj);\n    _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n    channel._addEL[type] = channel._addEL[type].filter((o)=>o !== obj);\n    _stopListening(channel);\n}\nfunction _startListening(channel) {\n    if (!channel._iL && _hasMessageListeners(channel)) {\n        // someone is listening, start subscribing\n        const listenerFn = (msgObj)=>{\n            channel._addEL[msgObj.type].forEach((listenerObject)=>{\n                /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */ // const hundredMsInMicro = 100 * 1000;\n                // const minMessageTime = listenerObject.time - hundredMsInMicro;\n                if (msgObj.time >= listenerObject.time) {\n                    listenerObject.fn(msgObj.data);\n                } else if (channel.method.type === \"server\") {\n                    // server msg might lag based on connection.\n                    listenerObject.fn(msgObj.data);\n                }\n            });\n        };\n        const time = channel.method.microSeconds();\n        if (channel._prepP) {\n            channel._prepP.then(()=>{\n                channel._iL = true;\n                channel.method.onMessage(channel._state, listenerFn, time);\n            });\n        } else {\n            channel._iL = true;\n            channel.method.onMessage(channel._state, listenerFn, time);\n        }\n    }\n}\nfunction _stopListening(channel) {\n    if (channel._iL && !_hasMessageListeners(channel)) {\n        // noone is listening, stop subscribing\n        channel._iL = false;\n        const time = channel.method.microSeconds();\n        channel.method.onMessage(channel._state, null, time);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2Jyb2FkY2FzdENoYW5uZWwuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ2E7QUFDUDtBQUNnQjtBQUM0QjtBQUVsRiwrQkFBK0I7QUFFL0I7O0NBRUMsR0FDRCxTQUFTUSxVQUFVQyxHQUFHO0lBQ3BCLElBQUlBLE9BQU8sT0FBT0EsSUFBSUMsSUFBSSxLQUFLLFlBQVk7UUFDekMsT0FBTztJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUNBQyxRQUFRQyxPQUFPLENBQUM7QUFDaEJELFFBQVFDLE9BQU8sQ0FBQztBQUNoQixNQUFNQyx3QkFBd0JGLFFBQVFDLE9BQU87QUFDN0MsU0FBU0UsTUFBTUMsSUFBSSxFQUFFQyxXQUFXO0lBQzlCLElBQUksQ0FBQ0QsTUFBTUEsT0FBTztJQUNsQixPQUFPLElBQUlKLFFBQVFNLENBQUFBLE1BQU9DLFdBQVcsSUFBTUQsSUFBSUQsY0FBY0Q7QUFDL0Q7QUFDQSxTQUFTSSxVQUFVQyxHQUFHLEVBQUVDLEdBQUc7SUFDekIsT0FBT0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQU1ILENBQUFBLE1BQU1ELE1BQU0sS0FBS0E7QUFDdEQ7QUFFQTs7Q0FFQyxHQUNELFNBQVNLO0lBQ1AsT0FBT0gsS0FBS0UsTUFBTSxHQUFHRSxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDO0FBQzlDO0FBQ0EsSUFBSUMsU0FBUztBQUViOzs7Ozs7Q0FNQyxHQUNELFNBQVNDO0lBQ1AsSUFBSUMsTUFBTUMsS0FBS0MsR0FBRyxLQUFLLE1BQU0sK0JBQStCO0lBQzVELElBQUlGLE9BQU9GLFFBQVE7UUFDakJFLE1BQU1GLFNBQVM7SUFDakI7SUFDQUEsU0FBU0U7SUFDVCxPQUFPQTtBQUNUO0FBRUEsa0ZBQWtGO0FBQ2xGLGlEQUFpRDtBQUNqRCw4RUFBOEU7QUFDOUUsbUZBQW1GO0FBQ25G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Ozs7Ozs7OztTQVFDLEdBQ0QsdUNBQXVDO2dCQUN2QyxpRUFBaUU7Z0JBRWpFLElBQUl0SixPQUFPckosSUFBSSxJQUFJMlMsZUFBZTNTLElBQUksRUFBRTtvQkFDdEMyUyxlQUFlalEsRUFBRSxDQUFDMkcsT0FBT3JILElBQUk7Z0JBQy9CLE9BQU8sSUFBSWlPLFFBQVF2QyxNQUFNLENBQUN2SyxJQUFJLEtBQUssVUFBVTtvQkFDM0MsNENBQTRDO29CQUM1Q3dQLGVBQWVqUSxFQUFFLENBQUMyRyxPQUFPckgsSUFBSTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsTUFBTWhDLE9BQU9pUSxRQUFRdkMsTUFBTSxDQUFDckssWUFBWTtRQUN4QyxJQUFJNE0sUUFBUXFCLE1BQU0sRUFBRTtZQUNsQnJCLFFBQVFxQixNQUFNLENBQUMzUixJQUFJLENBQUM7Z0JBQ2xCc1EsUUFBUWMsR0FBRyxHQUFHO2dCQUNkZCxRQUFRdkMsTUFBTSxDQUFDekssU0FBUyxDQUFDZ04sUUFBUStCLE1BQU0sRUFBRVUsWUFBWTFTO1lBQ3ZEO1FBQ0YsT0FBTztZQUNMaVEsUUFBUWMsR0FBRyxHQUFHO1lBQ2RkLFFBQVF2QyxNQUFNLENBQUN6SyxTQUFTLENBQUNnTixRQUFRK0IsTUFBTSxFQUFFVSxZQUFZMVM7UUFDdkQ7SUFDRjtBQUNGO0FBQ0EsU0FBU3lTLGVBQWV4QyxPQUFPO0lBQzdCLElBQUlBLFFBQVFjLEdBQUcsSUFBSSxDQUFDdUIscUJBQXFCckMsVUFBVTtRQUNqRCx1Q0FBdUM7UUFDdkNBLFFBQVFjLEdBQUcsR0FBRztRQUNkLE1BQU0vUSxPQUFPaVEsUUFBUXZDLE1BQU0sQ0FBQ3JLLFlBQVk7UUFDeEM0TSxRQUFRdkMsTUFBTSxDQUFDekssU0FBUyxDQUFDZ04sUUFBUStCLE1BQU0sRUFBRSxNQUFNaFM7SUFDakQ7QUFDRjtBQUVrTiIsInNvdXJjZXMiOlsid2VicGFjazovL3NvbHp6dC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvYnJvYWRjYXN0Q2hhbm5lbC5lc20uanM/OTczMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nbGV2ZWwgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgT2JsaXZpb3VzU2V0IH0gZnJvbSAnb2JsaXZpb3VzLXNldCc7XG5pbXBvcnQgeyBpbyB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuaW1wb3J0IHsgZ2V0UHVibGljLCBzaWduIH0gZnJvbSAnQHRvcnVzbGFicy9lY2NyeXB0byc7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIGVuY3J5cHREYXRhLCBkZWNyeXB0RGF0YSB9IGZyb20gJ0B0b3J1c2xhYnMvbWV0YWRhdGEtaGVscGVycyc7XG5cbi8vIGltcG9ydCBCb3dzZXIgZnJvbSAnYm93c2VyJztcblxuLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICBpZiAob2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcblByb21pc2UucmVzb2x2ZSh0cnVlKTtcbmNvbnN0IFBST01JU0VfUkVTT0xWRURfVk9JRCA9IFByb21pc2UucmVzb2x2ZSgpO1xuZnVuY3Rpb24gc2xlZXAodGltZSwgcmVzb2x2ZVdpdGgpIHtcbiAgaWYgKCF0aW1lKSB0aW1lID0gMDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KCgpID0+IHJlcyhyZXNvbHZlV2l0aCksIHRpbWUpKTtcbn1cbmZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODA4NDI0OFxuICovXG5mdW5jdGlvbiByYW5kb21Ub2tlbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbn1cbmxldCBsYXN0TXMgPSAwO1xuXG4vKipcbiAqIHJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWNyby1zZWNvbmRzLFxuICogV0FSTklORzogVGhpcyBpcyBhIHBzZXVkby1mdW5jdGlvblxuICogUGVyZm9ybWFuY2Uubm93IGlzIG5vdCByZWxpYWJsZSBpbiB3ZWJ3b3JrZXJzLCBzbyB3ZSBqdXN0IG1ha2Ugc3VyZSB0byBuZXZlciByZXR1cm4gdGhlIHNhbWUgdGltZS5cbiAqIFRoaXMgaXMgZW5vdWdoIGluIGJyb3dzZXJzLCBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBiZSB1c2VkIGluIG5vZGVqcy5cbiAqIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBoYWNrIGlzIHRvIGVuc3VyZSB0aGF0IEJyb2FkY2FzdENoYW5uZWwgYmVoYXZlcyBlcXVhbCB0byBwcm9kdWN0aW9uIHdoZW4gaXQgaXMgdXNlZCBpbiBmYXN0LXJ1bm5pbmcgdW5pdCB0ZXN0cy5cbiAqL1xuZnVuY3Rpb24gbWljcm9TZWNvbmRzJDUoKSB7XG4gIGxldCByZXQgPSBEYXRlLm5vdygpICogMTAwMDsgLy8gbWlsbGlzZWNvbmRzIHRvIG1pY3Jvc2Vjb25kc1xuICBpZiAocmV0IDw9IGxhc3RNcykge1xuICAgIHJldCA9IGxhc3RNcyArIDE7XG4gIH1cbiAgbGFzdE1zID0gcmV0O1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyB0aGUgcHJvYmxlbSBpcyBvbmx5IGluIGlmcmFtZXMuIHdlIHNob3VsZCBkZWZhdWx0IHRvIHNlcnZlciBpbiBjYXNlIG9mIGlmcmFtZXMuXG4vLyBzdG9yYWdlIHNjb3BpbmcgaXMgcHJlc2VudCBpbiBhbGwgYnJvd3NlcnMgbm93XG4vLyBTYWZhcmkgYW5kIG90aGVyIGJyb3dzZXJzIHN1cHBvcnQgbmF0aXZlIEJyb2FkY2FzdCBjaGFubmVsIG5vdy4gSXQncyBpbiBMUy5cbi8vIHRlc3QgaGVyZTogaHR0cHM6Ly9wdWJrZXkuZ2l0aHViLmlvL2Jyb2FkY2FzdC1jaGFubmVsL2UyZS5odG1sP21ldGhvZFR5cGU9bmF0aXZlXG4vLyBodHRwczovL2Nhbml1c2UuY29tL2Jyb2FkY2FzdGNoYW5uZWxcbi8vIGV4cG9ydCBmdW5jdGlvbiBhcmUzUENTdXBwb3J0ZWQoKSB7XG4vLyAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4vLyAgICAgY29uc3QgYnJvd3NlckluZm8gPSBCb3dzZXIucGFyc2UobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyAgICAgbG9nLmluZm8oSlNPTi5zdHJpbmdpZnkoYnJvd3NlckluZm8pLCAnY3VycmVudCBicm93c2VyIGluZm8nKTtcblxuLy8gICAgIGxldCB0aGlyZFBhcnR5Q29va2llU3VwcG9ydCA9IHRydWU7XG4vLyAgICAgLy8gYnJhdmVcbi8vICAgICBpZiAobmF2aWdhdG9yLmJyYXZlKSB7XG4vLyAgICAgICAgIHRoaXJkUGFydHlDb29raWVTdXBwb3J0ID0gZmFsc2U7XG4vLyAgICAgfVxuLy8gICAgIC8vIEFsbCB3ZWJraXQgJiBnZWNrbyBlbmdpbmUgaW5zdGFuY2VzIHVzZSBpdHAgKGludGVsbGlnZW50IHRyYWNraW5nIHByZXZlbnRpb24gLVxuLy8gICAgIC8vIGh0dHBzOi8vd2Via2l0Lm9yZy90cmFja2luZy1wcmV2ZW50aW9uLyNpbnRlbGxpZ2VudC10cmFja2luZy1wcmV2ZW50aW9uLWl0cClcbi8vICAgICBpZiAoYnJvd3NlckluZm8uZW5naW5lLm5hbWUgPT09IEJvd3Nlci5FTkdJTkVfTUFQLldlYktpdCB8fCBicm93c2VySW5mby5lbmdpbmUubmFtZSA9PT0gQm93c2VyLkVOR0lORV9NQVAuR2Vja28pIHtcbi8vICAgICAgICAgdGhpcmRQYXJ0eUNvb2tpZVN1cHBvcnQgPSBmYWxzZTtcbi8vICAgICB9XG5cbi8vICAgICByZXR1cm4gdGhpcmRQYXJ0eUNvb2tpZVN1cHBvcnQ7XG4vLyB9XG5cbmNvbnN0IGxvZyA9IGxvZ2xldmVsLmdldExvZ2dlcignYnJvYWRjYXN0LWNoYW5uZWwnKTtcbmxvZy5zZXRMZXZlbCgnZXJyb3InKTtcblxuY29uc3QgbWljcm9TZWNvbmRzJDQgPSBtaWNyb1NlY29uZHMkNTtcbmNvbnN0IHR5cGUkNCA9ICduYXRpdmUnO1xuZnVuY3Rpb24gY3JlYXRlJDQoY2hhbm5lbE5hbWUpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgdGltZTogbWljcm9TZWNvbmRzJDUoKSxcbiAgICBtZXNzYWdlc0NhbGxiYWNrOiBudWxsLFxuICAgIGJjOiBuZXcgQnJvYWRjYXN0Q2hhbm5lbChjaGFubmVsTmFtZSksXG4gICAgc3ViRm5zOiBbXSAvLyBzdWJzY3JpYmVyRnVuY3Rpb25zXG4gIH07XG4gIHN0YXRlLmJjLm9ubWVzc2FnZSA9IG1zZyA9PiB7XG4gICAgaWYgKHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHtcbiAgICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnLmRhdGEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY2xvc2UkNChjaGFubmVsU3RhdGUpIHtcbiAgY2hhbm5lbFN0YXRlLmJjLmNsb3NlKCk7XG4gIGNoYW5uZWxTdGF0ZS5zdWJGbnMgPSBbXTtcbn1cbmZ1bmN0aW9uIHBvc3RNZXNzYWdlJDQoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICB0cnkge1xuICAgIGNoYW5uZWxTdGF0ZS5iYy5wb3N0TWVzc2FnZShtZXNzYWdlSnNvbiwgZmFsc2UpO1xuICAgIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICB9XG59XG5mdW5jdGlvbiBvbk1lc3NhZ2UkNChjaGFubmVsU3RhdGUsIGZuKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG59XG5mdW5jdGlvbiBjYW5CZVVzZWQkNCgpIHtcbiAgLyoqXG4gICAqIGluIHRoZSBlbGVjdHJvbi1yZW5kZXJlciwgaXNOb2RlIHdpbGwgYmUgdHJ1ZSBldmVuIGlmIHdlIGFyZSBpbiBicm93c2VyLWNvbnRleHRcbiAgICogc28gd2UgYWxzbyBjaGVjayBpZiB3aW5kb3cgaXMgdW5kZWZpbmVkXG4gICAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKEJyb2FkY2FzdENoYW5uZWwuX3B1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm9hZGNhc3RDaGFubmVsOiBEbyBub3Qgb3ZlcndyaXRlIHdpbmRvdy5Ccm9hZGNhc3RDaGFubmVsIHdpdGggdGhpcyBtb2R1bGUsIHRoaXMgaXMgbm90IGEgcG9seWZpbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lJDQoKSB7XG4gIHJldHVybiAxNTA7XG59XG52YXIgTmF0aXZlTWV0aG9kID0ge1xuICBjcmVhdGU6IGNyZWF0ZSQ0LFxuICBjbG9zZTogY2xvc2UkNCxcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UkNCxcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlJDQsXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkJDQsXG4gIHR5cGU6IHR5cGUkNCxcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSQ0LFxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kcyQ0XG59O1xuXG5mdW5jdGlvbiBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cygpIHtcbiAgbGV0IG9yaWdpbmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGNvbnN0IG9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsT3B0aW9ucykpO1xuXG4gIC8vIG1haW5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLndlYldvcmtlclN1cHBvcnQgPT09ICd1bmRlZmluZWQnKSBvcHRpb25zLndlYldvcmtlclN1cHBvcnQgPSB0cnVlO1xuXG4gIC8vIGluZGV4ZWQtZGJcbiAgaWYgKCFvcHRpb25zLmlkYikgb3B0aW9ucy5pZGIgPSB7fTtcbiAgLy8gIGFmdGVyIHRoaXMgdGltZSB0aGUgbWVzc2FnZXMgZ2V0IGRlbGV0ZWRcbiAgaWYgKCFvcHRpb25zLmlkYi50dGwpIG9wdGlvbnMuaWRiLnR0bCA9IDEwMDAgKiA0NTtcbiAgaWYgKCFvcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsKSBvcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsID0gMTUwO1xuICAvLyAgaGFuZGxlcyBhYnJ1cHQgZGIgb25jbG9zZSBldmVudHMuXG4gIGlmIChvcmlnaW5hbE9wdGlvbnMuaWRiICYmIHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuaWRiLm9uY2xvc2UgPT09ICdmdW5jdGlvbicpIG9wdGlvbnMuaWRiLm9uY2xvc2UgPSBvcmlnaW5hbE9wdGlvbnMuaWRiLm9uY2xvc2U7XG5cbiAgLy8gbG9jYWxzdG9yYWdlXG4gIGlmICghb3B0aW9ucy5sb2NhbHN0b3JhZ2UpIG9wdGlvbnMubG9jYWxzdG9yYWdlID0ge307XG4gIGlmICghb3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCkgb3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCA9IDEwMDAgKiA2MDtcblxuICAvLyBzZXJ2ZXJcbiAgaWYgKCFvcHRpb25zLnNlcnZlcikgb3B0aW9ucy5zZXJ2ZXIgPSB7fTtcbiAgaWYgKCFvcHRpb25zLnNlcnZlci51cmwpIG9wdGlvbnMuc2VydmVyLnVybCA9ICdodHRwczovL3Nlc3Npb24ud2ViM2F1dGguaW8nO1xuICBpZiAoIW9wdGlvbnMuc2VydmVyLnJlbW92ZVRpbWVvdXQpIG9wdGlvbnMuc2VydmVyLnJlbW92ZVRpbWVvdXQgPSAxMDAwICogNjAgKiA1OyAvLyA1IG1pbnV0ZXNcblxuICAvLyBjdXN0b20gbWV0aG9kc1xuICBpZiAob3JpZ2luYWxPcHRpb25zLm1ldGhvZHMpIG9wdGlvbnMubWV0aG9kcyA9IG9yaWdpbmFsT3B0aW9ucy5tZXRob2RzO1xuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiB0aGlzIG1ldGhvZCB1c2VzIGluZGV4ZWRkYiB0byBzdG9yZSB0aGUgbWVzc2FnZXNcbiAqIFRoZXJlIGlzIGN1cnJlbnRseSBubyBvYnNlcnZlckFQSSBmb3IgaWRiXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vdzNjL0luZGV4ZWREQi9pc3N1ZXMvNTFcbiAqXG4gKiBXaGVuIHdvcmtpbmcgb24gdGhpcywgZW5zdXJlIHRvIHVzZSB0aGVzZSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogQGxpbmsgaHR0cHM6Ly9yeGRiLmluZm8vc2xvdy1pbmRleGVkZGIuaHRtbFxuICovXG5cbmNvbnN0IG1pY3JvU2Vjb25kcyQzID0gbWljcm9TZWNvbmRzJDU7XG5jb25zdCBEQl9QUkVGSVggPSAncHVia2V5LmJyb2FkY2FzdC1jaGFubmVsLTAtJztcbmNvbnN0IE9CSkVDVF9TVE9SRV9JRCA9ICdtZXNzYWdlcyc7XG5cbi8qKlxuICogVXNlIHJlbGF4ZWQgZHVyYWJpbGl0eSBmb3IgZmFzdGVyIHBlcmZvcm1hbmNlIG9uIGFsbCB0cmFuc2FjdGlvbnMuXG4gKiBAbGluayBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIxLzA4LzIyL3NwZWVkaW5nLXVwLWluZGV4ZWRkYi1yZWFkcy1hbmQtd3JpdGVzL1xuICovXG5jb25zdCBUUkFOU0FDVElPTl9TRVRUSU5HUyA9IHtcbiAgZHVyYWJpbGl0eTogJ3JlbGF4ZWQnXG59O1xuY29uc3QgdHlwZSQzID0gJ2lkYic7XG5mdW5jdGlvbiBnZXRJZGIoKSB7XG4gIGlmICh0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4ZWREQjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubW96SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy5tb3pJbmRleGVkREI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cud2Via2l0SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy53ZWJraXRJbmRleGVkREI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubXNJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93Lm1zSW5kZXhlZERCO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJZiBwb3NzaWJsZSwgd2Ugc2hvdWxkIGV4cGxpY2l0bHkgY29tbWl0IEluZGV4ZWREQiB0cmFuc2FjdGlvbnNcbiAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKiBAbGluayBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIxLzA4LzIyL3NwZWVkaW5nLXVwLWluZGV4ZWRkYi1yZWFkcy1hbmQtd3JpdGVzL1xuICovXG5mdW5jdGlvbiBjb21taXRJbmRleGVkREJUcmFuc2FjdGlvbih0eCkge1xuICBpZiAodHguY29tbWl0KSB7XG4gICAgdHguY29tbWl0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFiYXNlKGNoYW5uZWxOYW1lKSB7XG4gIGNvbnN0IEluZGV4ZWREQiA9IGdldElkYigpO1xuXG4gIC8vIGNyZWF0ZSB0YWJsZVxuICBjb25zdCBkYk5hbWUgPSBEQl9QUkVGSVggKyBjaGFubmVsTmFtZTtcblxuICAvKipcbiAgICogQWxsIEluZGV4ZWREQiBkYXRhYmFzZXMgYXJlIG9wZW5lZCB3aXRob3V0IHZlcnNpb25cbiAgICogYmVjYXVzZSBpdCBpcyBhIGJpdCBmYXN0ZXIsIGVzcGVjaWFsbHkgb24gZmlyZWZveFxuICAgKiBAbGluayBodHRwOi8vbnBhcmFzaHVyYW0uY29tL0luZGV4ZWREQi9wZXJmLyNPcGVuJTIwRGF0YWJhc2UlMjB3aXRoJTIwdmVyc2lvblxuICAgKi9cbiAgY29uc3Qgb3BlblJlcXVlc3QgPSBJbmRleGVkREIub3BlbihkYk5hbWUpO1xuICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBldiA9PiB7XG4gICAgY29uc3QgZGIgPSBldi50YXJnZXQucmVzdWx0O1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCwge1xuICAgICAga2V5UGF0aDogJ2lkJyxcbiAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZGJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgb3BlblJlcXVlc3Qub25lcnJvciA9IGV2ID0+IHJlaihldik7XG4gICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgcmVzKG9wZW5SZXF1ZXN0LnJlc3VsdCk7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBkYlByb21pc2U7XG59XG5cbi8qKlxuICogd3JpdGVzIHRoZSBuZXcgbWVzc2FnZSB0byB0aGUgZGF0YWJhc2VcbiAqIHNvIG90aGVyIHJlYWRlcnMgY2FuIGZpbmQgaXRcbiAqL1xuZnVuY3Rpb24gd3JpdGVNZXNzYWdlKGRiLCByZWFkZXJVdWlkLCBtZXNzYWdlSnNvbikge1xuICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgY29uc3Qgd3JpdGVPYmplY3QgPSB7XG4gICAgdXVpZDogcmVhZGVyVXVpZCxcbiAgICB0aW1lLFxuICAgIGRhdGE6IG1lc3NhZ2VKc29uXG4gIH07XG4gIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oW09CSkVDVF9TVE9SRV9JRF0sICdyZWFkd3JpdGUnLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICB0eC5vbmNvbXBsZXRlID0gKCkgPT4gcmVzKCk7XG4gICAgdHgub25lcnJvciA9IGV2ID0+IHJlaihldik7XG4gICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICAgIG9iamVjdFN0b3JlLmFkZCh3cml0ZU9iamVjdCk7XG4gICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFsbE1lc3NhZ2VzKGRiKSB7XG4gIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX0lELCAncmVhZG9ubHknLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgY29uc3QgcmV0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4ge1xuICAgIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSBldiA9PiB7XG4gICAgICBjb25zdCBjdXJzb3IgPSBldi50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICByZXQucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAvL2FsZXJ0KFwiTmFtZSBmb3IgU1NOIFwiICsgY3Vyc29yLmtleSArIFwiIGlzIFwiICsgY3Vyc29yLnZhbHVlLm5hbWUpO1xuICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmVzKHJldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlc0hpZ2hlclRoYW4oZGIsIGxhc3RDdXJzb3JJZCkge1xuICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9JRCwgJ3JlYWRvbmx5JywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gIGNvbnN0IHJldCA9IFtdO1xuICBsZXQga2V5UmFuZ2VWYWx1ZSA9IElEQktleVJhbmdlLmJvdW5kKGxhc3RDdXJzb3JJZCArIDEsIEluZmluaXR5KTtcblxuICAvKipcbiAgICogT3B0aW1pemF0aW9uIHNob3J0Y3V0LFxuICAgKiBpZiBnZXRBbGwoKSBjYW4gYmUgdXNlZCwgZG8gbm90IHVzZSBhIGN1cnNvci5cbiAgICogQGxpbmsgaHR0cHM6Ly9yeGRiLmluZm8vc2xvdy1pbmRleGVkZGIuaHRtbFxuICAgKi9cbiAgaWYgKG9iamVjdFN0b3JlLmdldEFsbCkge1xuICAgIGNvbnN0IGdldEFsbFJlcXVlc3QgPSBvYmplY3RTdG9yZS5nZXRBbGwoa2V5UmFuZ2VWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgZ2V0QWxsUmVxdWVzdC5vbmVycm9yID0gZXJyID0+IHJlaihlcnIpO1xuICAgICAgZ2V0QWxsUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXMoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb3BlbkN1cnNvcigpIHtcbiAgICAvLyBPY2Nhc2lvbmFsbHkgU2FmYXJpIHdpbGwgZmFpbCBvbiBJREJLZXlSYW5nZS5ib3VuZCwgdGhpc1xuICAgIC8vIGNhdGNoZXMgdGhhdCBlcnJvciwgaGF2aW5nIGl0IG9wZW4gdGhlIGN1cnNvciB0byB0aGUgZmlyc3RcbiAgICAvLyBpdGVtLiBXaGVuIGl0IGdldHMgZGF0YSBpdCB3aWxsIGFkdmFuY2UgdG8gdGhlIGRlc2lyZWQga2V5LlxuICAgIHRyeSB7XG4gICAgICBrZXlSYW5nZVZhbHVlID0gSURCS2V5UmFuZ2UuYm91bmQobGFzdEN1cnNvcklkICsgMSwgSW5maW5pdHkpO1xuICAgICAgcmV0dXJuIG9iamVjdFN0b3JlLm9wZW5DdXJzb3Ioa2V5UmFuZ2VWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGNvbnN0IG9wZW5DdXJzb3JSZXF1ZXN0ID0gb3BlbkN1cnNvcigpO1xuICAgIG9wZW5DdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSBlcnIgPT4gcmVqKGVycik7XG4gICAgb3BlbkN1cnNvclJlcXVlc3Qub25zdWNjZXNzID0gZXYgPT4ge1xuICAgICAgY29uc3QgY3Vyc29yID0gZXYudGFyZ2V0LnJlc3VsdDtcbiAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgaWYgKGN1cnNvci52YWx1ZS5pZCA8IGxhc3RDdXJzb3JJZCArIDEpIHtcbiAgICAgICAgICBjdXJzb3IuY29udGludWUobGFzdEN1cnNvcklkICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXMocmV0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU1lc3NhZ2VzQnlJZChkYiwgaWRzKSB7XG4gIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oW09CSkVDVF9TVE9SRV9JRF0sICdyZWFkd3JpdGUnLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGlkcy5tYXAoaWQgPT4ge1xuICAgIGNvbnN0IGRlbGV0ZVJlcXVlc3QgPSBvYmplY3RTdG9yZS5kZWxldGUoaWQpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4ge1xuICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXMoKTtcbiAgICB9KTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0T2xkTWVzc2FnZXMoZGIsIHR0bCkge1xuICBjb25zdCBvbGRlclRoZW4gPSBEYXRlLm5vdygpIC0gdHRsO1xuICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9JRCwgJ3JlYWRvbmx5JywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gIGNvbnN0IHJldCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzID0+IHtcbiAgICBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKCkub25zdWNjZXNzID0gZXYgPT4ge1xuICAgICAgY29uc3QgY3Vyc29yID0gZXYudGFyZ2V0LnJlc3VsdDtcbiAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgY29uc3QgbXNnT2JrID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICBpZiAobXNnT2JrLnRpbWUgPCBvbGRlclRoZW4pIHtcbiAgICAgICAgICByZXQucHVzaChtc2dPYmspO1xuICAgICAgICAgIC8vYWxlcnQoXCJOYW1lIGZvciBTU04gXCIgKyBjdXJzb3Iua2V5ICsgXCIgaXMgXCIgKyBjdXJzb3IudmFsdWUubmFtZSk7XG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gbW9yZSBvbGQgbWVzc2FnZXMsXG4gICAgICAgICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgIHJlcyhyZXQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzKHJldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhbk9sZE1lc3NhZ2VzKGRiLCB0dGwpIHtcbiAgcmV0dXJuIGdldE9sZE1lc3NhZ2VzKGRiLCB0dGwpLnRoZW4odG9vT2xkID0+IHtcbiAgICByZXR1cm4gcmVtb3ZlTWVzc2FnZXNCeUlkKGRiLCB0b29PbGQubWFwKG1zZyA9PiBtc2cuaWQpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGUkMyhjaGFubmVsTmFtZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gIHJldHVybiBjcmVhdGVEYXRhYmFzZShjaGFubmVsTmFtZSkudGhlbihkYiA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICBjbG9zZWQ6IGZhbHNlLFxuICAgICAgbGFzdEN1cnNvcklkOiAwLFxuICAgICAgY2hhbm5lbE5hbWUsXG4gICAgICBvcHRpb25zLFxuICAgICAgdXVpZDogcmFuZG9tVG9rZW4oKSxcbiAgICAgIC8qKlxuICAgICAgICogZW1pdHRlZE1lc3NhZ2VzSWRzXG4gICAgICAgKiBjb250YWlucyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gZW1pdHRlZCBiZWZvcmVcbiAgICAgICAqIEB0eXBlIHtPYmxpdmlvdXNTZXR9XG4gICAgICAgKi9cbiAgICAgIGVNSXM6IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5pZGIudHRsICogMiksXG4gICAgICAvLyBlbnN1cmVzIHdlIGRvIG5vdCByZWFkIG1lc3NhZ2VzIGluIHBhcnJhbGxlbFxuICAgICAgd3JpdGVCbG9ja1Byb21pc2U6IFBST01JU0VfUkVTT0xWRURfVk9JRCxcbiAgICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGwsXG4gICAgICByZWFkUXVldWVQcm9taXNlczogW10sXG4gICAgICBkYixcbiAgICAgIHRpbWU6IG1pY3JvU2Vjb25kcyQ1KClcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFicnVwdCBjbG9zZXMgdGhhdCBkbyBub3Qgb3JpZ2luYXRlIGZyb20gZGIuY2xvc2UoKS5cbiAgICAgKiBUaGlzIGNvdWxkIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgaXNcbiAgICAgKiByZW1vdmVkIG9yIGlmIHRoZSB1c2VyIGNsZWFycyB0aGUgZGF0YWJhc2UgaW4gdGhlIGJyb3dzZXInc1xuICAgICAqIGhpc3RvcnkgcHJlZmVyZW5jZXMuXG4gICAgICovXG4gICAgZGIub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0YXRlLmNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5pZGIub25jbG9zZSkgb3B0aW9ucy5pZGIub25jbG9zZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXJ2aWNlLXdvcmtlcnMgYXJlIHVzZWQsXG4gICAgICogd2UgaGF2ZSBubyAnc3RvcmFnZSctZXZlbnQgaWYgdGhleSBwb3N0IGEgbWVzc2FnZSxcbiAgICAgKiB0aGVyZWZvcmUgd2UgYWxzbyBoYXZlIHRvIHNldCBhbiBpbnRlcnZhbFxuICAgICAqL1xuICAgIF9yZWFkTG9vcChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9yZWFkTG9vcChzdGF0ZSkge1xuICBpZiAoc3RhdGUuY2xvc2VkKSByZXR1cm47XG4gIHJlYWROZXdNZXNzYWdlcyhzdGF0ZSkudGhlbigoKSA9PiBzbGVlcChzdGF0ZS5vcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsKSkudGhlbigoKSA9PiBfcmVhZExvb3Aoc3RhdGUpKTtcbn1cbmZ1bmN0aW9uIF9maWx0ZXJNZXNzYWdlKG1zZ09iaiwgc3RhdGUpIHtcbiAgaWYgKG1zZ09iai51dWlkID09PSBzdGF0ZS51dWlkKSByZXR1cm4gZmFsc2U7IC8vIHNlbmQgYnkgb3duXG4gIGlmIChzdGF0ZS5lTUlzLmhhcyhtc2dPYmouaWQpKSByZXR1cm4gZmFsc2U7IC8vIGFscmVhZHkgZW1pdHRlZFxuICBpZiAobXNnT2JqLmRhdGEudGltZSA8IHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lKSByZXR1cm4gZmFsc2U7IC8vIG9sZGVyIHRoZW4gb25NZXNzYWdlQ2FsbGJhY2tcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogcmVhZHMgYWxsIG5ldyBtZXNzYWdlcyBmcm9tIHRoZSBkYXRhYmFzZSBhbmQgZW1pdHMgdGhlbVxuICovXG5mdW5jdGlvbiByZWFkTmV3TWVzc2FnZXMoc3RhdGUpIHtcbiAgLy8gY2hhbm5lbCBhbHJlYWR5IGNsb3NlZFxuICBpZiAoc3RhdGUuY2xvc2VkKSByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuXG4gIC8vIGlmIG5vIG9uZSBpcyBsaXN0ZW5pbmcsIHdlIGRvIG5vdCBuZWVkIHRvIHNjYW4gZm9yIG5ldyBtZXNzYWdlc1xuICBpZiAoIXN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIHJldHVybiBnZXRNZXNzYWdlc0hpZ2hlclRoYW4oc3RhdGUuZGIsIHN0YXRlLmxhc3RDdXJzb3JJZCkudGhlbihuZXdlck1lc3NhZ2VzID0+IHtcbiAgICBjb25zdCB1c2VNZXNzYWdlcyA9IG5ld2VyTWVzc2FnZXNcbiAgICAvKipcbiAgICAgKiB0aGVyZSBpcyBhIGJ1ZyBpbiBpT1Mgd2hlcmUgdGhlIG1zZ09iaiBjYW4gYmUgdW5kZWZpbmVkIHNvbWUgdGltZXNcbiAgICAgKiBzbyB3ZSBmaWx0ZXIgdGhlbSBvdXRcbiAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vcHVia2V5L2Jyb2FkY2FzdC1jaGFubmVsL2lzc3Vlcy8xOVxuICAgICAqLy5maWx0ZXIobXNnT2JqID0+ICEhbXNnT2JqKS5tYXAobXNnT2JqID0+IHtcbiAgICAgIGlmIChtc2dPYmouaWQgPiBzdGF0ZS5sYXN0Q3Vyc29ySWQpIHtcbiAgICAgICAgc3RhdGUubGFzdEN1cnNvcklkID0gbXNnT2JqLmlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1zZ09iajtcbiAgICB9KS5maWx0ZXIobXNnT2JqID0+IF9maWx0ZXJNZXNzYWdlKG1zZ09iaiwgc3RhdGUpKS5zb3J0KChtc2dPYmpBLCBtc2dPYmpCKSA9PiBtc2dPYmpBLnRpbWUgLSBtc2dPYmpCLnRpbWUpOyAvLyBzb3J0IGJ5IHRpbWVcbiAgICB1c2VNZXNzYWdlcy5mb3JFYWNoKG1zZ09iaiA9PiB7XG4gICAgICBpZiAoc3RhdGUubWVzc2FnZXNDYWxsYmFjaykge1xuICAgICAgICBzdGF0ZS5lTUlzLmFkZChtc2dPYmouaWQpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKG1zZ09iai5kYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsb3NlJDMoY2hhbm5lbFN0YXRlKSB7XG4gIGNoYW5uZWxTdGF0ZS5jbG9zZWQgPSB0cnVlO1xuICBjaGFubmVsU3RhdGUuZGIuY2xvc2UoKTtcbn1cbmZ1bmN0aW9uIHBvc3RNZXNzYWdlJDMoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2UgPSBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2UudGhlbigoKSA9PiB3cml0ZU1lc3NhZ2UoY2hhbm5lbFN0YXRlLmRiLCBjaGFubmVsU3RhdGUudXVpZCwgbWVzc2FnZUpzb24pKS50aGVuKCgpID0+IHtcbiAgICBpZiAocmFuZG9tSW50KDAsIDEwKSA9PT0gMCkge1xuICAgICAgLyogYXdhaXQgKGRvIG5vdCBhd2FpdCkgKi9cbiAgICAgIGNsZWFuT2xkTWVzc2FnZXMoY2hhbm5lbFN0YXRlLmRiLCBjaGFubmVsU3RhdGUub3B0aW9ucy5pZGIudHRsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2hhbm5lbFN0YXRlLndyaXRlQmxvY2tQcm9taXNlO1xufVxuZnVuY3Rpb24gb25NZXNzYWdlJDMoY2hhbm5lbFN0YXRlLCBmbiwgdGltZSkge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFja1RpbWUgPSB0aW1lO1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xuICByZWFkTmV3TWVzc2FnZXMoY2hhbm5lbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNhbkJlVXNlZCQzKCkge1xuICBjb25zdCBpZGIgPSBnZXRJZGIoKTtcbiAgaWYgKCFpZGIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lJDMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5pZGIuZmFsbGJhY2tJbnRlcnZhbCAqIDI7XG59XG52YXIgSW5kZXhlRGJNZXRob2QgPSB7XG4gIGdldElkYixcbiAgY3JlYXRlRGF0YWJhc2UsXG4gIGNyZWF0ZTogY3JlYXRlJDMsXG4gIGNsb3NlOiBjbG9zZSQzLFxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSQzLFxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UkMyxcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQkMyxcbiAgdHlwZTogdHlwZSQzLFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lJDMsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzJDMsXG4gIHdyaXRlTWVzc2FnZSxcbiAgZ2V0QWxsTWVzc2FnZXMsXG4gIGNsZWFuT2xkTWVzc2FnZXMsXG4gIGdldE1lc3NhZ2VzSGlnaGVyVGhhbixcbiAgZ2V0T2xkTWVzc2FnZXNcbn07XG5cbi8qKlxuICogQSBsb2NhbFN0b3JhZ2Utb25seSBtZXRob2Qgd2hpY2ggdXNlcyBsb2NhbHN0b3JhZ2UgYW5kIGl0cyAnc3RvcmFnZSctZXZlbnRcbiAqIFRoaXMgZG9lcyBub3Qgd29yayBpbnNpZGUgb2Ygd2Vid29ya2VycyBiZWNhdXNlIHRoZXkgaGF2ZSBubyBhY2Nlc3MgdG8gbG9jYXN0b3JhZ2VcbiAqIFRoaXMgaXMgYmFzaWNhbGx5IGltcGxlbWVudGVkIHRvIHN1cHBvcnQgSUU5IG9yIHlvdXIgZ3JhbmRtb3RoZXJzIHRvYXN0ZXIuXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PW5hbWV2YWx1ZS1zdG9yYWdlXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PWluZGV4ZWRkYlxuICovXG5cbmNvbnN0IG1pY3JvU2Vjb25kcyQyID0gbWljcm9TZWNvbmRzJDU7XG5jb25zdCBLRVlfUFJFRklYJDEgPSAncHVia2V5LmJyb2FkY2FzdENoYW5uZWwtJztcbmNvbnN0IHR5cGUkMiA9ICdsb2NhbHN0b3JhZ2UnO1xuXG4vKipcbiAqIGNvcGllZCBmcm9tIGNyb3NzdGFiXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGVqYWNxdWVzL2Nyb3NzdGFiL2Jsb2IvbWFzdGVyL3NyYy9jcm9zc3RhYi5qcyNMMzJcbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlKCkge1xuICBsZXQgbG9jYWxTdG9yYWdlO1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgbG9jYWxTdG9yYWdlID0gd2luZG93WydpZTgtZXZlbnRsaXN0ZW5lci9zdG9yYWdlJ10gfHwgd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5ldyB2ZXJzaW9ucyBvZiBGaXJlZm94IHRocm93IGEgU2VjdXJpdHkgZXhjZXB0aW9uXG4gICAgLy8gaWYgY29va2llcyBhcmUgZGlzYWJsZWQuIFNlZVxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwMjgxNTNcbiAgfVxuICByZXR1cm4gbG9jYWxTdG9yYWdlO1xufVxuZnVuY3Rpb24gc3RvcmFnZUtleSQxKGNoYW5uZWxOYW1lKSB7XG4gIHJldHVybiBLRVlfUFJFRklYJDEgKyBjaGFubmVsTmFtZTtcbn1cblxuLyoqXG4gKiB3cml0ZXMgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBzdG9yYWdlXG4gKiBhbmQgZmlyZXMgdGhlIHN0b3JhZ2UtZXZlbnQgc28gb3RoZXIgcmVhZGVycyBjYW4gZmluZCBpdFxuICovXG5mdW5jdGlvbiBwb3N0TWVzc2FnZSQyKGNoYW5uZWxTdGF0ZSwgbWVzc2FnZUpzb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlcyA9PiB7XG4gICAgc2xlZXAoKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHN0b3JhZ2VLZXkkMShjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpO1xuICAgICAgY29uc3Qgd3JpdGVPYmogPSB7XG4gICAgICAgIHRva2VuOiByYW5kb21Ub2tlbigpLFxuICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICBkYXRhOiBtZXNzYWdlSnNvbixcbiAgICAgICAgdXVpZDogY2hhbm5lbFN0YXRlLnV1aWRcbiAgICAgIH07XG4gICAgICBjb25zdCB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHdyaXRlT2JqKTtcbiAgICAgIGdldExvY2FsU3RvcmFnZSgpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RvcmFnZUV2ZW50IGRvZXMgbm90IGZpcmUgdGhlICdzdG9yYWdlJyBldmVudFxuICAgICAgICogaW4gdGhlIHdpbmRvdyB0aGF0IGNoYW5nZXMgdGhlIHN0YXRlIG9mIHRoZSBsb2NhbCBzdG9yYWdlLlxuICAgICAgICogU28gd2UgZmlyZSBpdCBtYW51YWxseVxuICAgICAgICovXG4gICAgICBjb25zdCBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXYuaW5pdEV2ZW50KCdzdG9yYWdlJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBldi5rZXkgPSBrZXk7XG4gICAgICBldi5uZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgICAgcmVzKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkU3RvcmFnZUV2ZW50TGlzdGVuZXIoY2hhbm5lbE5hbWUsIGZuKSB7XG4gIGNvbnN0IGtleSA9IHN0b3JhZ2VLZXkkMShjaGFubmVsTmFtZSk7XG4gIGNvbnN0IGxpc3RlbmVyID0gZXYgPT4ge1xuICAgIGlmIChldi5rZXkgPT09IGtleSkge1xuICAgICAgZm4oSlNPTi5wYXJzZShldi5uZXdWYWx1ZSkpO1xuICAgIH1cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBsaXN0ZW5lcik7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0b3JhZ2VFdmVudExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgbGlzdGVuZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlJDIoY2hhbm5lbE5hbWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICBpZiAoIWNhbkJlVXNlZCQyKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb2FkY2FzdENoYW5uZWw6IGxvY2Fsc3RvcmFnZSBjYW5ub3QgYmUgdXNlZCcpO1xuICB9XG4gIGNvbnN0IHV1aWQgPSByYW5kb21Ub2tlbigpO1xuXG4gIC8qKlxuICAgKiBlTUlzXG4gICAqIGNvbnRhaW5zIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYmVlbiBlbWl0dGVkIGJlZm9yZVxuICAgKiBAdHlwZSB7T2JsaXZpb3VzU2V0fVxuICAgKi9cbiAgY29uc3QgZU1JcyA9IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCk7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGNoYW5uZWxOYW1lLFxuICAgIHV1aWQsXG4gICAgdGltZTogbWljcm9TZWNvbmRzJDUoKSxcbiAgICBlTUlzIC8vIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICB9O1xuICBzdGF0ZS5saXN0ZW5lciA9IGFkZFN0b3JhZ2VFdmVudExpc3RlbmVyKGNoYW5uZWxOYW1lLCBtc2dPYmogPT4ge1xuICAgIGlmICghc3RhdGUubWVzc2FnZXNDYWxsYmFjaykgcmV0dXJuOyAvLyBubyBsaXN0ZW5lclxuICAgIGlmIChtc2dPYmoudXVpZCA9PT0gdXVpZCkgcmV0dXJuOyAvLyBvd24gbWVzc2FnZVxuICAgIGlmICghbXNnT2JqLnRva2VuIHx8IGVNSXMuaGFzKG1zZ09iai50b2tlbikpIHJldHVybjsgLy8gYWxyZWFkeSBlbWl0dGVkXG4gICAgaWYgKG1zZ09iai5kYXRhLnRpbWUgJiYgbXNnT2JqLmRhdGEudGltZSA8IHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lKSByZXR1cm47IC8vIHRvbyBvbGRcblxuICAgIGVNSXMuYWRkKG1zZ09iai50b2tlbik7XG4gICAgc3RhdGUubWVzc2FnZXNDYWxsYmFjayhtc2dPYmouZGF0YSk7XG4gIH0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBjbG9zZSQyKGNoYW5uZWxTdGF0ZSkge1xuICByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsU3RhdGUubGlzdGVuZXIpO1xufVxuZnVuY3Rpb24gb25NZXNzYWdlJDIoY2hhbm5lbFN0YXRlLCBmbiwgdGltZSkge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFja1RpbWUgPSB0aW1lO1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZnVuY3Rpb24gY2FuQmVVc2VkJDIoKSB7XG4gIGNvbnN0IGxzID0gZ2V0TG9jYWxTdG9yYWdlKCk7XG4gIGlmICghbHMpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBrZXkgPSAnX19icm9hZGNhc3RjaGFubmVsX2NoZWNrJztcbiAgICBscy5zZXRJdGVtKGtleSwgJ3dvcmtzJyk7XG4gICAgbHMucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gU2FmYXJpIDEwIGluIHByaXZhdGUgbW9kZSB3aWxsIG5vdCBhbGxvdyB3cml0ZSBhY2Nlc3MgdG8gbG9jYWxcbiAgICAvLyBzdG9yYWdlIGFuZCBmYWlsIHdpdGggYSBRdW90YUV4Y2VlZGVkRXJyb3IuIFNlZVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkjUHJpdmF0ZV9Ccm93c2luZ19JbmNvZ25pdG9fbW9kZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lJDIoKSB7XG4gIGNvbnN0IGRlZmF1bHRUaW1lID0gMTIwO1xuICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIGlmICh1c2VyQWdlbnQuaW5jbHVkZXMoJ3NhZmFyaScpICYmICF1c2VyQWdlbnQuaW5jbHVkZXMoJ2Nocm9tZScpKSB7XG4gICAgLy8gc2FmYXJpIGlzIG11Y2ggc2xvd2VyIHNvIHRoaXMgdGltZSBpcyBoaWdoZXJcbiAgICByZXR1cm4gZGVmYXVsdFRpbWUgKiAyO1xuICB9XG4gIHJldHVybiBkZWZhdWx0VGltZTtcbn1cbnZhciBMb2NhbHN0b3JhZ2VNZXRob2QgPSB7XG4gIGdldExvY2FsU3RvcmFnZSxcbiAgY3JlYXRlOiBjcmVhdGUkMixcbiAgY2xvc2U6IGNsb3NlJDIsXG4gIG9uTWVzc2FnZTogb25NZXNzYWdlJDIsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSQyLFxuICBjYW5CZVVzZWQ6IGNhbkJlVXNlZCQyLFxuICB0eXBlOiB0eXBlJDIsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUkMixcbiAgbWljcm9TZWNvbmRzOiBtaWNyb1NlY29uZHMkMixcbiAgc3RvcmFnZUtleTogc3RvcmFnZUtleSQxLFxuICBhZGRTdG9yYWdlRXZlbnRMaXN0ZW5lcixcbiAgcmVtb3ZlU3RvcmFnZUV2ZW50TGlzdGVuZXJcbn07XG5cbi8qKlxuICogQSBsb2NhbFN0b3JhZ2Utb25seSBtZXRob2Qgd2hpY2ggdXNlcyBsb2NhbHN0b3JhZ2UgYW5kIGl0cyAnc3RvcmFnZSctZXZlbnRcbiAqIFRoaXMgZG9lcyBub3Qgd29yayBpbnNpZGUgb2Ygd2Vid29ya2VycyBiZWNhdXNlIHRoZXkgaGF2ZSBubyBhY2Nlc3MgdG8gbG9jYXN0b3JhZ2VcbiAqIFRoaXMgaXMgYmFzaWNhbGx5IGltcGxlbWVudGVkIHRvIHN1cHBvcnQgSUU5IG9yIHlvdXIgZ3JhbmRtb3RoZXJzIHRvYXN0ZXIuXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PW5hbWV2YWx1ZS1zdG9yYWdlXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PWluZGV4ZWRkYlxuICovXG5cbmNvbnN0IG1pY3JvU2Vjb25kcyQxID0gbWljcm9TZWNvbmRzJDU7XG5jb25zdCBLRVlfUFJFRklYID0gJ3B1YmtleS5icm9hZGNhc3RDaGFubmVsLSc7XG5jb25zdCB0eXBlJDEgPSAnc2VydmVyJztcbmxldCBTT0NLRVRfQ09OTl9JTlNUQU5DRSA9IG51bGw7XG4vLyB1c2VkIHRvIGRlY2lkZSB0byByZWNvbm5lY3Qgc29ja2V0IGUuZy4gd2hlbiBzb2NrZXQgY29ubmVjdGlvbiBpcyBkaXNjb25uZWN0ZWQgdW5leHBlY3RlZGx5XG5jb25zdCBydW5uaW5nQ2hhbm5lbHMgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBzdG9yYWdlS2V5KGNoYW5uZWxOYW1lKSB7XG4gIHJldHVybiBLRVlfUFJFRklYICsgY2hhbm5lbE5hbWU7XG59XG5cbi8qKlxuICogd3JpdGVzIHRoZSBuZXcgbWVzc2FnZSB0byB0aGUgc3RvcmFnZVxuICogYW5kIGZpcmVzIHRoZSBzdG9yYWdlLWV2ZW50IHNvIG90aGVyIHJlYWRlcnMgY2FuIGZpbmQgaXRcbiAqL1xuZnVuY3Rpb24gcG9zdE1lc3NhZ2UkMShjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBzbGVlcCgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gc3RvcmFnZUtleShjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpO1xuICAgICAgY29uc3QgY2hhbm5lbEVuY1ByaXZLZXkgPSBrZWNjYWsyNTYoQnVmZmVyLmZyb20oa2V5LCAndXRmOCcpKTtcbiAgICAgIGNvbnN0IGVuY0RhdGEgPSBhd2FpdCBlbmNyeXB0RGF0YShjaGFubmVsRW5jUHJpdktleS50b1N0cmluZygnaGV4JyksIHtcbiAgICAgICAgdG9rZW46IHJhbmRvbVRva2VuKCksXG4gICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgIGRhdGE6IG1lc3NhZ2VKc29uLFxuICAgICAgICB1dWlkOiBjaGFubmVsU3RhdGUudXVpZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICBzYW1lT3JpZ2luQ2hlY2s6IHRydWUsXG4gICAgICAgIHNhbWVJcENoZWNrOiB0cnVlLFxuICAgICAgICBrZXk6IGdldFB1YmxpYyhjaGFubmVsRW5jUHJpdktleSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBkYXRhOiBlbmNEYXRhLFxuICAgICAgICBzaWduYXR1cmU6IChhd2FpdCBzaWduKGNoYW5uZWxFbmNQcml2S2V5LCBrZWNjYWsyNTYoQnVmZmVyLmZyb20oZW5jRGF0YSwgJ3V0ZjgnKSkpKS50b1N0cmluZygnaGV4JylcbiAgICAgIH07XG4gICAgICBpZiAoY2hhbm5lbFN0YXRlLnRpbWVvdXQpIGJvZHkudGltZW91dCA9IGNoYW5uZWxTdGF0ZS50aW1lb3V0O1xuICAgICAgcmV0dXJuIGZldGNoKGNoYW5uZWxTdGF0ZS5zZXJ2ZXJVcmwgKyAnL2NoYW5uZWwvc2V0Jywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4ocmVzKS5jYXRjaChyZWopO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNvY2tldEluc3RhbmNlKHNlcnZlclVybCkge1xuICBpZiAoU09DS0VUX0NPTk5fSU5TVEFOQ0UpIHtcbiAgICByZXR1cm4gU09DS0VUX0NPTk5fSU5TVEFOQ0U7XG4gIH1cbiAgY29uc3QgU09DS0VUX0NPTk4gPSBpbyhzZXJ2ZXJVcmwsIHtcbiAgICB0cmFuc3BvcnRzOiBbJ3dlYnNvY2tldCcsICdwb2xsaW5nJ10sXG4gICAgLy8gdXNlIFdlYlNvY2tldCBmaXJzdCwgaWYgYXZhaWxhYmxlXG4gICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4OiAxMDAwMCxcbiAgICByZWNvbm5lY3Rpb25BdHRlbXB0czogMTBcbiAgfSk7XG4gIFNPQ0tFVF9DT05OLm9uKCdjb25uZWN0X2Vycm9yJywgZXJyID0+IHtcbiAgICAvLyByZXZlcnQgdG8gY2xhc3NpYyB1cGdyYWRlXG4gICAgU09DS0VUX0NPTk4uaW8ub3B0cy50cmFuc3BvcnRzID0gWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICAgIGxvZy5lcnJvcignY29ubmVjdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICBTT0NLRVRfQ09OTi5vbignY29ubmVjdCcsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBlbmdpbmVcbiAgICB9ID0gU09DS0VUX0NPTk4uaW87XG4gICAgbG9nLmRlYnVnKCdpbml0aWFsbHkgY29ubmVjdGVkIHRvJywgZW5naW5lLnRyYW5zcG9ydC5uYW1lKTsgLy8gaW4gbW9zdCBjYXNlcywgcHJpbnRzIFwicG9sbGluZ1wiXG4gICAgZW5naW5lLm9uY2UoJ3VwZ3JhZGUnLCAoKSA9PiB7XG4gICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNwb3J0IGlzIHVwZ3JhZGVkIChpLmUuIGZyb20gSFRUUCBsb25nLXBvbGxpbmcgdG8gV2ViU29ja2V0KVxuICAgICAgbG9nLmRlYnVnKCd1cGdyYWRlZCcsIGVuZ2luZS50cmFuc3BvcnQubmFtZSk7IC8vIGluIG1vc3QgY2FzZXMsIHByaW50cyBcIndlYnNvY2tldFwiXG4gICAgfSk7XG4gICAgZW5naW5lLm9uY2UoJ2Nsb3NlJywgcmVhc29uID0+IHtcbiAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gaXMgY2xvc2VkXG4gICAgICBsb2cuZGVidWcoJ2Nvbm5lY3Rpb24gY2xvc2VkJywgcmVhc29uKTtcbiAgICB9KTtcbiAgfSk7XG4gIFNPQ0tFVF9DT05OLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgbG9nLmVycm9yKCdzb2NrZXQgZXJyb3JlZCcsIGVycik7XG4gICAgU09DS0VUX0NPTk4uZGlzY29ubmVjdCgpO1xuICB9KTtcbiAgU09DS0VUX0NPTk5fSU5TVEFOQ0UgPSBTT0NLRVRfQ09OTjtcbiAgcmV0dXJuIFNPQ0tFVF9DT05OO1xufVxuZnVuY3Rpb24gc2V0dXBTb2NrZXRDb25uZWN0aW9uKHNlcnZlclVybCwgY2hhbm5lbFN0YXRlLCBmbikge1xuICBjb25zdCBzb2NrZXRDb25uID0gZ2V0U29ja2V0SW5zdGFuY2Uoc2VydmVyVXJsKTtcbiAgY29uc3Qga2V5ID0gc3RvcmFnZUtleShjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpO1xuICBjb25zdCBjaGFubmVsRW5jUHJpdktleSA9IGtlY2NhazI1NihCdWZmZXIuZnJvbShrZXksICd1dGY4JykpO1xuICBjb25zdCBjaGFubmVsUHViS2V5ID0gZ2V0UHVibGljKGNoYW5uZWxFbmNQcml2S2V5KS50b1N0cmluZygnaGV4Jyk7XG4gIGlmIChzb2NrZXRDb25uLmNvbm5lY3RlZCkge1xuICAgIHNvY2tldENvbm4uZW1pdCgnY2hlY2tfYXV0aF9zdGF0dXMnLCBjaGFubmVsUHViS2V5LCB7XG4gICAgICBzYW1lT3JpZ2luQ2hlY2s6IHRydWUsXG4gICAgICBzYW1lSXBDaGVjazogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNvY2tldENvbm4ub25jZSgnY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGxvZy5kZWJ1ZygnY29ubmVjdGVkIHdpdGggc29ja2V0Jyk7XG4gICAgICBzb2NrZXRDb25uLmVtaXQoJ2NoZWNrX2F1dGhfc3RhdHVzJywgY2hhbm5lbFB1YktleSwge1xuICAgICAgICBzYW1lT3JpZ2luQ2hlY2s6IHRydWUsXG4gICAgICAgIHNhbWVJcENoZWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCByZWNvbm5lY3QgPSAoKSA9PiB7XG4gICAgc29ja2V0Q29ubi5vbmNlKCdjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHJ1bm5pbmdDaGFubmVscy5oYXMoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKSkge1xuICAgICAgICBzb2NrZXRDb25uLmVtaXQoJ2NoZWNrX2F1dGhfc3RhdHVzJywgY2hhbm5lbFB1YktleSwge1xuICAgICAgICAgIHNhbWVPcmlnaW5DaGVjazogdHJ1ZSxcbiAgICAgICAgICBzYW1lSXBDaGVjazogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdmlzaWJpbGl0eUxpc3RlbmVyID0gKCkgPT4ge1xuICAgIC8vIGlmIGNoYW5uZWwgaXMgY2xvc2VkLCB0aGVuIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAgaWYgKCFzb2NrZXRDb25uIHx8ICFydW5uaW5nQ2hhbm5lbHMuaGFzKGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSkpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB2aXNpYmlsaXR5TGlzdGVuZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiBub3QgY29ubmVjdGVkLCB0aGVuIHdhaXQgZm9yIGNvbm5lY3Rpb24gYW5kIHBpbmcgc2VydmVyIGZvciBsYXRlc3QgbXNnLlxuICAgIGlmICghc29ja2V0Q29ubi5jb25uZWN0ZWQgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgIHJlY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbGlzdGVuZXIgPSBhc3luYyBldiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlY0RhdGEgPSBhd2FpdCBkZWNyeXB0RGF0YShjaGFubmVsRW5jUHJpdktleS50b1N0cmluZygnaGV4JyksIGV2KTtcbiAgICAgIGxvZy5pbmZvKGRlY0RhdGEpO1xuICAgICAgZm4oZGVjRGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuICBzb2NrZXRDb25uLm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgIGxvZy5kZWJ1Zygnc29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgIGlmIChydW5uaW5nQ2hhbm5lbHMuaGFzKGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSkpIHtcbiAgICAgIGxvZy5lcnJvcignc29ja2V0IGRpc2Nvbm5lY3RlZCB1bmV4cGVjdGVkbHksIHJlY29ubmVjdGluZyBzb2NrZXQnKTtcbiAgICAgIHJlY29ubmVjdCgpO1xuICAgIH1cbiAgfSk7XG4gIHNvY2tldENvbm4ub24oYCR7Y2hhbm5lbFB1YktleX1fc3VjY2Vzc2AsIGxpc3RlbmVyKTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB2aXNpYmlsaXR5TGlzdGVuZXIpO1xuICByZXR1cm4gc29ja2V0Q29ubjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZSQxKGNoYW5uZWxOYW1lLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgY29uc3QgdXVpZCA9IHJhbmRvbVRva2VuKCk7XG5cbiAgLyoqXG4gICAqIGVNSXNcbiAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAqIEB0eXBlIHtPYmxpdmlvdXNTZXR9XG4gICAqL1xuICBjb25zdCBlTUlzID0gbmV3IE9ibGl2aW91c1NldChvcHRpb25zLnNlcnZlci5yZW1vdmVUaW1lb3V0KTtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgY2hhbm5lbE5hbWUsXG4gICAgdXVpZCxcbiAgICBlTUlzLFxuICAgIC8vIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICAgIHNlcnZlclVybDogb3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgIHRpbWU6IG1pY3JvU2Vjb25kcyQ1KClcbiAgfTtcbiAgaWYgKG9wdGlvbnMuc2VydmVyLnRpbWVvdXQpIHN0YXRlLnRpbWVvdXQgPSBvcHRpb25zLnNlcnZlci50aW1lb3V0O1xuICBzZXR1cFNvY2tldENvbm5lY3Rpb24ob3B0aW9ucy5zZXJ2ZXIudXJsLCBzdGF0ZSwgbXNnT2JqID0+IHtcbiAgICBpZiAoIXN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHJldHVybjsgLy8gbm8gbGlzdGVuZXJcbiAgICBpZiAobXNnT2JqLnV1aWQgPT09IHN0YXRlLnV1aWQpIHJldHVybjsgLy8gb3duIG1lc3NhZ2VcbiAgICBpZiAoIW1zZ09iai50b2tlbiB8fCBzdGF0ZS5lTUlzLmhhcyhtc2dPYmoudG9rZW4pKSByZXR1cm47IC8vIGFscmVhZHkgZW1pdHRlZFxuICAgIC8vIGlmIChtc2dPYmouZGF0YS50aW1lICYmIG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuOyAvLyB0b28gb2xkXG5cbiAgICBzdGF0ZS5lTUlzLmFkZChtc2dPYmoudG9rZW4pO1xuICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICB9KTtcbiAgcnVubmluZ0NoYW5uZWxzLmFkZChjaGFubmVsTmFtZSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlJDEoY2hhbm5lbFN0YXRlKSB7XG4gIHJ1bm5pbmdDaGFubmVscy5kZWxldGUoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKTtcbiAgLy8gZ2l2ZSAyIHNlYyBmb3IgYWxsIG1zZ3Mgd2hpY2ggYXJlIGluIHRyYW5zaXQgdG8gYmUgY29uc3VtZWRcbiAgLy8gYnkgcmVjZWl2ZXIuXG4gIC8vIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgLy8gICAgIHJlbW92ZVN0b3JhZ2VFdmVudExpc3RlbmVyKGNoYW5uZWxTdGF0ZSk7XG4gIC8vICAgICBTT0NLRVRfQ09OTl9JTlNUQU5DRSA9IG51bGw7XG4gIC8vIH0sIDEwMDApO1xufVxuZnVuY3Rpb24gb25NZXNzYWdlJDEoY2hhbm5lbFN0YXRlLCBmbiwgdGltZSkge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFja1RpbWUgPSB0aW1lO1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZnVuY3Rpb24gY2FuQmVVc2VkJDEoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSQxKCkge1xuICBjb25zdCBkZWZhdWx0VGltZSA9IDUwMDtcbiAgLy8gVE9ETzogTWF5YmUgaW5jcmVhc2UgaXQgYmFzZWQgb24gb3BlcmF0aW9uXG4gIHJldHVybiBkZWZhdWx0VGltZTtcbn1cbnZhciBTZXJ2ZXJNZXRob2QgPSB7XG4gIGNyZWF0ZTogY3JlYXRlJDEsXG4gIGNsb3NlOiBjbG9zZSQxLFxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSQxLFxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UkMSxcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQkMSxcbiAgdHlwZTogdHlwZSQxLFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lJDEsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzJDFcbn07XG5cbmNvbnN0IG1pY3JvU2Vjb25kcyA9IG1pY3JvU2Vjb25kcyQ1O1xuY29uc3QgdHlwZSA9ICdzaW11bGF0ZSc7XG5jb25zdCBTSU1VTEFURV9DSEFOTkVMUyA9IG5ldyBTZXQoKTtcbmNvbnN0IFNJTVVMQVRFX0RFTEFZX1RJTUUgPSA1O1xuZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHRpbWU6IG1pY3JvU2Vjb25kcyQ1KCksXG4gICAgbmFtZTogY2hhbm5lbE5hbWUsXG4gICAgbWVzc2FnZXNDYWxsYmFjazogbnVsbFxuICB9O1xuICBTSU1VTEFURV9DSEFOTkVMUy5hZGQoc3RhdGUpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcbiAgU0lNVUxBVEVfQ0hBTk5FTFMuZGVsZXRlKGNoYW5uZWxTdGF0ZSk7XG59XG5mdW5jdGlvbiBwb3N0TWVzc2FnZShjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY29uc3QgY2hhbm5lbEFycmF5ID0gQXJyYXkuZnJvbShTSU1VTEFURV9DSEFOTkVMUyk7XG4gICAgY2hhbm5lbEFycmF5LmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgICBpZiAoY2hhbm5lbC5uYW1lID09PSBjaGFubmVsU3RhdGUubmFtZSAmJlxuICAgICAgLy8gaGFzIHNhbWUgbmFtZVxuICAgICAgY2hhbm5lbCAhPT0gY2hhbm5lbFN0YXRlICYmXG4gICAgICAvLyBub3Qgb3duIGNoYW5uZWxcbiAgICAgICEhY2hhbm5lbC5tZXNzYWdlc0NhbGxiYWNrICYmXG4gICAgICAvLyBoYXMgc3Vic2NyaWJlcnNcbiAgICAgIGNoYW5uZWwudGltZSA8IG1lc3NhZ2VKc29uLnRpbWUgLy8gY2hhbm5lbCBub3QgY3JlYXRlZCBhZnRlciBwb3N0TWVzc2FnZSgpIGNhbGxcbiAgICAgICkge1xuICAgICAgICBjaGFubmVsLm1lc3NhZ2VzQ2FsbGJhY2sobWVzc2FnZUpzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlcygpO1xuICB9LCBTSU1VTEFURV9ERUxBWV9USU1FKSk7XG59XG5mdW5jdGlvbiBvbk1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBmbikge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZnVuY3Rpb24gY2FuQmVVc2VkKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGF2ZXJhZ2VSZXNwb25zZVRpbWUoKSB7XG4gIHJldHVybiBTSU1VTEFURV9ERUxBWV9USU1FO1xufVxudmFyIFNpbXVsYXRlTWV0aG9kID0ge1xuICBjcmVhdGUsXG4gIGNsb3NlLFxuICBvbk1lc3NhZ2UsXG4gIHBvc3RNZXNzYWdlLFxuICBjYW5CZVVzZWQsXG4gIHR5cGUsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWUsXG4gIG1pY3JvU2Vjb25kc1xufTtcblxuLy8gb3JkZXIgaXMgaW1wb3J0YW50XG5jb25zdCBNRVRIT0RTID0gW05hdGl2ZU1ldGhvZCxcbi8vIGZhc3Rlc3RcbkluZGV4ZURiTWV0aG9kLCBMb2NhbHN0b3JhZ2VNZXRob2QsIFNlcnZlck1ldGhvZF07XG5mdW5jdGlvbiBjaG9vc2VNZXRob2Qob3B0aW9ucykge1xuICBsZXQgY2hvb3NlTWV0aG9kcyA9IFtdLmNvbmNhdChvcHRpb25zLm1ldGhvZHMsIE1FVEhPRFMpLmZpbHRlcihCb29sZWFuKTtcblxuICAvLyBkaXJlY3RseSBjaG9zZW5cbiAgaWYgKG9wdGlvbnMudHlwZSkge1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaW11bGF0ZScpIHtcbiAgICAgIC8vIG9ubHkgdXNlIHNpbXVsYXRlLW1ldGhvZCBpZiBkaXJlY3RseSBjaG9zZW5cbiAgICAgIHJldHVybiBTaW11bGF0ZU1ldGhvZDtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gY2hvb3NlTWV0aG9kcy5maW5kKG0gPT4gbS50eXBlID09PSBvcHRpb25zLnR5cGUpO1xuICAgIGlmICghcmV0KSB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZC10eXBlICcgKyBvcHRpb25zLnR5cGUgKyAnIG5vdCBmb3VuZCcpO2Vsc2UgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZiBubyB3ZWJ3b3JrZXIgc3VwcG9ydCBpcyBuZWVkZWQsXG4gICAqIHJlbW92ZSBpZGIgZnJvbSB0aGUgbGlzdCBzbyB0aGF0IGxvY2Fsc3RvcmFnZSBpcyBiZWVuIGNob3NlblxuICAgKi9cbiAgaWYgKCFvcHRpb25zLndlYldvcmtlclN1cHBvcnQpIHtcbiAgICBjaG9vc2VNZXRob2RzID0gY2hvb3NlTWV0aG9kcy5maWx0ZXIobSA9PiBtLnR5cGUgIT09ICdpZGInKTtcbiAgfVxuICBjb25zdCB1c2VNZXRob2QgPSBjaG9vc2VNZXRob2RzLmZpbmQobWV0aG9kID0+IG1ldGhvZC5jYW5CZVVzZWQob3B0aW9ucykpO1xuICBpZiAoIXVzZU1ldGhvZCkgdGhyb3cgbmV3IEVycm9yKGBObyB1c2VhYmxlIG1ldGhvZCBmb3VuZCBpbiAke0pTT04uc3RyaW5naWZ5KE1FVEhPRFMubWFwKG0gPT4gbS50eXBlKSl9YCk7ZWxzZSByZXR1cm4gdXNlTWV0aG9kO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGFsbCBvcGVuIGNoYW5uZWxzLFxuICogdXNlZCBpbiB0ZXN0cyB0byBlbnN1cmUgZXZlcnl0aGluZyBpcyBjbG9zZWQuXG4gKi9cbmNvbnN0IE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTID0gbmV3IFNldCgpO1xubGV0IGxhc3RJZCA9IDA7XG5jb25zdCBCcm9hZGNhc3RDaGFubmVsJDEgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAvLyBpZGVudGlmaWVyIG9mIHRoZSBjaGFubmVsIHRvIGRlYnVnIHN0dWZmXG4gIHRoaXMuaWQgPSBsYXN0SWQrKztcbiAgT1BFTl9CUk9BRENBU1RfQ0hBTk5FTFMuYWRkKHRoaXMpO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICBpZiAoRU5GT1JDRURfT1BUSU9OUykge1xuICAgIG9wdGlvbnMgPSBFTkZPUkNFRF9PUFRJT05TO1xuICB9XG4gIHRoaXMub3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICB0aGlzLm1ldGhvZCA9IGNob29zZU1ldGhvZCh0aGlzLm9wdGlvbnMpO1xuXG4gIC8vIGlzTGlzdGVuaW5nXG4gIHRoaXMuX2lMID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIF9vbk1lc3NhZ2VMaXN0ZW5lclxuICAgKiBzZXR0aW5nIG9ubWVzc2FnZSB0d2ljZSxcbiAgICogd2lsbCBvdmVyd3JpdGUgdGhlIGZpcnN0IGxpc3RlbmVyXG4gICAqL1xuICB0aGlzLl9vbk1MID0gbnVsbDtcblxuICAvKipcbiAgICogX2FkZEV2ZW50TGlzdGVuZXJzXG4gICAqL1xuICB0aGlzLl9hZGRFTCA9IHtcbiAgICBtZXNzYWdlOiBbXSxcbiAgICBpbnRlcm5hbDogW11cbiAgfTtcblxuICAvKipcbiAgICogVW5zZW5kIG1lc3NhZ2UgcHJvbWlzZXNcbiAgICogd2hlcmUgdGhlIHNlbmRpbmcgaXMgc3RpbGwgaW4gcHJvZ3Jlc3NcbiAgICogQHR5cGUge1NldDxQcm9taXNlPn1cbiAgICovXG4gIHRoaXMuX3VNUCA9IG5ldyBTZXQoKTtcblxuICAvKipcbiAgICogX2JlZm9yZUNsb3NlXG4gICAqIGFycmF5IG9mIHByb21pc2VzIHRoYXQgd2lsbCBiZSBhd2FpdGVkXG4gICAqIGJlZm9yZSB0aGUgY2hhbm5lbCBpcyBjbG9zZWRcbiAgICovXG4gIHRoaXMuX2JlZkMgPSBbXTtcblxuICAvKipcbiAgICogX3ByZXBhcmVQcm9taXNlXG4gICAqL1xuICB0aGlzLl9wcmVwUCA9IG51bGw7XG4gIF9wcmVwYXJlQ2hhbm5lbCh0aGlzKTtcbn07XG5cbi8vIFNUQVRJQ1NcblxuLyoqXG4gKiB1c2VkIHRvIGlkZW50aWZ5IGlmIHNvbWVvbmUgb3ZlcndyaXRlc1xuICogd2luZG93LkJyb2FkY2FzdENoYW5uZWwgd2l0aCB0aGlzXG4gKiBTZWUgbWV0aG9kcy9uYXRpdmUuanNcbiAqL1xuQnJvYWRjYXN0Q2hhbm5lbCQxLl9wdWJrZXkgPSB0cnVlO1xuXG4vKipcbiAqIGlmIHNldCwgdGhpcyBtZXRob2QgaXMgZW5mb3JjZWQsXG4gKiBubyBtYXRoZXIgd2hhdCB0aGUgb3B0aW9ucyBhcmVcbiAqL1xubGV0IEVORk9SQ0VEX09QVElPTlM7XG5mdW5jdGlvbiBlbmZvcmNlT3B0aW9ucyhvcHRpb25zKSB7XG4gIEVORk9SQ0VEX09QVElPTlMgPSBvcHRpb25zO1xufVxuXG4vLyBQUk9UT1RZUEVcbkJyb2FkY2FzdENoYW5uZWwkMS5wcm90b3R5cGUgPSB7XG4gIHBvc3RNZXNzYWdlKG1zZykge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKCk6ICcgKyAnQ2Fubm90IHBvc3QgbWVzc2FnZSBhZnRlciBjaGFubmVsIGhhcyBjbG9zZWQgJyArXG4gICAgICAvKipcbiAgICAgICAqIEluIHRoZSBwYXN0IHdoZW4gdGhpcyBlcnJvciBhcHBlYXJlZCwgaXQgd2FzIHJlYWx5IGhhcmQgdG8gZGVidWcuXG4gICAgICAgKiBTbyBub3cgd2UgbG9nIHRoZSBtc2cgdG9nZXRoZXIgd2l0aCB0aGUgZXJyb3Igc28gaXQgYXQgbGVhc3RcbiAgICAgICAqIGdpdmVzIHNvbWUgY2x1ZSBhYm91dCB3aGVyZSBpbiB5b3VyIGFwcGxpY2F0aW9uIHRoaXMgaGFwcGVucy5cbiAgICAgICAqL1xuICAgICAgSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgfVxuICAgIHJldHVybiBfcG9zdCh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gIH0sXG4gIHBvc3RJbnRlcm5hbChtc2cpIHtcbiAgICByZXR1cm4gX3Bvc3QodGhpcywgJ2ludGVybmFsJywgbXNnKTtcbiAgfSxcbiAgc2V0IG9ubWVzc2FnZShmbikge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICBjb25zdCBsaXN0ZW5PYmogPSB7XG4gICAgICB0aW1lLFxuICAgICAgZm5cbiAgICB9O1xuICAgIF9yZW1vdmVMaXN0ZW5lck9iamVjdCh0aGlzLCAnbWVzc2FnZScsIHRoaXMuX29uTUwpO1xuICAgIGlmIChmbiAmJiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX29uTUwgPSBsaXN0ZW5PYmo7XG4gICAgICBfYWRkTGlzdGVuZXJPYmplY3QodGhpcywgJ21lc3NhZ2UnLCBsaXN0ZW5PYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vbk1MID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pIHtcbiAgICBjb25zdCB0aW1lID0gdGhpcy5tZXRob2QubWljcm9TZWNvbmRzKCk7XG4gICAgY29uc3QgbGlzdGVuT2JqID0ge1xuICAgICAgdGltZSxcbiAgICAgIGZuXG4gICAgfTtcbiAgICBfYWRkTGlzdGVuZXJPYmplY3QodGhpcywgdHlwZSwgbGlzdGVuT2JqKTtcbiAgfSxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbikge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuX2FkZEVMW3R5cGVdLmZpbmQob2JqID0+IG9iai5mbiA9PT0gZm4pO1xuICAgIF9yZW1vdmVMaXN0ZW5lck9iamVjdCh0aGlzLCB0eXBlLCBvYmopO1xuICB9LFxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT1BFTl9CUk9BRENBU1RfQ0hBTk5FTFMuZGVsZXRlKHRoaXMpO1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICBjb25zdCBhd2FpdFByZXBhcmUgPSB0aGlzLl9wcmVwUCA/IHRoaXMuX3ByZXBQIDogUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICAgIHRoaXMuX29uTUwgPSBudWxsO1xuICAgIHRoaXMuX2FkZEVMLm1lc3NhZ2UgPSBbXTtcbiAgICByZXR1cm4gYXdhaXRQcmVwYXJlXG4gICAgLy8gd2FpdCB1bnRpbCBhbGwgY3VycmVudCBzZW5kaW5nIGFyZSBwcm9jZXNzZWRcbiAgICAudGhlbigoKSA9PiBQcm9taXNlLmFsbChBcnJheS5mcm9tKHRoaXMuX3VNUCkpKVxuICAgIC8vIHJ1biBiZWZvcmUtY2xvc2UgaG9va3NcbiAgICAudGhlbigoKSA9PiBQcm9taXNlLmFsbCh0aGlzLl9iZWZDLm1hcChmbiA9PiBmbigpKSkpXG4gICAgLy8gY2xvc2UgdGhlIGNoYW5uZWxcbiAgICAudGhlbigoKSA9PiB0aGlzLm1ldGhvZC5jbG9zZSh0aGlzLl9zdGF0ZSkpO1xuICB9LFxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2QudHlwZTtcbiAgfSxcbiAgZ2V0IGlzQ2xvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLmNsb3NlZDtcbiAgfVxufTtcblxuLyoqXG4gKiBQb3N0IGEgbWVzc2FnZSBvdmVyIHRoZSBjaGFubmVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlZCB3aGVuIHRoZSBtZXNzYWdlIHNlbmRpbmcgaXMgZG9uZVxuICovXG5mdW5jdGlvbiBfcG9zdChicm9hZGNhc3RDaGFubmVsLCB0eXBlLCBtc2cpIHtcbiAgY29uc3QgdGltZSA9IGJyb2FkY2FzdENoYW5uZWwubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICBjb25zdCBtc2dPYmogPSB7XG4gICAgdGltZSxcbiAgICB0eXBlLFxuICAgIGRhdGE6IG1zZ1xuICB9O1xuICBjb25zdCBhd2FpdFByZXBhcmUgPSBicm9hZGNhc3RDaGFubmVsLl9wcmVwUCA/IGJyb2FkY2FzdENoYW5uZWwuX3ByZXBQIDogUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICByZXR1cm4gYXdhaXRQcmVwYXJlLnRoZW4oKCkgPT4ge1xuICAgIGNvbnN0IHNlbmRQcm9taXNlID0gYnJvYWRjYXN0Q2hhbm5lbC5tZXRob2QucG9zdE1lc3NhZ2UoYnJvYWRjYXN0Q2hhbm5lbC5fc3RhdGUsIG1zZ09iaik7XG5cbiAgICAvLyBhZGQvcmVtb3ZlIHRvIHVuc2VuZCBtZXNzYWdlcyBsaXN0XG4gICAgYnJvYWRjYXN0Q2hhbm5lbC5fdU1QLmFkZChzZW5kUHJvbWlzZSk7XG4gICAgc2VuZFByb21pc2UuY2F0Y2goKS50aGVuKCgpID0+IGJyb2FkY2FzdENoYW5uZWwuX3VNUC5kZWxldGUoc2VuZFByb21pc2UpKTtcbiAgICByZXR1cm4gc2VuZFByb21pc2U7XG4gIH0pO1xufVxuZnVuY3Rpb24gX3ByZXBhcmVDaGFubmVsKGNoYW5uZWwpIHtcbiAgY29uc3QgbWF5YmVQcm9taXNlID0gY2hhbm5lbC5tZXRob2QuY3JlYXRlKGNoYW5uZWwubmFtZSwgY2hhbm5lbC5vcHRpb25zKTtcbiAgaWYgKGlzUHJvbWlzZShtYXliZVByb21pc2UpKSB7XG4gICAgY2hhbm5lbC5fcHJlcFAgPSBtYXliZVByb21pc2U7XG4gICAgbWF5YmVQcm9taXNlLnRoZW4ocyA9PiB7XG4gICAgICAvLyB1c2VkIGluIHRlc3RzIHRvIHNpbXVsYXRlIHNsb3cgcnVudGltZVxuICAgICAgLyppZiAoY2hhbm5lbC5vcHRpb25zLnByZXBhcmVEZWxheSkge1xuICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHRoaXMub3B0aW9ucy5wcmVwYXJlRGVsYXkpKTtcbiAgICAgIH0qL1xuICAgICAgY2hhbm5lbC5fc3RhdGUgPSBzO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNoYW5uZWwuX3N0YXRlID0gbWF5YmVQcm9taXNlO1xuICB9XG59XG5mdW5jdGlvbiBfaGFzTWVzc2FnZUxpc3RlbmVycyhjaGFubmVsKSB7XG4gIGlmIChjaGFubmVsLl9hZGRFTC5tZXNzYWdlLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICBpZiAoY2hhbm5lbC5fYWRkRUwuaW50ZXJuYWwubGVuZ3RoID4gMCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lck9iamVjdChjaGFubmVsLCB0eXBlLCBvYmopIHtcbiAgY2hhbm5lbC5fYWRkRUxbdHlwZV0ucHVzaChvYmopO1xuICBfc3RhcnRMaXN0ZW5pbmcoY2hhbm5lbCk7XG59XG5mdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXJPYmplY3QoY2hhbm5lbCwgdHlwZSwgb2JqKSB7XG4gIGNoYW5uZWwuX2FkZEVMW3R5cGVdID0gY2hhbm5lbC5fYWRkRUxbdHlwZV0uZmlsdGVyKG8gPT4gbyAhPT0gb2JqKTtcbiAgX3N0b3BMaXN0ZW5pbmcoY2hhbm5lbCk7XG59XG5mdW5jdGlvbiBfc3RhcnRMaXN0ZW5pbmcoY2hhbm5lbCkge1xuICBpZiAoIWNoYW5uZWwuX2lMICYmIF9oYXNNZXNzYWdlTGlzdGVuZXJzKGNoYW5uZWwpKSB7XG4gICAgLy8gc29tZW9uZSBpcyBsaXN0ZW5pbmcsIHN0YXJ0IHN1YnNjcmliaW5nXG5cbiAgICBjb25zdCBsaXN0ZW5lckZuID0gbXNnT2JqID0+IHtcbiAgICAgIGNoYW5uZWwuX2FkZEVMW21zZ09iai50eXBlXS5mb3JFYWNoKGxpc3RlbmVyT2JqZWN0ID0+IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHRpbmcgdGhlIGN1cnJlbnQgdGltZSBpbiBKYXZhU2NyaXB0IGhhcyBubyBnb29kIHByZWNpc2lvbi5cbiAgICAgICAgICogU28gaW5zdGVhZCBvZiBvbmx5IGxpc3RlbmluZyB0byBldmVudHMgdGhhdCBoYXBwZW5kICdhZnRlcicgdGhlIGxpc3RlbmVyXG4gICAgICAgICAqIHdhcyBhZGRlZCwgd2UgYWxzbyBsaXN0ZW4gdG8gZXZlbnRzIHRoYXQgaGFwcGVuZGVkIDEwMG1zIGJlZm9yZSBpdC5cbiAgICAgICAgICogVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiBhbm90aGVyIHByb2Nlc3MsIGxpa2UgYSBXZWJXb3JrZXIsIHNlbmRzIGV2ZW50c1xuICAgICAgICAgKiB3ZSBkbyBub3QgbWlzcyB0aGVtIG91dCBiZWNhdXNlIHRoZWlyIHRpbWVzdGFtcCBpcyBhIGJpdCBvZmYgY29tcGFyZWQgdG8gdGhlIG1haW4gcHJvY2Vzcy5cbiAgICAgICAgICogTm90IGRvaW5nIHRoaXMgd291bGQgbWFrZSBtZXNzYWdlcyBtaXNzaW5nIHdoZW4gd2Ugc2VuZCBkYXRhIGRpcmVjdGx5IGFmdGVyIHN1YnNjcmliaW5nIGFuZCBhd2FpdGluZyBhIHJlc3BvbnNlLlxuICAgICAgICAgKiBAbGluayBodHRwczovL2pvaG5yZXNpZy5jb20vYmxvZy9hY2N1cmFjeS1vZi1qYXZhc2NyaXB0LXRpbWUvXG4gICAgICAgICAqL1xuICAgICAgICAvLyBjb25zdCBodW5kcmVkTXNJbk1pY3JvID0gMTAwICogMTAwMDtcbiAgICAgICAgLy8gY29uc3QgbWluTWVzc2FnZVRpbWUgPSBsaXN0ZW5lck9iamVjdC50aW1lIC0gaHVuZHJlZE1zSW5NaWNybztcblxuICAgICAgICBpZiAobXNnT2JqLnRpbWUgPj0gbGlzdGVuZXJPYmplY3QudGltZSkge1xuICAgICAgICAgIGxpc3RlbmVyT2JqZWN0LmZuKG1zZ09iai5kYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsLm1ldGhvZC50eXBlID09PSAnc2VydmVyJykge1xuICAgICAgICAgIC8vIHNlcnZlciBtc2cgbWlnaHQgbGFnIGJhc2VkIG9uIGNvbm5lY3Rpb24uXG4gICAgICAgICAgbGlzdGVuZXJPYmplY3QuZm4obXNnT2JqLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpbWUgPSBjaGFubmVsLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICBpZiAoY2hhbm5lbC5fcHJlcFApIHtcbiAgICAgIGNoYW5uZWwuX3ByZXBQLnRoZW4oKCkgPT4ge1xuICAgICAgICBjaGFubmVsLl9pTCA9IHRydWU7XG4gICAgICAgIGNoYW5uZWwubWV0aG9kLm9uTWVzc2FnZShjaGFubmVsLl9zdGF0ZSwgbGlzdGVuZXJGbiwgdGltZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbC5faUwgPSB0cnVlO1xuICAgICAgY2hhbm5lbC5tZXRob2Qub25NZXNzYWdlKGNoYW5uZWwuX3N0YXRlLCBsaXN0ZW5lckZuLCB0aW1lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9zdG9wTGlzdGVuaW5nKGNoYW5uZWwpIHtcbiAgaWYgKGNoYW5uZWwuX2lMICYmICFfaGFzTWVzc2FnZUxpc3RlbmVycyhjaGFubmVsKSkge1xuICAgIC8vIG5vb25lIGlzIGxpc3RlbmluZywgc3RvcCBzdWJzY3JpYmluZ1xuICAgIGNoYW5uZWwuX2lMID0gZmFsc2U7XG4gICAgY29uc3QgdGltZSA9IGNoYW5uZWwubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIGNoYW5uZWwubWV0aG9kLm9uTWVzc2FnZShjaGFubmVsLl9zdGF0ZSwgbnVsbCwgdGltZSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQnJvYWRjYXN0Q2hhbm5lbCQxIGFzIEJyb2FkY2FzdENoYW5uZWwsIEluZGV4ZURiTWV0aG9kIGFzIEluZGV4ZWREYk1ldGhvZCwgTG9jYWxzdG9yYWdlTWV0aG9kIGFzIExvY2FsU3RvcmFnZU1ldGhvZCwgTmF0aXZlTWV0aG9kLCBPUEVOX0JST0FEQ0FTVF9DSEFOTkVMUywgU2VydmVyTWV0aG9kLCBjaG9vc2VNZXRob2QsIGVuZm9yY2VPcHRpb25zIH07XG4iXSwibmFtZXMiOlsibG9nbGV2ZWwiLCJPYmxpdmlvdXNTZXQiLCJpbyIsImdldFB1YmxpYyIsInNpZ24iLCJrZWNjYWsyNTYiLCJlbmNyeXB0RGF0YSIsImRlY3J5cHREYXRhIiwiaXNQcm9taXNlIiwib2JqIiwidGhlbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiUFJPTUlTRV9SRVNPTFZFRF9WT0lEIiwic2xlZXAiLCJ0aW1lIiwicmVzb2x2ZVdpdGgiLCJyZXMiLCJzZXRUaW1lb3V0IiwicmFuZG9tSW50IiwibWluIiwibWF4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicmFuZG9tVG9rZW4iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImxhc3RNcyIsIm1pY3JvU2Vjb25kcyQ1IiwicmV0IiwiRGF0ZSIsIm5vdyIsImxvZyIsImdldExvZ2dlciIsInNldExldmVsIiwibWljcm9TZWNvbmRzJDQiLCJ0eXBlJDQiLCJjcmVhdGUkNCIsImNoYW5uZWxOYW1lIiwic3RhdGUiLCJtZXNzYWdlc0NhbGxiYWNrIiwiYmMiLCJCcm9hZGNhc3RDaGFubmVsIiwic3ViRm5zIiwib25tZXNzYWdlIiwibXNnIiwiZGF0YSIsImNsb3NlJDQiLCJjaGFubmVsU3RhdGUiLCJjbG9zZSIsInBvc3RNZXNzYWdlJDQiLCJtZXNzYWdlSnNvbiIsInBvc3RNZXNzYWdlIiwiZXJyIiwicmVqZWN0Iiwib25NZXNzYWdlJDQiLCJmbiIsImNhbkJlVXNlZCQ0IiwiX3B1YmtleSIsIkVycm9yIiwiYXZlcmFnZVJlc3BvbnNlVGltZSQ0IiwiTmF0aXZlTWV0aG9kIiwiY3JlYXRlIiwib25NZXNzYWdlIiwiY2FuQmVVc2VkIiwidHlwZSIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJtaWNyb1NlY29uZHMiLCJmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyIsIm9yaWdpbmFsT3B0aW9ucyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIm9wdGlvbnMiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ3ZWJXb3JrZXJTdXBwb3J0IiwiaWRiIiwidHRsIiwiZmFsbGJhY2tJbnRlcnZhbCIsIm9uY2xvc2UiLCJsb2NhbHN0b3JhZ2UiLCJyZW1vdmVUaW1lb3V0Iiwic2VydmVyIiwidXJsIiwibWV0aG9kcyIsIm1pY3JvU2Vjb25kcyQzIiwiREJfUFJFRklYIiwiT0JKRUNUX1NUT1JFX0lEIiwiVFJBTlNBQ1RJT05fU0VUVElOR1MiLCJkdXJhYmlsaXR5IiwidHlwZSQzIiwiZ2V0SWRiIiwiaW5kZXhlZERCIiwid2luZG93IiwibW96SW5kZXhlZERCIiwid2Via2l0SW5kZXhlZERCIiwibXNJbmRleGVkREIiLCJjb21taXRJbmRleGVkREJUcmFuc2FjdGlvbiIsInR4IiwiY29tbWl0IiwiY3JlYXRlRGF0YWJhc2UiLCJJbmRleGVkREIiLCJkYk5hbWUiLCJvcGVuUmVxdWVzdCIsIm9wZW4iLCJvbnVwZ3JhZGVuZWVkZWQiLCJldiIsImRiIiwidGFyZ2V0IiwicmVzdWx0IiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJrZXlQYXRoIiwiYXV0b0luY3JlbWVudCIsImRiUHJvbWlzZSIsInJlaiIsIm9uZXJyb3IiLCJvbnN1Y2Nlc3MiLCJ3cml0ZU1lc3NhZ2UiLCJyZWFkZXJVdWlkIiwid3JpdGVPYmplY3QiLCJ1dWlkIiwidHJhbnNhY3Rpb24iLCJvbmNvbXBsZXRlIiwib2JqZWN0U3RvcmUiLCJhZGQiLCJnZXRBbGxNZXNzYWdlcyIsIm9wZW5DdXJzb3IiLCJjdXJzb3IiLCJwdXNoIiwidmFsdWUiLCJjb250aW51ZSIsImdldE1lc3NhZ2VzSGlnaGVyVGhhbiIsImxhc3RDdXJzb3JJZCIsImtleVJhbmdlVmFsdWUiLCJJREJLZXlSYW5nZSIsImJvdW5kIiwiSW5maW5pdHkiLCJnZXRBbGwiLCJnZXRBbGxSZXF1ZXN0IiwiZSIsIm9wZW5DdXJzb3JSZXF1ZXN0IiwiaWQiLCJyZW1vdmVNZXNzYWdlc0J5SWQiLCJpZHMiLCJhbGwiLCJtYXAiLCJkZWxldGVSZXF1ZXN0IiwiZGVsZXRlIiwiZ2V0T2xkTWVzc2FnZXMiLCJvbGRlclRoZW4iLCJtc2dPYmsiLCJjbGVhbk9sZE1lc3NhZ2VzIiwidG9vT2xkIiwiY3JlYXRlJDMiLCJjbG9zZWQiLCJlTUlzIiwid3JpdGVCbG9ja1Byb21pc2UiLCJyZWFkUXVldWVQcm9taXNlcyIsIl9yZWFkTG9vcCIsInJlYWROZXdNZXNzYWdlcyIsIl9maWx0ZXJNZXNzYWdlIiwibXNnT2JqIiwiaGFzIiwibWVzc2FnZXNDYWxsYmFja1RpbWUiLCJuZXdlck1lc3NhZ2VzIiwidXNlTWVzc2FnZXMiLCJmaWx0ZXIiLCJzb3J0IiwibXNnT2JqQSIsIm1zZ09iakIiLCJmb3JFYWNoIiwiY2xvc2UkMyIsInBvc3RNZXNzYWdlJDMiLCJvbk1lc3NhZ2UkMyIsImNhbkJlVXNlZCQzIiwiYXZlcmFnZVJlc3BvbnNlVGltZSQzIiwiSW5kZXhlRGJNZXRob2QiLCJtaWNyb1NlY29uZHMkMiIsIktFWV9QUkVGSVgkMSIsInR5cGUkMiIsImdldExvY2FsU3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsInN0b3JhZ2VLZXkkMSIsInBvc3RNZXNzYWdlJDIiLCJrZXkiLCJ3cml0ZU9iaiIsInRva2VuIiwic2V0SXRlbSIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJuZXdWYWx1ZSIsImRpc3BhdGNoRXZlbnQiLCJhZGRTdG9yYWdlRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZVN0b3JhZ2VFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNyZWF0ZSQyIiwiY2FuQmVVc2VkJDIiLCJjbG9zZSQyIiwib25NZXNzYWdlJDIiLCJscyIsInJlbW92ZUl0ZW0iLCJhdmVyYWdlUmVzcG9uc2VUaW1lJDIiLCJkZWZhdWx0VGltZSIsInVzZXJBZ2VudCIsIm5hdmlnYXRvciIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJMb2NhbHN0b3JhZ2VNZXRob2QiLCJzdG9yYWdlS2V5IiwibWljcm9TZWNvbmRzJDEiLCJLRVlfUFJFRklYIiwidHlwZSQxIiwiU09DS0VUX0NPTk5fSU5TVEFOQ0UiLCJydW5uaW5nQ2hhbm5lbHMiLCJTZXQiLCJwb3N0TWVzc2FnZSQxIiwiY2hhbm5lbEVuY1ByaXZLZXkiLCJCdWZmZXIiLCJmcm9tIiwiZW5jRGF0YSIsImJvZHkiLCJzYW1lT3JpZ2luQ2hlY2siLCJzYW1lSXBDaGVjayIsInNpZ25hdHVyZSIsInRpbWVvdXQiLCJmZXRjaCIsInNlcnZlclVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJjYXRjaCIsImdldFNvY2tldEluc3RhbmNlIiwiU09DS0VUX0NPTk4iLCJ0cmFuc3BvcnRzIiwid2l0aENyZWRlbnRpYWxzIiwicmVjb25uZWN0aW9uRGVsYXlNYXgiLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsIm9uIiwib3B0cyIsImVycm9yIiwiZW5naW5lIiwiZGVidWciLCJ0cmFuc3BvcnQiLCJuYW1lIiwib25jZSIsInJlYXNvbiIsImRpc2Nvbm5lY3QiLCJzZXR1cFNvY2tldENvbm5lY3Rpb24iLCJzb2NrZXRDb25uIiwiY2hhbm5lbFB1YktleSIsImNvbm5lY3RlZCIsImVtaXQiLCJyZWNvbm5lY3QiLCJ2aXNpYmlsaXR5TGlzdGVuZXIiLCJ2aXNpYmlsaXR5U3RhdGUiLCJkZWNEYXRhIiwiaW5mbyIsImNyZWF0ZSQxIiwiY2xvc2UkMSIsIm9uTWVzc2FnZSQxIiwiY2FuQmVVc2VkJDEiLCJhdmVyYWdlUmVzcG9uc2VUaW1lJDEiLCJTZXJ2ZXJNZXRob2QiLCJTSU1VTEFURV9DSEFOTkVMUyIsIlNJTVVMQVRFX0RFTEFZX1RJTUUiLCJjaGFubmVsQXJyYXkiLCJBcnJheSIsImNoYW5uZWwiLCJTaW11bGF0ZU1ldGhvZCIsIk1FVEhPRFMiLCJjaG9vc2VNZXRob2QiLCJjaG9vc2VNZXRob2RzIiwiY29uY2F0IiwiQm9vbGVhbiIsImZpbmQiLCJtIiwidXNlTWV0aG9kIiwiT1BFTl9CUk9BRENBU1RfQ0hBTk5FTFMiLCJsYXN0SWQiLCJCcm9hZGNhc3RDaGFubmVsJDEiLCJFTkZPUkNFRF9PUFRJT05TIiwiX2lMIiwiX29uTUwiLCJfYWRkRUwiLCJtZXNzYWdlIiwiaW50ZXJuYWwiLCJfdU1QIiwiX2JlZkMiLCJfcHJlcFAiLCJfcHJlcGFyZUNoYW5uZWwiLCJlbmZvcmNlT3B0aW9ucyIsInByb3RvdHlwZSIsIl9wb3N0IiwicG9zdEludGVybmFsIiwibGlzdGVuT2JqIiwiX3JlbW92ZUxpc3RlbmVyT2JqZWN0IiwiX2FkZExpc3RlbmVyT2JqZWN0IiwiYXdhaXRQcmVwYXJlIiwiX3N0YXRlIiwiaXNDbG9zZWQiLCJicm9hZGNhc3RDaGFubmVsIiwic2VuZFByb21pc2UiLCJtYXliZVByb21pc2UiLCJzIiwiX2hhc01lc3NhZ2VMaXN0ZW5lcnMiLCJfc3RhcnRMaXN0ZW5pbmciLCJvIiwiX3N0b3BMaXN0ZW5pbmciLCJsaXN0ZW5lckZuIiwibGlzdGVuZXJPYmplY3QiLCJJbmRleGVkRGJNZXRob2QiLCJMb2NhbFN0b3JhZ2VNZXRob2QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toruslabs/constants/dist/constants.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FND_SERVER: () => (/* binding */ FND_SERVER),\n/* harmony export */   KEY_TYPE: () => (/* binding */ KEY_TYPE),\n/* harmony export */   LEGACY_NETWORKS_ROUTE_MAP: () => (/* binding */ LEGACY_NETWORKS_ROUTE_MAP),\n/* harmony export */   METADATA_MAP: () => (/* binding */ METADATA_MAP),\n/* harmony export */   MULTI_CLUSTER_NETWORKS: () => (/* binding */ MULTI_CLUSTER_NETWORKS),\n/* harmony export */   NETWORK_MAP: () => (/* binding */ NETWORK_MAP),\n/* harmony export */   PROXY_CONTRACT_ADDRESS: () => (/* binding */ PROXY_CONTRACT_ADDRESS),\n/* harmony export */   SESSION_SERVER: () => (/* binding */ SESSION_SERVER),\n/* harmony export */   SIGNER_MAP: () => (/* binding */ SIGNER_MAP),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* binding */ TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* binding */ TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   abi: () => (/* binding */ abi)\n/* harmony export */ });\nconst TORUS_LEGACY_NETWORK = {\n    MAINNET: \"mainnet\",\n    TESTNET: \"testnet\",\n    CYAN: \"cyan\",\n    AQUA: \"aqua\",\n    CELESTE: \"celeste\"\n};\nconst TORUS_SAPPHIRE_NETWORK = {\n    SAPPHIRE_DEVNET: \"sapphire_devnet\",\n    SAPPHIRE_MAINNET: \"sapphire_mainnet\"\n};\nconst PROXY_CONTRACT_ADDRESS = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"0xf20336e16B5182637f09821c27BDe29b0AFcfe80\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"0x9f072ba19b3370e512aa1b4bfcdaf97283168005\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"0x29Dea82a0509153b91040ee13cDBba0f03efb625\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c\"\n};\nconst MULTI_CLUSTER_NETWORKS = [];\nconst LEGACY_NETWORKS_ROUTE_MAP = {\n    [TORUS_LEGACY_NETWORK.AQUA]: {\n        migrationCompleted: true,\n        networkIdentifier: \"aqua\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.CELESTE]: {\n        migrationCompleted: true,\n        networkIdentifier: \"celeste\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.CYAN]: {\n        migrationCompleted: true,\n        networkIdentifier: \"cyan\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.MAINNET]: {\n        migrationCompleted: true,\n        networkIdentifier: \"mainnet\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.TESTNET]: {\n        migrationCompleted: true,\n        networkIdentifier: \"teal\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET\n    }\n};\nconst NETWORK_MAP = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"mainnet\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"goerli\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"polygon-mainnet\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"polygon-mainnet\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"polygon-mainnet\"\n};\nconst SIGNER_MAP = {\n    [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: \"https://signer.web3auth.io\",\n    [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"https://signer-polygon.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"https://signer-polygon.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"https://signer-polygon.web3auth.io\"\n};\nconst METADATA_MAP = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"https://metadata.web3auth.io\"\n};\nconst FND_SERVER = \"https://fnd.web3auth.io\";\nconst SESSION_SERVER = \"https://session.web3auth.io\";\nconst KEY_TYPE = {\n    SECP256K1: \"secp256k1\",\n    ED25519: \"ed25519\"\n};\nconst abi = [\n    {\n        inputs: [\n            {\n                internalType: \"string\",\n                name: \"_verifier\",\n                type: \"string\"\n            },\n            {\n                internalType: \"bytes32\",\n                name: \"hashedVerifierId\",\n                type: \"bytes32\"\n            }\n        ],\n        name: \"getNodeSet\",\n        outputs: [\n            {\n                internalType: \"uint256\",\n                name: \"currentEpoch\",\n                type: \"uint256\"\n            },\n            {\n                internalType: \"string[]\",\n                name: \"torusNodeEndpoints\",\n                type: \"string[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusNodePubX\",\n                type: \"uint256[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusNodePubY\",\n                type: \"uint256[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusIndexes\",\n                type: \"uint256[]\"\n            }\n        ],\n        stateMutability: \"view\",\n        type: \"function\"\n    }\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9jb25zdGFudHMvZGlzdC9jb25zdGFudHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLHVCQUF1QjtJQUMzQkMsU0FBUztJQUNUQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxTQUFTO0FBQ1g7QUFDQSxNQUFNQyx5QkFBeUI7SUFDN0JDLGlCQUFpQjtJQUNqQkMsa0JBQWtCO0FBQ3BCO0FBQ0EsTUFBTUMseUJBQXlCO0lBQzdCLENBQUNULHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1LLHlCQUF5QixFQUk5QjtBQUNELE1BQU1DLDRCQUE0QjtJQUNoQyxDQUFDWCxxQkFBcUJJLElBQUksQ0FBQyxFQUFFO1FBQzNCUSxvQkFBb0I7UUFDcEJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CUix1QkFBdUJFLGdCQUFnQjtJQUM1RDtJQUNBLENBQUNSLHFCQUFxQkssT0FBTyxDQUFDLEVBQUU7UUFDOUJPLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQyxtQkFBbUJSLHVCQUF1QkUsZ0JBQWdCO0lBQzVEO0lBQ0EsQ0FBQ1IscUJBQXFCRyxJQUFJLENBQUMsRUFBRTtRQUMzQlMsb0JBQW9CO1FBQ3BCQyxtQkFBbUI7UUFDbkJDLG1CQUFtQlIsdUJBQXVCRSxnQkFBZ0I7SUFDNUQ7SUFDQSxDQUFDUixxQkFBcUJDLE9BQU8sQ0FBQyxFQUFFO1FBQzlCVyxvQkFBb0I7UUFDcEJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CUix1QkFBdUJFLGdCQUFnQjtJQUM1RDtJQUNBLENBQUNSLHFCQUFxQkUsT0FBTyxDQUFDLEVBQUU7UUFDOUJVLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQyxtQkFBbUJSLHVCQUF1QkMsZUFBZTtJQUMzRDtBQUNGO0FBQ0EsTUFBTVEsY0FBYztJQUNsQixDQUFDZixxQkFBcUJDLE9BQU8sQ0FBQyxFQUFFO0lBQ2hDLENBQUNELHFCQUFxQkUsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0YscUJBQXFCRyxJQUFJLENBQUMsRUFBRTtJQUM3QixDQUFDSCxxQkFBcUJJLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNKLHFCQUFxQkssT0FBTyxDQUFDLEVBQUU7QUFDbEM7QUFDQSxNQUFNVyxhQUFhO0lBQ2pCLENBQUNWLHVCQUF1QkUsZ0JBQWdCLENBQUMsRUFBRTtJQUMzQyxDQUFDRix1QkFBdUJDLGVBQWUsQ0FBQyxFQUFFO0lBQzFDLENBQUNQLHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1ZLGVBQWU7SUFDbkIsQ0FBQ2pCLHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1hLGFBQWE7QUFDbkIsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLFdBQVc7SUFDZkMsV0FBVztJQUNYQyxTQUFTO0FBQ1g7QUFFQSxNQUFNQyxNQUFNO0lBQUM7UUFDWEMsUUFBUTtZQUFDO2dCQUNQQyxjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7WUFBRztnQkFDREYsY0FBYztnQkFDZEMsTUFBTTtnQkFDTkMsTUFBTTtZQUNSO1NBQUU7UUFDRkQsTUFBTTtRQUNORSxTQUFTO1lBQUM7Z0JBQ1JILGNBQWM7Z0JBQ2RDLE1BQU07Z0JBQ05DLE1BQU07WUFDUjtZQUFHO2dCQUNERixjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7WUFBRztnQkFDREYsY0FBYztnQkFDZEMsTUFBTTtnQkFDTkMsTUFBTTtZQUNSO1lBQUc7Z0JBQ0RGLGNBQWM7Z0JBQ2RDLE1BQU07Z0JBQ05DLE1BQU07WUFDUjtZQUFHO2dCQUNERixjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7U0FBRTtRQUNGRSxpQkFBaUI7UUFDakJGLE1BQU07SUFDUjtDQUFFO0FBRW1OIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29senp0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvY29uc3RhbnRzL2Rpc3QvY29uc3RhbnRzLmVzbS5qcz8zZTliIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFRPUlVTX0xFR0FDWV9ORVRXT1JLID0ge1xuICBNQUlOTkVUOiBcIm1haW5uZXRcIixcbiAgVEVTVE5FVDogXCJ0ZXN0bmV0XCIsXG4gIENZQU46IFwiY3lhblwiLFxuICBBUVVBOiBcImFxdWFcIixcbiAgQ0VMRVNURTogXCJjZWxlc3RlXCJcbn07XG5jb25zdCBUT1JVU19TQVBQSElSRV9ORVRXT1JLID0ge1xuICBTQVBQSElSRV9ERVZORVQ6IFwic2FwcGhpcmVfZGV2bmV0XCIsXG4gIFNBUFBISVJFX01BSU5ORVQ6IFwic2FwcGhpcmVfbWFpbm5ldFwiXG59O1xuY29uc3QgUFJPWFlfQ09OVFJBQ1RfQUREUkVTUyA9IHtcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcIjB4ZjIwMzM2ZTE2QjUxODI2MzdmMDk4MjFjMjdCRGUyOWIwQUZjZmU4MFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiMHhkMDg0NjA0ZTVGQTM4N0ZiQzJEYThiQWFiMDdmREQ2YURFRDQ2MTRBXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXTogXCIweDlmMDcyYmExOWIzMzcwZTUxMmFhMWI0YmZjZGFmOTcyODMxNjgwMDVcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcIjB4MjlEZWE4MmEwNTA5MTUzYjkxMDQwZWUxM2NEQmJhMGYwM2VmYjYyNVwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiMHg2QmZmYjRlODk0NTMwNjlFNzQ4N2YwZmE1YzlmNGEyRDc3MWNjZTZjXCJcbn07XG5jb25zdCBNVUxUSV9DTFVTVEVSX05FVFdPUktTID0gW1xuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBLFxuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFLFxuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOLFxuXTtcbmNvbnN0IExFR0FDWV9ORVRXT1JLU19ST1VURV9NQVAgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJhcXVhXCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwiY2VsZXN0ZVwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRcbiAgfSxcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcImN5YW5cIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXG4gIH0sXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJtYWlubmV0XCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwidGVhbFwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX0RFVk5FVFxuICB9XG59O1xuY29uc3QgTkVUV09SS19NQVAgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXTogXCJtYWlubmV0XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXTogXCJnb2VybGlcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiBcInBvbHlnb24tbWFpbm5ldFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwicG9seWdvbi1tYWlubmV0XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFXTogXCJwb2x5Z29uLW1haW5uZXRcIlxufTtcbmNvbnN0IFNJR05FUl9NQVAgPSB7XG4gIFtUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRdOiBcImh0dHBzOi8vc2lnbmVyLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX0RFVk5FVF06IFwiaHR0cHM6Ly9zaWduZXIud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcImh0dHBzOi8vc2lnbmVyLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXTogXCJodHRwczovL3NpZ25lci53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiXG59O1xuY29uc3QgTUVUQURBVEFfTUFQID0ge1xuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiXG59O1xuY29uc3QgRk5EX1NFUlZFUiA9IFwiaHR0cHM6Ly9mbmQud2ViM2F1dGguaW9cIjtcbmNvbnN0IFNFU1NJT05fU0VSVkVSID0gXCJodHRwczovL3Nlc3Npb24ud2ViM2F1dGguaW9cIjtcbmNvbnN0IEtFWV9UWVBFID0ge1xuICBTRUNQMjU2SzE6IFwic2VjcDI1NmsxXCIsXG4gIEVEMjU1MTk6IFwiZWQyNTUxOVwiXG59O1xuXG5jb25zdCBhYmkgPSBbe1xuICBpbnB1dHM6IFt7XG4gICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgIG5hbWU6IFwiX3ZlcmlmaWVyXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICBuYW1lOiBcImhhc2hlZFZlcmlmaWVySWRcIixcbiAgICB0eXBlOiBcImJ5dGVzMzJcIlxuICB9XSxcbiAgbmFtZTogXCJnZXROb2RlU2V0XCIsXG4gIG91dHB1dHM6IFt7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICBuYW1lOiBcImN1cnJlbnRFcG9jaFwiLFxuICAgIHR5cGU6IFwidWludDI1NlwiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nW11cIixcbiAgICBuYW1lOiBcInRvcnVzTm9kZUVuZHBvaW50c1wiLFxuICAgIHR5cGU6IFwic3RyaW5nW11cIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZbXVwiLFxuICAgIG5hbWU6IFwidG9ydXNOb2RlUHViWFwiLFxuICAgIHR5cGU6IFwidWludDI1NltdXCJcbiAgfSwge1xuICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2W11cIixcbiAgICBuYW1lOiBcInRvcnVzTm9kZVB1YllcIixcbiAgICB0eXBlOiBcInVpbnQyNTZbXVwiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NltdXCIsXG4gICAgbmFtZTogXCJ0b3J1c0luZGV4ZXNcIixcbiAgICB0eXBlOiBcInVpbnQyNTZbXVwiXG4gIH1dLFxuICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICB0eXBlOiBcImZ1bmN0aW9uXCJcbn1dO1xuXG5leHBvcnQgeyBGTkRfU0VSVkVSLCBLRVlfVFlQRSwgTEVHQUNZX05FVFdPUktTX1JPVVRFX01BUCwgTUVUQURBVEFfTUFQLCBNVUxUSV9DTFVTVEVSX05FVFdPUktTLCBORVRXT1JLX01BUCwgUFJPWFlfQ09OVFJBQ1RfQUREUkVTUywgU0VTU0lPTl9TRVJWRVIsIFNJR05FUl9NQVAsIFRPUlVTX0xFR0FDWV9ORVRXT1JLLCBUT1JVU19TQVBQSElSRV9ORVRXT1JLLCBhYmkgfTtcbiJdLCJuYW1lcyI6WyJUT1JVU19MRUdBQ1lfTkVUV09SSyIsIk1BSU5ORVQiLCJURVNUTkVUIiwiQ1lBTiIsIkFRVUEiLCJDRUxFU1RFIiwiVE9SVVNfU0FQUEhJUkVfTkVUV09SSyIsIlNBUFBISVJFX0RFVk5FVCIsIlNBUFBISVJFX01BSU5ORVQiLCJQUk9YWV9DT05UUkFDVF9BRERSRVNTIiwiTVVMVElfQ0xVU1RFUl9ORVRXT1JLUyIsIkxFR0FDWV9ORVRXT1JLU19ST1VURV9NQVAiLCJtaWdyYXRpb25Db21wbGV0ZWQiLCJuZXR3b3JrSWRlbnRpZmllciIsIm5ldHdvcmtNaWdyYXRlZFRvIiwiTkVUV09SS19NQVAiLCJTSUdORVJfTUFQIiwiTUVUQURBVEFfTUFQIiwiRk5EX1NFUlZFUiIsIlNFU1NJT05fU0VSVkVSIiwiS0VZX1RZUEUiLCJTRUNQMjU2SzEiLCJFRDI1NTE5IiwiYWJpIiwiaW5wdXRzIiwiaW50ZXJuYWxUeXBlIiwibmFtZSIsInR5cGUiLCJvdXRwdXRzIiwic3RhdGVNdXRhYmlsaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   derivePadded: () => (/* binding */ derivePadded),\n/* harmony export */   deriveUnpadded: () => (/* binding */ deriveUnpadded),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generatePrivate: () => (/* binding */ generatePrivate),\n/* harmony export */   getPublic: () => (/* binding */ getPublic),\n/* harmony export */   getPublicCompressed: () => (/* binding */ getPublicCompressed),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_1__.ec(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst browserCrypto = global.crypto || global.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nfunction isScalar(x) {\n    return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n    if (!isScalar(privateKey)) {\n        return false;\n    }\n    return privateKey.compare(ZERO32) > 0 && // > 0\n    privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for(let i = 0; i < b1.length; i++){\n        res |= b1[i] ^ b2[i]; // jshint ignore:line\n    }\n    return res === 0;\n}\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */ function randomBytes(size) {\n    const arr = new Uint8Array(size);\n    if (typeof browserCrypto.getRandomValues === \"undefined\") {\n        return Buffer.from(crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(size));\n    }\n    browserCrypto.getRandomValues(arr);\n    return Buffer.from(arr);\n}\nasync function sha512(msg) {\n    if (subtle) {\n        const hash = await subtle.digest(\"SHA-512\", msg);\n        const result = new Uint8Array(hash);\n        return result;\n    }\n    const hash = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash(\"sha512\");\n    const result = hash.update(msg).digest();\n    return new Uint8Array(result);\n}\nfunction getAes(op) {\n    return async function(iv, key, data) {\n        if (subtle) {\n            const importAlgorithm = {\n                name: \"AES-CBC\"\n            };\n            const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [\n                op\n            ]);\n            const encAlgorithm = {\n                name: \"AES-CBC\",\n                iv\n            };\n            const result = await subtle[op](encAlgorithm, cryptoKey, data);\n            return Buffer.from(new Uint8Array(result));\n        } else if (op === \"encrypt\") {\n            const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(\"aes-256-cbc\", key, iv);\n            const firstChunk = cipher.update(data);\n            const secondChunk = cipher.final();\n            return Buffer.concat([\n                firstChunk,\n                secondChunk\n            ]);\n        } else if (op === \"decrypt\") {\n            const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(\"aes-256-cbc\", key, iv);\n            const firstChunk = decipher.update(data);\n            const secondChunk = decipher.final();\n            return Buffer.concat([\n                firstChunk,\n                secondChunk\n            ]);\n        }\n        throw new Error(`Unsupported operation: ${op}`);\n    };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n    if (subtle) {\n        const importAlgorithm = {\n            name: \"HMAC\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\n            \"sign\",\n            \"verify\"\n        ]);\n        const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n        const result = Buffer.from(new Uint8Array(sig));\n        return result;\n    }\n    const hmac = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHmac(\"sha256\", Buffer.from(key));\n    hmac.update(msg);\n    const result = hmac.digest();\n    return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n    const expectedSig = await hmacSha256Sign(key, msg);\n    return equalConstTime(expectedSig, sig);\n}\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */ const generatePrivate = function() {\n    let privateKey = randomBytes(32);\n    while(!isValidPrivateKey(privateKey)){\n        privateKey = randomBytes(32);\n    }\n    return privateKey;\n};\nconst getPublic = function(privateKey) {\n    // This function has sync API so we throw an error immediately.\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // XXX(Kagami): `elliptic.utils.encode` returns array for every\n    // encoding except `hex`.\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n/**\n * Get compressed version of public key.\n */ const getPublicCompressed = function(privateKey) {\n    // jshint ignore:line\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // See https://github.com/wanderer/secp256k1-node/issues/46\n    const compressed = true;\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function(privateKey, msg) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    return Buffer.from(ec.sign(msg, privateKey, {\n        canonical: true\n    }).toDER());\n};\nconst verify = async function(publicKey, msg, sig) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65) {\n        assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33) {\n        assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n        return null;\n    }\n    throw new Error(\"Bad signature\");\n};\nconst derive = async function(privateKeyA, publicKeyB) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n        assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic()); // BN instance\n    return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function(privateKeyA, publicKeyB) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n        assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic()); // BN instance\n    return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function(publicKeyTo, msg, opts) {\n    opts = opts || {};\n    let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey)){\n        ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    const ephemPublicKey = getPublic(ephemPrivateKey);\n    const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n    const hash = await sha512(Px);\n    const iv = opts.iv || randomBytes(16);\n    const encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n    const ciphertext = data;\n    const dataToMac = Buffer.concat([\n        iv,\n        ephemPublicKey,\n        ciphertext\n    ]);\n    const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n    return {\n        iv,\n        ephemPublicKey,\n        ciphertext,\n        mac\n    };\n};\nconst decrypt = async function(privateKey, opts, _padding) {\n    const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n    const deriveLocal = padding ? derivePadded : deriveUnpadded;\n    const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n    const hash = await sha512(Px);\n    const encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const dataToMac = Buffer.concat([\n        opts.iv,\n        opts.ephemPublicKey,\n        opts.ciphertext\n    ]);\n    const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n    if (!macGood && padding === false) {\n        return decrypt(privateKey, opts, true);\n    } else if (!macGood && padding === true) {\n        throw new Error(\"bad MAC after trying padded\");\n    }\n    const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n    return Buffer.from(new Uint8Array(msg));\n};\n //# sourceMappingURL=eccrypto.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9lY2NyeXB0by9kaXN0L2VjY3J5cHRvLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNNO0FBRXRDLE1BQU1DLEtBQUssSUFBSUMsd0NBQUlBLENBQUM7QUFDcEIsOERBQThEO0FBQzlELE1BQU1DLGdCQUFnQkMsT0FBT0MsTUFBTSxJQUFJRCxPQUFPRSxRQUFRLElBQUksQ0FBQztBQUMzRCw4REFBOEQ7QUFDOUQsTUFBTUMsU0FBU0osY0FBY0ksTUFBTSxJQUFJSixjQUFjSyxZQUFZO0FBQ2pFLE1BQU1DLGlCQUFpQkMsT0FBT0MsSUFBSSxDQUFDLG9FQUFvRTtBQUN2RyxNQUFNQyxTQUFTRixPQUFPRyxLQUFLLENBQUMsSUFBSTtBQUNoQyxTQUFTQyxPQUFPQyxTQUFTLEVBQUVDLE9BQU87SUFDaEMsSUFBSSxDQUFDRCxXQUFXO1FBQ2QsTUFBTSxJQUFJRSxNQUFNRCxXQUFXO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTRSxTQUFTQyxDQUFDO0lBQ2pCLE9BQU9ULE9BQU9VLFFBQVEsQ0FBQ0QsTUFBTUEsRUFBRUUsTUFBTSxLQUFLO0FBQzVDO0FBQ0EsU0FBU0Msa0JBQWtCQyxVQUFVO0lBQ25DLElBQUksQ0FBQ0wsU0FBU0ssYUFBYTtRQUN6QixPQUFPO0lBQ1Q7SUFDQSxPQUFPQSxXQUFXQyxPQUFPLENBQUNaLFVBQVUsS0FDcEMsTUFBTTtJQUNOVyxXQUFXQyxPQUFPLENBQUNmLGtCQUFrQixHQUFHLE1BQU07QUFDaEQ7QUFFQSxrRUFBa0U7QUFDbEUsU0FBU2dCLGVBQWVDLEVBQUUsRUFBRUMsRUFBRTtJQUM1QixJQUFJRCxHQUFHTCxNQUFNLEtBQUtNLEdBQUdOLE1BQU0sRUFBRTtRQUMzQixPQUFPO0lBQ1Q7SUFDQSxJQUFJTyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILEdBQUdMLE1BQU0sRUFBRVEsSUFBSztRQUNsQ0QsT0FBT0YsRUFBRSxD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VSxnQkFBZ0J6RCxLQUFLMEQsS0FBSyxDQUFDLEdBQUc7SUFDcEMsTUFBTUMsU0FBUzNELEtBQUswRCxLQUFLLENBQUM7SUFDMUIsTUFBTUcsWUFBWXhGLE9BQU8rQyxNQUFNLENBQUM7UUFBQ2tDLEtBQUsvQyxFQUFFO1FBQUUrQyxLQUFLRSxjQUFjO1FBQUVGLEtBQUtNLFVBQVU7S0FBQztJQUMvRSxNQUFNTyxVQUFVLE1BQU1yQyxpQkFBaUJ6RCxPQUFPQyxJQUFJLENBQUNxRixTQUFTRSxXQUFXUCxLQUFLUSxHQUFHO0lBQy9FLElBQUksQ0FBQ0ssV0FBV0YsWUFBWSxPQUFPO1FBQ2pDLE9BQU9GLFFBQVE3RSxZQUFZb0UsTUFBTTtJQUNuQyxPQUFPLElBQUksQ0FBQ2EsV0FBV0YsWUFBWSxNQUFNO1FBQ3ZDLE1BQU0sSUFBSXJGLE1BQU07SUFDbEI7SUFDQSxNQUFNbUIsTUFBTSxNQUFNeUIsY0FBYzhCLEtBQUsvQyxFQUFFLEVBQUVsQyxPQUFPQyxJQUFJLENBQUNtRixnQkFBZ0JILEtBQUtNLFVBQVU7SUFDcEYsT0FBT3ZGLE9BQU9DLElBQUksQ0FBQyxJQUFJc0IsV0FBV0c7QUFDcEM7QUFFaUksQ0FDakksd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29senp0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvZWNjcnlwdG8vZGlzdC9lY2NyeXB0by5lc20uanM/ZjUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbm9kZUNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgZWMgYXMgZWMkMSB9IGZyb20gJ2VsbGlwdGljJztcblxuY29uc3QgZWMgPSBuZXcgZWMkMShcInNlY3AyNTZrMVwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBicm93c2VyQ3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8gfHwge307XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3Qgc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XG5jb25zdCBFQ19HUk9VUF9PUkRFUiA9IEJ1ZmZlci5mcm9tKFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiLCBcImhleFwiKTtcbmNvbnN0IFpFUk8zMiA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJBc3NlcnRpb24gZmFpbGVkXCIpO1xuICB9XG59XG5mdW5jdGlvbiBpc1NjYWxhcih4KSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoeCkgJiYgeC5sZW5ndGggPT09IDMyO1xufVxuZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICBpZiAoIWlzU2NhbGFyKHByaXZhdGVLZXkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBwcml2YXRlS2V5LmNvbXBhcmUoWkVSTzMyKSA+IDAgJiZcbiAgLy8gPiAwXG4gIHByaXZhdGVLZXkuY29tcGFyZShFQ19HUk9VUF9PUkRFUikgPCAwOyAvLyA8IEdcbn1cblxuLy8gQ29tcGFyZSB0d28gYnVmZmVycyBpbiBjb25zdGFudCB0aW1lIHRvIHByZXZlbnQgdGltaW5nIGF0dGFja3MuXG5mdW5jdGlvbiBlcXVhbENvbnN0VGltZShiMSwgYjIpIHtcbiAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCByZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzIHw9IGIxW2ldIF4gYjJbaV07IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB9XG5cbiAgcmV0dXJuIHJlcyA9PT0gMDtcbn1cblxuLyogVGhpcyBtdXN0IGNoZWNrIGlmIHdlJ3JlIGluIHRoZSBicm93c2VyIG9yXG5ub3QsIHNpbmNlIHRoZSBmdW5jdGlvbnMgYXJlIGRpZmZlcmVudCBhbmQgZG9lc1xubm90IGNvbnZlcnQgdXNpbmcgYnJvd3NlcmlmeSAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoc2l6ZSkge1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgaWYgKHR5cGVvZiBicm93c2VyQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShub2RlQ3J5cHRvLnJhbmRvbUJ5dGVzKHNpemUpKTtcbiAgfVxuICBicm93c2VyQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNoYTUxMihtc2cpIHtcbiAgaWYgKHN1YnRsZSkge1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBzdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBtc2cpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgaGFzaCA9IG5vZGVDcnlwdG8uY3JlYXRlSGFzaChcInNoYTUxMlwiKTtcbiAgY29uc3QgcmVzdWx0ID0gaGFzaC51cGRhdGUobXNnKS5kaWdlc3QoKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBnZXRBZXMob3ApIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIChpdiwga2V5LCBkYXRhKSB7XG4gICAgaWYgKHN1YnRsZSkge1xuICAgICAgY29uc3QgaW1wb3J0QWxnb3JpdGhtID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1DQkNcIlxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBpbXBvcnRBbGdvcml0aG0sIGZhbHNlLCBbb3BdKTtcbiAgICAgIGNvbnN0IGVuY0FsZ29yaXRobSA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCIsXG4gICAgICAgIGl2XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VidGxlW29wXShlbmNBbGdvcml0aG0sIGNyeXB0b0tleSwgZGF0YSk7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gXCJlbmNyeXB0XCIpIHtcbiAgICAgIGNvbnN0IGNpcGhlciA9IG5vZGVDcnlwdG8uY3JlYXRlQ2lwaGVyaXYoXCJhZXMtMjU2LWNiY1wiLCBrZXksIGl2KTtcbiAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgY29uc3Qgc2Vjb25kQ2h1bmsgPSBjaXBoZXIuZmluYWwoKTtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtmaXJzdENodW5rLCBzZWNvbmRDaHVua10pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiZGVjcnlwdFwiKSB7XG4gICAgICBjb25zdCBkZWNpcGhlciA9IG5vZGVDcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtY2JjXCIsIGtleSwgaXYpO1xuICAgICAgY29uc3QgZmlyc3RDaHVuayA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgIGNvbnN0IHNlY29uZENodW5rID0gZGVjaXBoZXIuZmluYWwoKTtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtmaXJzdENodW5rLCBzZWNvbmRDaHVua10pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9wZXJhdGlvbjogJHtvcH1gKTtcbiAgfTtcbn1cbmNvbnN0IGFlc0NiY0VuY3J5cHQgPSBnZXRBZXMoXCJlbmNyeXB0XCIpO1xuY29uc3QgYWVzQ2JjRGVjcnlwdCA9IGdldEFlcyhcImRlY3J5cHRcIik7XG5hc3luYyBmdW5jdGlvbiBobWFjU2hhMjU2U2lnbihrZXksIG1zZykge1xuICBpZiAoc3VidGxlKSB7XG4gICAgY29uc3QgaW1wb3J0QWxnb3JpdGhtID0ge1xuICAgICAgbmFtZTogXCJITUFDXCIsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IFwiU0hBLTI1NlwiXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIG5ldyBVaW50OEFycmF5KGtleSksIGltcG9ydEFsZ29yaXRobSwgZmFsc2UsIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl0pO1xuICAgIGNvbnN0IHNpZyA9IGF3YWl0IHN1YnRsZS5zaWduKFwiSE1BQ1wiLCBjcnlwdG9LZXksIG1zZyk7XG4gICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoc2lnKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBobWFjID0gbm9kZUNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIEJ1ZmZlci5mcm9tKGtleSkpO1xuICBobWFjLnVwZGF0ZShtc2cpO1xuICBjb25zdCByZXN1bHQgPSBobWFjLmRpZ2VzdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuYXN5bmMgZnVuY3Rpb24gaG1hY1NoYTI1NlZlcmlmeShrZXksIG1zZywgc2lnKSB7XG4gIGNvbnN0IGV4cGVjdGVkU2lnID0gYXdhaXQgaG1hY1NoYTI1NlNpZ24oa2V5LCBtc2cpO1xuICByZXR1cm4gZXF1YWxDb25zdFRpbWUoZXhwZWN0ZWRTaWcsIHNpZyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBuZXcgdmFsaWQgcHJpdmF0ZSBrZXkuIFdpbGwgdXNlIHRoZSB3aW5kb3cuY3J5cHRvIG9yIHdpbmRvdy5tc0NyeXB0byBhcyBzb3VyY2VcbiAqIGRlcGVuZGluZyBvbiB5b3VyIGJyb3dzZXIuXG4gKi9cbmNvbnN0IGdlbmVyYXRlUHJpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG4gIHdoaWxlICghaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkpIHtcbiAgICBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICB9XG4gIHJldHVybiBwcml2YXRlS2V5O1xufTtcbmNvbnN0IGdldFB1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHN5bmMgQVBJIHNvIHdlIHRocm93IGFuIGVycm9yIGltbWVkaWF0ZWx5LlxuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgLy8gWFhYKEthZ2FtaSk6IGBlbGxpcHRpYy51dGlscy5lbmNvZGVgIHJldHVybnMgYXJyYXkgZm9yIGV2ZXJ5XG4gIC8vIGVuY29kaW5nIGV4Y2VwdCBgaGV4YC5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhcImFycmF5XCIpKTtcbn07XG5cbi8qKlxuICogR2V0IGNvbXByZXNzZWQgdmVyc2lvbiBvZiBwdWJsaWMga2V5LlxuICovXG5jb25zdCBnZXRQdWJsaWNDb21wcmVzc2VkID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3dhbmRlcmVyL3NlY3AyNTZrMS1ub2RlL2lzc3Vlcy80NlxuICBjb25zdCBjb21wcmVzc2VkID0gdHJ1ZTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhjb21wcmVzc2VkLCBcImFycmF5XCIpKTtcbn07XG5cbi8vIE5PVEUoS2FnYW1pKTogV2UgZG9uJ3QgdXNlIHByb21pc2Ugc2hpbSBpbiBCcm93c2VyIGltcGxlbWVudGF0aW9uXG4vLyBiZWNhdXNlIGl0J3Mgc3VwcG9ydGVkIG5hdGl2ZWx5IGluIG5ldyBicm93c2VycyAoc2VlXG4vLyA8aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PXByb21pc2VzPikgYW5kIHdlIGNhbiB1c2Ugb25seSBuZXcgYnJvd3NlcnNcbi8vIGJlY2F1c2Ugb2YgdGhlIFdlYkNyeXB0b0FQSSAoc2VlXG4vLyA8aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWNyeXB0b2dyYXBoeT4pLlxuY29uc3Qgc2lnbiA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5LCBtc2cpIHtcbiAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChtc2cubGVuZ3RoID4gMCwgXCJNZXNzYWdlIHNob3VsZCBub3QgYmUgZW1wdHlcIik7XG4gIGFzc2VydChtc2cubGVuZ3RoIDw9IDMyLCBcIk1lc3NhZ2UgaXMgdG9vIGxvbmdcIik7XG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5zaWduKG1zZywgcHJpdmF0ZUtleSwge1xuICAgIGNhbm9uaWNhbDogdHJ1ZVxuICB9KS50b0RFUigpKTtcbn07XG5jb25zdCB2ZXJpZnkgPSBhc3luYyBmdW5jdGlvbiAocHVibGljS2V5LCBtc2csIHNpZykge1xuICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Lmxlbmd0aCA9PT0gMzMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NSkge1xuICAgIGFzc2VydChwdWJsaWNLZXlbMF0gPT09IDQsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDMzKSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleVswXSA9PT0gMiB8fCBwdWJsaWNLZXlbMF0gPT09IDMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgYXNzZXJ0KG1zZy5sZW5ndGggPiAwLCBcIk1lc3NhZ2Ugc2hvdWxkIG5vdCBiZSBlbXB0eVwiKTtcbiAgYXNzZXJ0KG1zZy5sZW5ndGggPD0gMzIsIFwiTWVzc2FnZSBpcyB0b28gbG9uZ1wiKTtcbiAgaWYgKGVjLnZlcmlmeShtc2csIHNpZywgcHVibGljS2V5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkJhZCBzaWduYXR1cmVcIik7XG59O1xuY29uc3QgZGVyaXZlID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXlBLCBwdWJsaWNLZXlCKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwdWJsaWNLZXlCKSwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgYXNzZXJ0KHByaXZhdGVLZXlBLmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSB8fCBwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDMzKSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDIgfHwgcHVibGljS2V5QlswXSA9PT0gMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBjb25zdCBrZXlBID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUEpO1xuICBjb25zdCBrZXlCID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXlCKTtcbiAgY29uc3QgUHggPSBrZXlBLmRlcml2ZShrZXlCLmdldFB1YmxpYygpKTsgLy8gQk4gaW5zdGFuY2VcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFB4LnRvQXJyYXkoKSk7XG59O1xuY29uc3QgZGVyaXZlVW5wYWRkZWQgPSBkZXJpdmU7XG5jb25zdCBkZXJpdmVQYWRkZWQgPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleUEsIHB1YmxpY0tleUIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwcml2YXRlS2V5QSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHB1YmxpY0tleUIpLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBhc3NlcnQocHJpdmF0ZUtleUEubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5QSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQocHVibGljS2V5Qi5sZW5ndGggPT09IDY1IHx8IHB1YmxpY0tleUIubGVuZ3RoID09PSAzMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSkge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSA0LCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gMiB8fCBwdWJsaWNLZXlCWzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGNvbnN0IGtleUEgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5QSk7XG4gIGNvbnN0IGtleUIgPSBlYy5rZXlGcm9tUHVibGljKHB1YmxpY0tleUIpO1xuICBjb25zdCBQeCA9IGtleUEuZGVyaXZlKGtleUIuZ2V0UHVibGljKCkpOyAvLyBCTiBpbnN0YW5jZVxuICByZXR1cm4gQnVmZmVyLmZyb20oUHgudG9TdHJpbmcoMTYsIDY0KSwgXCJoZXhcIik7XG59O1xuY29uc3QgZW5jcnlwdCA9IGFzeW5jIGZ1bmN0aW9uIChwdWJsaWNLZXlUbywgbXNnLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBsZXQgZXBoZW1Qcml2YXRlS2V5ID0gb3B0cy5lcGhlbVByaXZhdGVLZXkgfHwgcmFuZG9tQnl0ZXMoMzIpO1xuICAvLyBUaGVyZSBpcyBhIHZlcnkgdW5saWtlbHkgcG9zc2liaWxpdHkgdGhhdCBpdCBpcyBub3QgYSB2YWxpZCBrZXlcbiAgd2hpbGUgKCFpc1ZhbGlkUHJpdmF0ZUtleShlcGhlbVByaXZhdGVLZXkpKSB7XG4gICAgZXBoZW1Qcml2YXRlS2V5ID0gb3B0cy5lcGhlbVByaXZhdGVLZXkgfHwgcmFuZG9tQnl0ZXMoMzIpO1xuICB9XG4gIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gZ2V0UHVibGljKGVwaGVtUHJpdmF0ZUtleSk7XG4gIGNvbnN0IFB4ID0gYXdhaXQgZGVyaXZlVW5wYWRkZWQoZXBoZW1Qcml2YXRlS2V5LCBwdWJsaWNLZXlUbyk7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBzaGE1MTIoUHgpO1xuICBjb25zdCBpdiA9IG9wdHMuaXYgfHwgcmFuZG9tQnl0ZXMoMTYpO1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gaGFzaC5zbGljZSgwLCAzMik7XG4gIGNvbnN0IG1hY0tleSA9IGhhc2guc2xpY2UoMzIpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgYWVzQ2JjRW5jcnlwdChpdiwgQnVmZmVyLmZyb20oZW5jcnlwdGlvbktleSksIG1zZyk7XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBkYXRhO1xuICBjb25zdCBkYXRhVG9NYWMgPSBCdWZmZXIuY29uY2F0KFtpdiwgZXBoZW1QdWJsaWNLZXksIGNpcGhlcnRleHRdKTtcbiAgY29uc3QgbWFjID0gYXdhaXQgaG1hY1NoYTI1NlNpZ24oQnVmZmVyLmZyb20obWFjS2V5KSwgZGF0YVRvTWFjKTtcbiAgcmV0dXJuIHtcbiAgICBpdixcbiAgICBlcGhlbVB1YmxpY0tleSxcbiAgICBjaXBoZXJ0ZXh0LFxuICAgIG1hY1xuICB9O1xufTtcbmNvbnN0IGRlY3J5cHQgPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleSwgb3B0cywgX3BhZGRpbmcpIHtcbiAgY29uc3QgcGFkZGluZyA9IF9wYWRkaW5nICE9PSBudWxsICYmIF9wYWRkaW5nICE9PSB2b2lkIDAgPyBfcGFkZGluZyA6IGZhbHNlO1xuICBjb25zdCBkZXJpdmVMb2NhbCA9IHBhZGRpbmcgPyBkZXJpdmVQYWRkZWQgOiBkZXJpdmVVbnBhZGRlZDtcbiAgY29uc3QgUHggPSBhd2FpdCBkZXJpdmVMb2NhbChwcml2YXRlS2V5LCBvcHRzLmVwaGVtUHVibGljS2V5KTtcbiAgY29uc3QgaGFzaCA9IGF3YWl0IHNoYTUxMihQeCk7XG4gIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBoYXNoLnNsaWNlKDAsIDMyKTtcbiAgY29uc3QgbWFjS2V5ID0gaGFzaC5zbGljZSgzMik7XG4gIGNvbnN0IGRhdGFUb01hYyA9IEJ1ZmZlci5jb25jYXQoW29wdHMuaXYsIG9wdHMuZXBoZW1QdWJsaWNLZXksIG9wdHMuY2lwaGVydGV4dF0pO1xuICBjb25zdCBtYWNHb29kID0gYXdhaXQgaG1hY1NoYTI1NlZlcmlmeShCdWZmZXIuZnJvbShtYWNLZXkpLCBkYXRhVG9NYWMsIG9wdHMubWFjKTtcbiAgaWYgKCFtYWNHb29kICYmIHBhZGRpbmcgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGRlY3J5cHQocHJpdmF0ZUtleSwgb3B0cywgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoIW1hY0dvb2QgJiYgcGFkZGluZyA9PT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBNQUMgYWZ0ZXIgdHJ5aW5nIHBhZGRlZFwiKTtcbiAgfVxuICBjb25zdCBtc2cgPSBhd2FpdCBhZXNDYmNEZWNyeXB0KG9wdHMuaXYsIEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25LZXkpLCBvcHRzLmNpcGhlcnRleHQpO1xuICByZXR1cm4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkobXNnKSk7XG59O1xuXG5leHBvcnQgeyBkZWNyeXB0LCBkZXJpdmUsIGRlcml2ZVBhZGRlZCwgZGVyaXZlVW5wYWRkZWQsIGVuY3J5cHQsIGdlbmVyYXRlUHJpdmF0ZSwgZ2V0UHVibGljLCBnZXRQdWJsaWNDb21wcmVzc2VkLCBzaWduLCB2ZXJpZnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVjY3J5cHRvLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJub2RlQ3J5cHRvIiwiZWMiLCJlYyQxIiwiYnJvd3NlckNyeXB0byIsImdsb2JhbCIsImNyeXB0byIsIm1zQ3J5cHRvIiwic3VidGxlIiwid2Via2l0U3VidGxlIiwiRUNfR1JPVVBfT1JERVIiLCJCdWZmZXIiLCJmcm9tIiwiWkVSTzMyIiwiYWxsb2MiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJpc1NjYWxhciIsIngiLCJpc0J1ZmZlciIsImxlbmd0aCIsImlzVmFsaWRQcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImNvbXBhcmUiLCJlcXVhbENvbnN0VGltZSIsImIxIiwiYjIiLCJyZXMiLCJpIiwicmFuZG9tQnl0ZXMiLCJzaXplIiwiYXJyIiwiVWludDhBcnJheSIsImdldFJhbmRvbVZhbHVlcyIsInNoYTUxMiIsIm1zZyIsImhhc2giLCJkaWdlc3QiLCJyZXN1bHQiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZ2V0QWVzIiwib3AiLCJpdiIsImtleSIsImRhdGEiLCJpbXBvcnRBbGdvcml0aG0iLCJuYW1lIiwiY3J5cHRvS2V5IiwiaW1wb3J0S2V5IiwiZW5jQWxnb3JpdGhtIiwiY2lwaGVyIiwiY3JlYXRlQ2lwaGVyaXYiLCJmaXJzdENodW5rIiwic2Vjb25kQ2h1bmsiLCJmaW5hbCIsImNvbmNhdCIsImRlY2lwaGVyIiwiY3JlYXRlRGVjaXBoZXJpdiIsImFlc0NiY0VuY3J5cHQiLCJhZXNDYmNEZWNyeXB0IiwiaG1hY1NoYTI1NlNpZ24iLCJzaWciLCJzaWduIiwiaG1hYyIsImNyZWF0ZUhtYWMiLCJobWFjU2hhMjU2VmVyaWZ5IiwiZXhwZWN0ZWRTaWciLCJnZW5lcmF0ZVByaXZhdGUiLCJnZXRQdWJsaWMiLCJrZXlGcm9tUHJpdmF0ZSIsImdldFB1YmxpY0NvbXByZXNzZWQiLCJjb21wcmVzc2VkIiwiY2Fub25pY2FsIiwidG9ERVIiLCJ2ZXJpZnkiLCJwdWJsaWNLZXkiLCJkZXJpdmUiLCJwcml2YXRlS2V5QSIsInB1YmxpY0tleUIiLCJrZXlBIiwia2V5QiIsImtleUZyb21QdWJsaWMiLCJQeCIsInRvQXJyYXkiLCJkZXJpdmVVbnBhZGRlZCIsImRlcml2ZVBhZGRlZCIsInRvU3RyaW5nIiwiZW5jcnlwdCIsInB1YmxpY0tleVRvIiwib3B0cyIsImVwaGVtUHJpdmF0ZUtleSIsImVwaGVtUHVibGljS2V5IiwiZW5jcnlwdGlvbktleSIsInNsaWNlIiwibWFjS2V5IiwiY2lwaGVydGV4dCIsImRhdGFUb01hYyIsIm1hYyIsImRlY3J5cHQiLCJfcGFkZGluZyIsInBhZGRpbmciLCJkZXJpdmVMb2NhbCIsIm1hY0dvb2QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAPIKey: () => (/* binding */ clearAPIKey),\n/* harmony export */   clearEmbedHost: () => (/* binding */ clearEmbedHost),\n/* harmony export */   enableSentryTracing: () => (/* binding */ enableSentryTracing),\n/* harmony export */   gatewayAuthHeader: () => (/* binding */ gatewayAuthHeader),\n/* harmony export */   gatewayEmbedHostHeader: () => (/* binding */ gatewayEmbedHostHeader),\n/* harmony export */   generateJsonRPCObject: () => (/* binding */ generateJsonRPCObject),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAPIKey: () => (/* binding */ getAPIKey),\n/* harmony export */   getEmbedHost: () => (/* binding */ getEmbedHost),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   promiseRace: () => (/* binding */ promiseRace),\n/* harmony export */   promiseTimeout: () => (/* binding */ promiseTimeout),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   setAPIKey: () => (/* binding */ setAPIKey),\n/* harmony export */   setEmbedHost: () => (/* binding */ setEmbedHost),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.merge */ \"(ssr)/./node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\";\n// #region API Keys\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n    sentry = _sentry;\n    tracingOrigins.push(..._tracingOrigins);\n    tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n    embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n    embedHost = \"\";\n}\nfunction getEmbedHost() {\n    return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n    apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n    apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n    return apiKey;\n}\n// #endregion\nfunction setLogLevel(level) {\n    log.setLevel(level);\n}\nasync function fetchAndTrace(url, init) {\n    let _url = null;\n    try {\n        _url = new URL(url);\n    } catch (error) {}\n    if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n        const transaction = sentry.startTransaction({\n            name: url\n        });\n        const span = transaction.startChild({\n            op: \"http\"\n        }); // This function returns a Span\n        const response = await fetch(url, init);\n        span.finish(); // Remember that only finished spans will be sent with the transaction\n        transaction.finish(); // Finishing the transaction will send it to Sentry\n        return response;\n    }\n    return fetch(url, init);\n}\nfunction getApiKeyHeaders() {\n    const headers = {};\n    if (apiKey) headers[gatewayAuthHeader] = apiKey;\n    if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n    return headers;\n}\nfunction debugLogResponse(response) {\n    log.info(`Response: ${response.status} ${response.statusText}`);\n    log.info(`Url: ${response.url}`);\n}\nfunction logTracingHeader(response) {\n    const tracingHeader = response.headers.get(\"x-web3-correlation-id\");\n    if (tracingHeader) log.info(`Request tracing with traceID = ${tracingHeader}`);\n}\nconst promiseTimeout = async (ms, promise)=>{\n    let timeoutFunc = null;\n    try {\n        const timeout = new Promise((_resolve, reject)=>{\n            timeoutFunc = setTimeout(()=>{\n                reject(new Error(`Timed out in ${ms}ms`));\n            }, ms);\n        });\n        const result = await Promise.race([\n            promise,\n            timeout\n        ]);\n        // promise.race will return the first resolved promise\n        // then we clear the timeout\n        if (timeoutFunc != null) {\n            clearTimeout(timeoutFunc);\n        }\n        return result;\n    } catch (err) {\n        // clear the timeout\n        if (timeoutFunc != null) {\n            clearTimeout(timeoutFunc);\n        }\n        // rethrow the original error\n        throw err;\n    }\n};\nconst get = async function(url) {\n    let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {}\n    };\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"GET\"\n    });\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst post = function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"POST\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then((response)=>{\n        if (customOptions.logTracingHeader) {\n            logTracingHeader(response);\n        }\n        if (response.ok) {\n            const responseContentType = response.headers.get(\"content-type\");\n            if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n                return response.json();\n            }\n            return response.text();\n        }\n        debugLogResponse(response);\n        throw response;\n    }));\n};\nconst patch = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"PATCH\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst put = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"PUT\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst remove = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"DELETE\"\n    });\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst generateJsonRPCObject = (method, parameters)=>({\n        jsonrpc: \"2.0\",\n        method,\n        id: 10,\n        params: parameters\n    });\nconst promiseRace = function(url, options) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n    return Promise.race([\n        get(url, options),\n        new Promise((_resolve, reject)=>{\n            setTimeout(()=>{\n                reject(new Error(\"timed out\"));\n            }, timeout);\n        })\n    ]);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9odHRwSGVscGVycy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ2hDO0FBQ1c7QUFFNUMsTUFBTUksTUFBTUYseURBQWtCLENBQUM7QUFDL0JFLElBQUlFLFFBQVEsQ0FBQ0gsNENBQU1BLENBQUNJLElBQUk7QUFDeEIsSUFBSUMsU0FBUztBQUNiLElBQUlDLFlBQVk7QUFFaEIsbUJBQW1CO0FBQ25CLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQyx5QkFBeUI7QUFDL0IsSUFBSUMsU0FBUztBQUNiLE1BQU1DLGlCQUFpQixFQUFFO0FBQ3pCLE1BQU1DLGVBQWUsRUFBRTtBQUN2QixTQUFTQyxvQkFBb0JDLE9BQU8sRUFBRUMsZUFBZSxFQUFFQyxhQUFhO0lBQ2xFTixTQUFTSTtJQUNUSCxlQUFlTSxJQUFJLElBQUlGO0lBQ3ZCSCxhQUFhSyxJQUFJLElBQUlEO0FBQ3ZCO0FBQ0EsU0FBU0UsYUFBYUMsVUFBVTtJQUM5QlosWUFBWVk7QUFDZDtBQUNBLFNBQVNDO0lBQ1BiLFlBQVk7QUFDZDtBQUNBLFNBQVNjO0lBQ1AsT0FBT2Q7QUFDVDtBQUNBLFNBQVNlLFVBQVVDLE9BQU87SUFDeEJqQixTQUFTaUI7QUFDWDtBQUNBLFNBQVNDO0lBQ1BsQixTQUFTO0FBQ1g7QUFDQSxTQUFTbUI7SUFDUCxPQUFPbkI7QUFDVDtBQUVBLGFBQWE7QUFFYixTQUFTb0IsWUFBWUMsS0FBSztJQUN4QnpCLElBQUlFLFFBQVEsQ0FBQ3VCO0FBQ2Y7QUFDQSxlQUFlQyxjQUFjQyxHQUFHLEVBQUVDLElBQUk7SUFDcEMsSUFBSUMsT0FBTztJQUNYLElBQUk7UUFDRkEsT0FBTyxJQUFJQyxJQUFJSDtJQUNqQixFQUFFLE9BQU9JLE9BQU8sQ0FBQztJQUNqQixJQUFJdkIsVUFBVXFCLFFBQVNwQixDQUFBQSxlQUFldUIsUUFBUSxDQUFDSCxLQUFL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R0FBRyxDQUFDO1FBQ2pELElBQUkwQix3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssS0FBS0Esb0JBQW9COUMsUUFBUSxDQUFDLHFCQUFxQjtZQUN0SCxPQUFPUyxTQUFTc0MsSUFBSTtRQUN0QjtRQUNBLE9BQU90QyxTQUFTdUMsSUFBSTtJQUN0QjtJQUNBbEMsaUJBQWlCTDtJQUNqQixNQUFNQTtBQUNSO0FBQ0EsTUFBTWtELHdCQUF3QixDQUFDZixRQUFRZ0IsYUFBZ0I7UUFDckRDLFNBQVM7UUFDVGpCO1FBQ0FrQixJQUFJO1FBQ0pDLFFBQVFIO0lBQ1Y7QUFDQSxNQUFNSSxjQUFjLFNBQVVyRSxHQUFHLEVBQUVnRCxPQUFPO0lBQ3hDLElBQUlsQixVQUFVVyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNsRixPQUFPVixRQUFRTSxJQUFJLENBQUM7UUFBQ1osSUFBSXpCLEtBQUtnRDtRQUFVLElBQUlqQixRQUFRLENBQUNDLFVBQVVDO1lBQzdEQyxXQUFXO2dCQUNURCxPQUFPLElBQUlFLE1BQU07WUFDbkIsR0FBR0w7UUFDTDtLQUFHO0FBQ0w7QUFFeVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2x6enQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9odHRwSGVscGVycy5lc20uanM/NDYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC5tZXJnZSc7XG5pbXBvcnQgbG9nTGV2ZWwsIHsgbGV2ZWxzIH0gZnJvbSAnbG9nbGV2ZWwnO1xuXG5jb25zdCBsb2cgPSBsb2dMZXZlbC5nZXRMb2dnZXIoXCJodHRwLWhlbHBlcnNcIik7XG5sb2cuc2V0TGV2ZWwobGV2ZWxzLklORk8pO1xubGV0IGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiO1xubGV0IGVtYmVkSG9zdCA9IFwiXCI7XG5cbi8vICNyZWdpb24gQVBJIEtleXNcbmNvbnN0IGdhdGV3YXlBdXRoSGVhZGVyID0gXCJ4LWFwaS1rZXlcIjtcbmNvbnN0IGdhdGV3YXlFbWJlZEhvc3RIZWFkZXIgPSBcIngtZW1iZWQtaG9zdFwiO1xubGV0IHNlbnRyeSA9IG51bGw7XG5jb25zdCB0cmFjaW5nT3JpZ2lucyA9IFtdO1xuY29uc3QgdHJhY2luZ1BhdGhzID0gW107XG5mdW5jdGlvbiBlbmFibGVTZW50cnlUcmFjaW5nKF9zZW50cnksIF90cmFjaW5nT3JpZ2lucywgX3RyYWNpbmdQYXRocykge1xuICBzZW50cnkgPSBfc2VudHJ5O1xuICB0cmFjaW5nT3JpZ2lucy5wdXNoKC4uLl90cmFjaW5nT3JpZ2lucyk7XG4gIHRyYWNpbmdQYXRocy5wdXNoKC4uLl90cmFjaW5nUGF0aHMpO1xufVxuZnVuY3Rpb24gc2V0RW1iZWRIb3N0KGVtYmVkSG9zdF8pIHtcbiAgZW1iZWRIb3N0ID0gZW1iZWRIb3N0Xztcbn1cbmZ1bmN0aW9uIGNsZWFyRW1iZWRIb3N0KCkge1xuICBlbWJlZEhvc3QgPSBcIlwiO1xufVxuZnVuY3Rpb24gZ2V0RW1iZWRIb3N0KCkge1xuICByZXR1cm4gZW1iZWRIb3N0O1xufVxuZnVuY3Rpb24gc2V0QVBJS2V5KGFwaUtleV8pIHtcbiAgYXBpS2V5ID0gYXBpS2V5Xztcbn1cbmZ1bmN0aW9uIGNsZWFyQVBJS2V5KCkge1xuICBhcGlLZXkgPSBcInRvcnVzLWRlZmF1bHRcIjtcbn1cbmZ1bmN0aW9uIGdldEFQSUtleSgpIHtcbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xuICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRUcmFjZSh1cmwsIGluaXQpIHtcbiAgbGV0IF91cmwgPSBudWxsO1xuICB0cnkge1xuICAgIF91cmwgPSBuZXcgVVJMKHVybCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICBpZiAoc2VudHJ5ICYmIF91cmwgJiYgKHRyYWNpbmdPcmlnaW5zLmluY2x1ZGVzKF91cmwub3JpZ2luKSB8fCB0cmFjaW5nUGF0aHMuaW5jbHVkZXMoX3VybC5wYXRobmFtZSkpKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBzZW50cnkuc3RhcnRUcmFuc2FjdGlvbih7XG4gICAgICBuYW1lOiB1cmxcbiAgICB9KTtcbiAgICBjb25zdCBzcGFuID0gdHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICBvcDogXCJodHRwXCJcbiAgICB9KTsgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgU3BhblxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIGluaXQpO1xuICAgIHNwYW4uZmluaXNoKCk7IC8vIFJlbWVtYmVyIHRoYXQgb25seSBmaW5pc2hlZCBzcGFucyB3aWxsIGJlIHNlbnQgd2l0aCB0aGUgdHJhbnNhY3Rpb25cblxuICAgIHRyYW5zYWN0aW9uLmZpbmlzaCgpOyAvLyBGaW5pc2hpbmcgdGhlIHRyYW5zYWN0aW9uIHdpbGwgc2VuZCBpdCB0byBTZW50cnlcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICByZXR1cm4gZmV0Y2godXJsLCBpbml0KTtcbn1cbmZ1bmN0aW9uIGdldEFwaUtleUhlYWRlcnMoKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGFwaUtleSkgaGVhZGVyc1tnYXRld2F5QXV0aEhlYWRlcl0gPSBhcGlLZXk7XG4gIGlmIChlbWJlZEhvc3QpIGhlYWRlcnNbZ2F0ZXdheUVtYmVkSG9zdEhlYWRlcl0gPSBlbWJlZEhvc3Q7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSkge1xuICBsb2cuaW5mbyhgUmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gIGxvZy5pbmZvKGBVcmw6ICR7cmVzcG9uc2UudXJsfWApO1xufVxuZnVuY3Rpb24gbG9nVHJhY2luZ0hlYWRlcihyZXNwb25zZSkge1xuICBjb25zdCB0cmFjaW5nSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LXdlYjMtY29ycmVsYXRpb24taWRcIik7XG4gIGlmICh0cmFjaW5nSGVhZGVyKSBsb2cuaW5mbyhgUmVxdWVzdCB0cmFjaW5nIHdpdGggdHJhY2VJRCA9ICR7dHJhY2luZ0hlYWRlcn1gKTtcbn1cbmNvbnN0IHByb21pc2VUaW1lb3V0ID0gYXN5bmMgKG1zLCBwcm9taXNlKSA9PiB7XG4gIGxldCB0aW1lb3V0RnVuYyA9IG51bGw7XG4gIHRyeSB7XG4gICAgY29uc3QgdGltZW91dCA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aW1lb3V0RnVuYyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBUaW1lZCBvdXQgaW4gJHttc31tc2ApKTtcbiAgICAgIH0sIG1zKTtcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRdKTtcbiAgICAvLyBwcm9taXNlLnJhY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2VcbiAgICAvLyB0aGVuIHdlIGNsZWFyIHRoZSB0aW1lb3V0XG4gICAgaWYgKHRpbWVvdXRGdW5jICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0RnVuYyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGNsZWFyIHRoZSB0aW1lb3V0XG4gICAgaWYgKHRpbWVvdXRGdW5jICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0RnVuYyk7XG4gICAgfVxuICAgIC8vIHJldGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuY29uc3QgZ2V0ID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHt9XG4gIH07XG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiR0VUXCJcbiAgfSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBwb3N0ID0gZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiXG4gIH0pO1xuXG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZVRpbWVvdXQoY3VzdG9tT3B0aW9ucy50aW1lb3V0IHx8IDYwMDAwLCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgaWYgKGN1c3RvbU9wdGlvbnMubG9nVHJhY2luZ0hlYWRlcikge1xuICAgICAgbG9nVHJhY2luZ0hlYWRlcihyZXNwb25zZSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH1cbiAgICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB0aHJvdyByZXNwb25zZTtcbiAgfSkpO1xufTtcbmNvbnN0IHBhdGNoID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiUEFUQ0hcIlxuICB9KTtcbiAgLy8gZGVlcCBtZXJnZSBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgZm9ybSBkYXRhIGFuZCB1cmwgZW5jb2RlZCBkYXRhICxcbiAgLy8gc28gd2Ugc2hvdWxkIG5vdCBkZWVwbWVyZ2UgYm9keSBkYXRhXG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBwdXQgPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJQVVRcIlxuICB9KTtcbiAgLy8gZGVlcCBtZXJnZSBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgZm9ybSBkYXRhIGFuZCB1cmwgZW5jb2RlZCBkYXRhICxcbiAgLy8gc28gd2Ugc2hvdWxkIG5vdCBkZWVwbWVyZ2UgYm9keSBkYXRhXG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCByZW1vdmUgPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICB9KTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IGdlbmVyYXRlSnNvblJQQ09iamVjdCA9IChtZXRob2QsIHBhcmFtZXRlcnMpID0+ICh7XG4gIGpzb25ycGM6IFwiMi4wXCIsXG4gIG1ldGhvZCxcbiAgaWQ6IDEwLFxuICBwYXJhbXM6IHBhcmFtZXRlcnNcbn0pO1xuY29uc3QgcHJvbWlzZVJhY2UgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA2MDAwMDtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbZ2V0KHVybCwgb3B0aW9ucyksIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwidGltZWQgb3V0XCIpKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfSldKTtcbn07XG5cbmV4cG9ydCB7IGNsZWFyQVBJS2V5LCBjbGVhckVtYmVkSG9zdCwgZW5hYmxlU2VudHJ5VHJhY2luZywgZ2F0ZXdheUF1dGhIZWFkZXIsIGdhdGV3YXlFbWJlZEhvc3RIZWFkZXIsIGdlbmVyYXRlSnNvblJQQ09iamVjdCwgZ2V0LCBnZXRBUElLZXksIGdldEVtYmVkSG9zdCwgcGF0Y2gsIHBvc3QsIHByb21pc2VSYWNlLCBwcm9taXNlVGltZW91dCwgcHV0LCByZW1vdmUsIHNldEFQSUtleSwgc2V0RW1iZWRIb3N0LCBzZXRMb2dMZXZlbCB9O1xuIl0sIm5hbWVzIjpbIl9vYmplY3RTcHJlYWQiLCJtZXJnZSIsImxvZ0xldmVsIiwibGV2ZWxzIiwibG9nIiwiZ2V0TG9nZ2VyIiwic2V0TGV2ZWwiLCJJTkZPIiwiYXBpS2V5IiwiZW1iZWRIb3N0IiwiZ2F0ZXdheUF1dGhIZWFkZXIiLCJnYXRld2F5RW1iZWRIb3N0SGVhZGVyIiwic2VudHJ5IiwidHJhY2luZ09yaWdpbnMiLCJ0cmFjaW5nUGF0aHMiLCJlbmFibGVTZW50cnlUcmFjaW5nIiwiX3NlbnRyeSIsIl90cmFjaW5nT3JpZ2lucyIsIl90cmFjaW5nUGF0aHMiLCJwdXNoIiwic2V0RW1iZWRIb3N0IiwiZW1iZWRIb3N0XyIsImNsZWFyRW1iZWRIb3N0IiwiZ2V0RW1iZWRIb3N0Iiwic2V0QVBJS2V5IiwiYXBpS2V5XyIsImNsZWFyQVBJS2V5IiwiZ2V0QVBJS2V5Iiwic2V0TG9nTGV2ZWwiLCJsZXZlbCIsImZldGNoQW5kVHJhY2UiLCJ1cmwiLCJpbml0IiwiX3VybCIsIlVSTCIsImVycm9yIiwiaW5jbHVkZXMiLCJvcmlnaW4iLCJwYXRobmFtZSIsInRyYW5zYWN0aW9uIiwic3RhcnRUcmFuc2FjdGlvbiIsIm5hbWUiLCJzcGFuIiwic3RhcnRDaGlsZCIsIm9wIiwicmVzcG9uc2UiLCJmZXRjaCIsImZpbmlzaCIsImdldEFwaUtleUhlYWRlcnMiLCJoZWFkZXJzIiwiZGVidWdMb2dSZXNwb25zZSIsImluZm8iLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwibG9nVHJhY2luZ0hlYWRlciIsInRyYWNpbmdIZWFkZXIiLCJnZXQiLCJwcm9taXNlVGltZW91dCIsIm1zIiwicHJvbWlzZSIsInRpbWVvdXRGdW5jIiwidGltZW91dCIsIlByb21pc2UiLCJfcmVzb2x2ZSIsInJlamVjdCIsInNldFRpbWVvdXQiLCJFcnJvciIsInJlc3VsdCIsInJhY2UiLCJjbGVhclRpbWVvdXQiLCJlcnIiLCJvcHRpb25zXyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImN1c3RvbU9wdGlvbnMiLCJkZWZhdWx0T3B0aW9ucyIsIm1vZGUiLCJ1c2VBUElLZXkiLCJvcHRpb25zIiwibWV0aG9kIiwib2siLCJyZXNwb25zZUNvbnRlbnRUeXBlIiwianNvbiIsInRleHQiLCJwb3N0IiwiZGF0YSIsImlzVXJsRW5jb2RlZERhdGEiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInRoZW4iLCJwYXRjaCIsInB1dCIsInJlbW92ZSIsImdlbmVyYXRlSnNvblJQQ09iamVjdCIsInBhcmFtZXRlcnMiLCJqc29ucnBjIiwiaWQiLCJwYXJhbXMiLCJwcm9taXNlUmFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptData: () => (/* binding */ decryptData),\n/* harmony export */   \"default\": () => (/* binding */ MetadataStorageLayer),\n/* harmony export */   ec: () => (/* binding */ ec),\n/* harmony export */   encParamsBufToHex: () => (/* binding */ encParamsBufToHex),\n/* harmony export */   encParamsHexToBuf: () => (/* binding */ encParamsHexToBuf),\n/* harmony export */   encryptAndSetData: () => (/* binding */ encryptAndSetData),\n/* harmony export */   encryptData: () => (/* binding */ encryptData),\n/* harmony export */   getAndDecryptData: () => (/* binding */ getAndDecryptData),\n/* harmony export */   getDeviceShare: () => (/* binding */ getDeviceShare),\n/* harmony export */   getTorusShare: () => (/* binding */ getTorusShare),\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   setDeviceShare: () => (/* binding */ setDeviceShare),\n/* harmony export */   setTorusShare: () => (/* binding */ setTorusShare)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! json-stable-stringify */ \"(ssr)/./node_modules/json-stable-stringify/index.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/esm/keccak.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n\n\n\n\n\n\n\nfunction keccak256(a) {\n    return Buffer.from((0,ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__.keccak256)(a));\n}\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_4__.ec(\"secp256k1\");\nclass MetadataStorageLayer {\n    // ms\n    constructor(){\n        let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n        let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"metadataHost\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"serverTimeOffset\", void 0);\n        this.metadataHost = metadataHost;\n        this.serverTimeOffset = serverTimeOffset;\n    }\n    static setAPIKey(apiKey) {\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setAPIKey)(apiKey);\n    }\n    static setEmbedHost(embedHost) {\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setEmbedHost)(embedHost);\n    }\n    generateMetadataParams(message, privateKeyHex) {\n        var _sig$recoveryParam$to, _sig$recoveryParam;\n        const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n        const setData = {\n            data: message,\n            timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n        };\n        const sig = key.sign(keccak256(Buffer.from(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(setData), \"utf8\")));\n        return {\n            pub_key_X: key.getPublic().getX().toString(16, 64),\n            pub_key_Y: key.getPublic().getY().toString(16, 64),\n            set_data: setData,\n            signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam$to = (_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2)) !== null && _sig$recoveryParam$to !== void 0 ? _sig$recoveryParam$to : \"00\"), \"hex\").toString(\"base64\")\n        };\n    }\n    generatePubKeyParams(privateKeyHex) {\n        const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n        return {\n            pub_key_X: key.getPublic().getX().toString(16, 64),\n            pub_key_Y: key.getPublic().getY().toString(16, 64)\n        };\n    }\n    async setMetadata(data, namespace, options) {\n        const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, data), {}, {\n            namespace\n        }) : data;\n        const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/set`, params, options, {\n            useAPIKey: true\n        });\n        return metadataResponse.message;\n    }\n    async getMetadata(pubKey, namespace, options) {\n        const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, pubKey), {}, {\n            namespace\n        }) : pubKey;\n        const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/get`, params, options, {\n            useAPIKey: true\n        });\n        return metadataResponse.message;\n    }\n}\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n    return {\n        iv: Buffer.from(encParamsHex.iv, \"hex\"),\n        ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n        ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n        mac: Buffer.from(encParamsHex.mac, \"hex\")\n    };\n}\nfunction encParamsBufToHex(encParams) {\n    return {\n        iv: Buffer.from(encParams.iv).toString(\"hex\"),\n        ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n        ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n        mac: Buffer.from(encParams.mac).toString(\"hex\")\n    };\n}\nasync function encryptData(privKeyHex, d) {\n    const serializedDec = JSON.stringify(d);\n    const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n    const encParams = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)((0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.getPublic)(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n    const encParamsHex = encParamsBufToHex(encParams);\n    const sData = JSON.stringify(encParamsHex);\n    return sData;\n}\nasync function decryptData(privKeyHex, d) {\n    const encParamsHex = JSON.parse(d);\n    const encParams = encParamsHexToBuf(encParamsHex);\n    const keyPair = ec.keyFromPrivate(privKeyHex);\n    const serializedBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n    const serializedDec = serializedBuf.toString(\"utf-8\");\n    const data = JSON.parse(serializedDec);\n    return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n    const keyPair = ec.keyFromPrivate(privKeyHex, \"hex\");\n    const pubKey = keyPair.getPublic();\n    const serializedData = await m.getMetadata({\n        pub_key_X: pubKey.getX().toString(16, 64),\n        pub_key_Y: pubKey.getY().toString(16, 64)\n    }, namespace);\n    if (!serializedData) {\n        return null;\n    }\n    const data = await decryptData(privKeyHex, serializedData);\n    return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n    const sData = await encryptData(privKeyHex, d);\n    const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n    await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n    const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n    const privKey = refKeyPair.getPrivate();\n    const pubKey = ec.keyFromPublic({\n        x: webAuthnPubKey.pub_key_X,\n        y: webAuthnPubKey.pub_key_Y\n    });\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n    let d = {};\n    if (data) d = data;\n    const serializedSubspaceData = JSON.stringify(subspaceData);\n    const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n    const encSubspaceData = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n    const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n    d[subspace] = encSubspaceDataHex;\n    await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n    const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n    const privKey = keyPair.getPrivate();\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n    let d = {};\n    if (data) d = data;\n    d[subspace] = subspaceData;\n    await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n    if (!data) return null;\n    const encParamsHex = data[subspace];\n    if (!encParamsHex) return null;\n    const encParams = encParamsHexToBuf(encParamsHex);\n    const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n    const privKey = keyPair.getPrivate();\n    const serializedSubspaceDataBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n    const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n    const subspaceData = JSON.parse(serializedSubspaceData);\n    return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n    if (data) return data[subspace];\n    return null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzL2Rpc3QvbWV0YWRhdGFIZWxwZXJzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDRztBQUNJO0FBQzFCO0FBQ1I7QUFDa0M7QUFDTjtBQUVsRSxTQUFTUSxVQUFVSyxDQUFDO0lBQ2xCLE9BQU9DLE9BQU9DLElBQUksQ0FBQ04sdUVBQVdBLENBQUNJO0FBQ2pDO0FBQ0EsTUFBTVAsS0FBSyxJQUFJQyx3Q0FBSUEsQ0FBQztBQUVwQixNQUFNUztJQUNKLEtBQUs7SUFFTEMsYUFBYztRQUNaLElBQUlDLGVBQWVDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3ZGLElBQUlHLG1CQUFtQkgsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDM0ZsQiw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEtBQUs7UUFDM0NBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxvQkFBb0IsS0FBSztRQUMvQyxJQUFJLENBQUNpQixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUdBO0lBQzFCO0lBQ0EsT0FBT3BCLFVBQVVxQixNQUFNLEVBQUU7UUFDdkJyQixrRUFBU0EsQ0FBQ3FCO0lBQ1o7SUFDQSxPQUFPcEIsYUFBYXFCLFNBQVMsRUFBRTtRQUM3QnJCLHFFQUFZQSxDQUFDcUI7SUFDZjtJQUNBQyx1QkFBdUJDLE9BQU8sRUFBRUMsYUFBYSxFQUFFO1FBQzdDLElBQUlDLHVCQUF1QkM7UUFDM0IsTUFBTUMsTUFBTXhCLEdBQUd5QixjQUFjLENBQUNKLGVBQWU7UUFDN0MsTUFBTUssVUFBVTtZQUNkQyxNQUFNUDtZQUNOUSxXQUFXQyxLQUFLQyxLQUFLLENB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QUFNcUQsZUFBZWhCLEtBQUtJLEtBQUssQ0FBQ2tCO0lBQ2hDLE9BQU9OO0FBQ1Q7QUFDQSxlQUFlYSxlQUFlckIsQ0FBQyxFQUFFTSxjQUFjLEVBQUVDLFFBQVE7SUFDdkQsTUFBTTFELE9BQU8sTUFBTWtELGtCQUFrQkMsR0FBR00sZ0JBQWdCM0I7SUFDeEQsSUFBSTlCLE1BQU0sT0FBT0EsSUFBSSxDQUFDMEQsU0FBUztJQUMvQixPQUFPO0FBQ1Q7QUFFOE4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2x6enQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzL2Rpc3QvbWV0YWRhdGFIZWxwZXJzLmVzbS5qcz80NWI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgc2V0QVBJS2V5LCBzZXRFbWJlZEhvc3QsIHBvc3QgfSBmcm9tICdAdG9ydXNsYWJzL2h0dHAtaGVscGVycyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJ2pzb24tc3RhYmxlLXN0cmluZ2lmeSc7XG5pbXBvcnQgeyBlYyBhcyBlYyQxIH0gZnJvbSAnZWxsaXB0aWMnO1xuaW1wb3J0IHsga2VjY2FrMjU2IGFzIGtlY2NhazI1NiQxIH0gZnJvbSAnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhayc7XG5pbXBvcnQgeyBlbmNyeXB0LCBnZXRQdWJsaWMsIGRlY3J5cHQgfSBmcm9tICdAdG9ydXNsYWJzL2VjY3J5cHRvJztcblxuZnVuY3Rpb24ga2VjY2FrMjU2KGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGtlY2NhazI1NiQxKGEpKTtcbn1cbmNvbnN0IGVjID0gbmV3IGVjJDEoXCJzZWNwMjU2azFcIik7XG5cbmNsYXNzIE1ldGFkYXRhU3RvcmFnZUxheWVyIHtcbiAgLy8gbXNcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgbWV0YWRhdGFIb3N0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcImh0dHBzOi8vbWV0YWRhdGEudG9yLnVzXCI7XG4gICAgbGV0IHNlcnZlclRpbWVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFIb3N0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2VydmVyVGltZU9mZnNldFwiLCB2b2lkIDApO1xuICAgIHRoaXMubWV0YWRhdGFIb3N0ID0gbWV0YWRhdGFIb3N0O1xuICAgIHRoaXMuc2VydmVyVGltZU9mZnNldCA9IHNlcnZlclRpbWVPZmZzZXQ7XG4gIH1cbiAgc3RhdGljIHNldEFQSUtleShhcGlLZXkpIHtcbiAgICBzZXRBUElLZXkoYXBpS2V5KTtcbiAgfVxuICBzdGF0aWMgc2V0RW1iZWRIb3N0KGVtYmVkSG9zdCkge1xuICAgIHNldEVtYmVkSG9zdChlbWJlZEhvc3QpO1xuICB9XG4gIGdlbmVyYXRlTWV0YWRhdGFQYXJhbXMobWVzc2FnZSwgcHJpdmF0ZUtleUhleCkge1xuICAgIHZhciBfc2lnJHJlY292ZXJ5UGFyYW0kdG8sIF9zaWckcmVjb3ZlcnlQYXJhbTtcbiAgICBjb25zdCBrZXkgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5SGV4LCBcImhleFwiKTtcbiAgICBjb25zdCBzZXREYXRhID0ge1xuICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcih0aGlzLnNlcnZlclRpbWVPZmZzZXQgKyBEYXRlLm5vdygpIC8gMTAwMCkudG9TdHJpbmcoMTYpXG4gICAgfTtcbiAgICBjb25zdCBzaWcgPSBrZXkuc2lnbihrZWNjYWsyNTYoQnVmZmVyLmZyb20oc3RyaW5naWZ5KHNldERhdGEpLCBcInV0ZjhcIikpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViX2tleV9YOiBrZXkuZ2V0UHVibGljKCkuZ2V0WCgpLnRvU3RyaW5nKDE2LCA2NCksXG4gICAgICBwdWJfa2V5X1k6IGtleS5nZXRQdWJsaWMoKS5nZXRZKCkudG9TdHJpbmcoMTYsIDY0KSxcbiAgICAgIHNldF9kYXRhOiBzZXREYXRhLFxuICAgICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcuci50b1N0cmluZygxNiwgNjQpICsgc2lnLnMudG9TdHJpbmcoMTYsIDY0KSArICgoX3NpZyRyZWNvdmVyeVBhcmFtJHRvID0gKF9zaWckcmVjb3ZlcnlQYXJhbSA9IHNpZy5yZWNvdmVyeVBhcmFtKSA9PT0gbnVsbCB8fCBfc2lnJHJlY292ZXJ5UGFyYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zaWckcmVjb3ZlcnlQYXJhbS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLnNsaWNlKC0yKSkgIT09IG51bGwgJiYgX3NpZyRyZWNvdmVyeVBhcmFtJHRvICE9PSB2b2lkIDAgPyBfc2lnJHJlY292ZXJ5UGFyYW0kdG8gOiBcIjAwXCIpLCBcImhleFwiKS50b1N0cmluZyhcImJhc2U2NFwiKVxuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVQdWJLZXlQYXJhbXMocHJpdmF0ZUtleUhleCkge1xuICAgIGNvbnN0IGtleSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlIZXgsIFwiaGV4XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWJfa2V5X1g6IGtleS5nZXRQdWJsaWMoKS5nZXRYKCkudG9TdHJpbmcoMTYsIDY0KSxcbiAgICAgIHB1Yl9rZXlfWToga2V5LmdldFB1YmxpYygpLmdldFkoKS50b1N0cmluZygxNiwgNjQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBzZXRNZXRhZGF0YShkYXRhLCBuYW1lc3BhY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuYW1lc3BhY2UgIT09IG51bGwgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRhdGEpLCB7fSwge1xuICAgICAgbmFtZXNwYWNlXG4gICAgfSkgOiBkYXRhO1xuICAgIGNvbnN0IG1ldGFkYXRhUmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMubWV0YWRhdGFIb3N0fS9zZXRgLCBwYXJhbXMsIG9wdGlvbnMsIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRhZGF0YVJlc3BvbnNlLm1lc3NhZ2U7XG4gIH1cbiAgYXN5bmMgZ2V0TWV0YWRhdGEocHViS2V5LCBuYW1lc3BhY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuYW1lc3BhY2UgIT09IG51bGwgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHB1YktleSksIHt9LCB7XG4gICAgICBuYW1lc3BhY2VcbiAgICB9KSA6IHB1YktleTtcbiAgICBjb25zdCBtZXRhZGF0YVJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLm1ldGFkYXRhSG9zdH0vZ2V0YCwgcGFyYW1zLCBvcHRpb25zLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0YWRhdGFSZXNwb25zZS5tZXNzYWdlO1xuICB9XG59XG5cbmNvbnN0IFdFQkFVVEhOX1RPUlVTX1NIQVJFID0gXCJ3ZWJhdXRobl90b3J1c19zaGFyZVwiO1xuY29uc3QgV0VCQVVUSE5fREVWSUNFX1NIQVJFID0gXCJ3ZWJhdXRobl9kZXZpY2Vfc2hhcmVcIjtcbmZ1bmN0aW9uIGVuY1BhcmFtc0hleFRvQnVmKGVuY1BhcmFtc0hleCkge1xuICByZXR1cm4ge1xuICAgIGl2OiBCdWZmZXIuZnJvbShlbmNQYXJhbXNIZXguaXYsIFwiaGV4XCIpLFxuICAgIGVwaGVtUHVibGljS2V5OiBCdWZmZXIuZnJvbShlbmNQYXJhbXNIZXguZXBoZW1QdWJsaWNLZXksIFwiaGV4XCIpLFxuICAgIGNpcGhlcnRleHQ6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtc0hleC5jaXBoZXJ0ZXh0LCBcImhleFwiKSxcbiAgICBtYWM6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtc0hleC5tYWMsIFwiaGV4XCIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNQYXJhbXNCdWZUb0hleChlbmNQYXJhbXMpIHtcbiAgcmV0dXJuIHtcbiAgICBpdjogQnVmZmVyLmZyb20oZW5jUGFyYW1zLml2KS50b1N0cmluZyhcImhleFwiKSxcbiAgICBlcGhlbVB1YmxpY0tleTogQnVmZmVyLmZyb20oZW5jUGFyYW1zLmVwaGVtUHVibGljS2V5KS50b1N0cmluZyhcImhleFwiKSxcbiAgICBjaXBoZXJ0ZXh0OiBCdWZmZXIuZnJvbShlbmNQYXJhbXMuY2lwaGVydGV4dCkudG9TdHJpbmcoXCJoZXhcIiksXG4gICAgbWFjOiBCdWZmZXIuZnJvbShlbmNQYXJhbXMubWFjKS50b1N0cmluZyhcImhleFwiKVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdERhdGEocHJpdktleUhleCwgZCkge1xuICBjb25zdCBzZXJpYWxpemVkRGVjID0gSlNPTi5zdHJpbmdpZnkoZCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRCdWYgPSBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGVjLCBcInV0Zi04XCIpO1xuICBjb25zdCBlbmNQYXJhbXMgPSBhd2FpdCBlbmNyeXB0KGdldFB1YmxpYyhCdWZmZXIuZnJvbShwcml2S2V5SGV4LCBcImhleFwiKSksIHNlcmlhbGl6ZWRCdWYpO1xuICBjb25zdCBlbmNQYXJhbXNIZXggPSBlbmNQYXJhbXNCdWZUb0hleChlbmNQYXJhbXMpO1xuICBjb25zdCBzRGF0YSA9IEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtc0hleCk7XG4gIHJldHVybiBzRGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHREYXRhKHByaXZLZXlIZXgsIGQpIHtcbiAgY29uc3QgZW5jUGFyYW1zSGV4ID0gSlNPTi5wYXJzZShkKTtcbiAgY29uc3QgZW5jUGFyYW1zID0gZW5jUGFyYW1zSGV4VG9CdWYoZW5jUGFyYW1zSGV4KTtcbiAgY29uc3Qga2V5UGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZLZXlIZXgpO1xuICBjb25zdCBzZXJpYWxpemVkQnVmID0gYXdhaXQgZGVjcnlwdChCdWZmZXIuZnJvbShrZXlQYWlyLmdldFByaXZhdGUoKS50b1N0cmluZyhcImhleFwiLCA2NCksIFwiaGV4XCIpLCBlbmNQYXJhbXMpO1xuICBjb25zdCBzZXJpYWxpemVkRGVjID0gc2VyaWFsaXplZEJ1Zi50b1N0cmluZyhcInV0Zi04XCIpO1xuICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkRGVjKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBbmREZWNyeXB0RGF0YShtLCBwcml2S2V5SGV4LCBuYW1lc3BhY2UpIHtcbiAgY29uc3Qga2V5UGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZLZXlIZXgsIFwiaGV4XCIpO1xuICBjb25zdCBwdWJLZXkgPSBrZXlQYWlyLmdldFB1YmxpYygpO1xuICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IGF3YWl0IG0uZ2V0TWV0YWRhdGEoe1xuICAgIHB1Yl9rZXlfWDogcHViS2V5LmdldFgoKS50b1N0cmluZygxNiwgNjQpLFxuICAgIHB1Yl9rZXlfWTogcHViS2V5LmdldFkoKS50b1N0cmluZygxNiwgNjQpXG4gIH0sIG5hbWVzcGFjZSk7XG4gIGlmICghc2VyaWFsaXplZERhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkYXRhID0gYXdhaXQgZGVjcnlwdERhdGEocHJpdktleUhleCwgc2VyaWFsaXplZERhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRBbmRTZXREYXRhKG0sIHByaXZLZXlIZXgsIGQsIG5hbWVzcGFjZSkge1xuICBjb25zdCBzRGF0YSA9IGF3YWl0IGVuY3J5cHREYXRhKHByaXZLZXlIZXgsIGQpO1xuICBjb25zdCBtZXRhZGF0YVBhcmFtcyA9IG0uZ2VuZXJhdGVNZXRhZGF0YVBhcmFtcyhzRGF0YSwgcHJpdktleUhleCk7XG4gIGF3YWl0IG0uc2V0TWV0YWRhdGEobWV0YWRhdGFQYXJhbXMsIG5hbWVzcGFjZSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZXRUb3J1c1NoYXJlKG0sIHdlYkF1dGhuUHViS2V5LCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UsIHN1YnNwYWNlRGF0YSkge1xuICBjb25zdCByZWZLZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUod2ViQXV0aG5SZWZIZXgpO1xuICBjb25zdCBwcml2S2V5ID0gcmVmS2V5UGFpci5nZXRQcml2YXRlKCk7XG4gIGNvbnN0IHB1YktleSA9IGVjLmtleUZyb21QdWJsaWMoe1xuICAgIHg6IHdlYkF1dGhuUHViS2V5LnB1Yl9rZXlfWCxcbiAgICB5OiB3ZWJBdXRoblB1YktleS5wdWJfa2V5X1lcbiAgfSk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fVE9SVVNfU0hBUkUpO1xuICBsZXQgZCA9IHt9O1xuICBpZiAoZGF0YSkgZCA9IGRhdGE7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGEgPSBKU09OLnN0cmluZ2lmeShzdWJzcGFjZURhdGEpO1xuICBjb25zdCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhQnVmID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZFN1YnNwYWNlRGF0YSwgXCJ1dGYtOFwiKTtcbiAgY29uc3QgZW5jU3Vic3BhY2VEYXRhID0gYXdhaXQgZW5jcnlwdChCdWZmZXIuZnJvbShwdWJLZXkuZ2V0UHVibGljKFwiaGV4XCIpLCBcImhleFwiKSwgc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1Zik7XG4gIGNvbnN0IGVuY1N1YnNwYWNlRGF0YUhleCA9IGVuY1BhcmFtc0J1ZlRvSGV4KGVuY1N1YnNwYWNlRGF0YSk7XG4gIGRbc3Vic3BhY2VdID0gZW5jU3Vic3BhY2VEYXRhSGV4O1xuICBhd2FpdCBlbmNyeXB0QW5kU2V0RGF0YShtLCBwcml2S2V5LnRvU3RyaW5nKFwiaGV4XCIsIDY0KSwgZCwgV0VCQVVUSE5fVE9SVVNfU0hBUkUpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0RGV2aWNlU2hhcmUobSwgd2ViQXV0aG5SZWZIZXgsIHN1YnNwYWNlLCBzdWJzcGFjZURhdGEpIHtcbiAgY29uc3Qga2V5UGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHdlYkF1dGhuUmVmSGV4KTtcbiAgY29uc3QgcHJpdktleSA9IGtleVBhaXIuZ2V0UHJpdmF0ZSgpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0QW5kRGVjcnlwdERhdGEobSwgd2ViQXV0aG5SZWZIZXgsIFdFQkFVVEhOX0RFVklDRV9TSEFSRSk7XG4gIGxldCBkID0ge307XG4gIGlmIChkYXRhKSBkID0gZGF0YTtcbiAgZFtzdWJzcGFjZV0gPSBzdWJzcGFjZURhdGE7XG4gIGF3YWl0IGVuY3J5cHRBbmRTZXREYXRhKG0sIHByaXZLZXkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBkLCBXRUJBVVRITl9ERVZJQ0VfU0hBUkUpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0VG9ydXNTaGFyZShtLCB3ZWJBdXRobktleUhleCwgd2ViQXV0aG5SZWZIZXgsIHN1YnNwYWNlKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fVE9SVVNfU0hBUkUpO1xuICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuICBjb25zdCBlbmNQYXJhbXNIZXggPSBkYXRhW3N1YnNwYWNlXTtcbiAgaWYgKCFlbmNQYXJhbXNIZXgpIHJldHVybiBudWxsO1xuICBjb25zdCBlbmNQYXJhbXMgPSBlbmNQYXJhbXNIZXhUb0J1ZihlbmNQYXJhbXNIZXgpO1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUod2ViQXV0aG5LZXlIZXgpO1xuICBjb25zdCBwcml2S2V5ID0ga2V5UGFpci5nZXRQcml2YXRlKCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYgPSBhd2FpdCBkZWNyeXB0KEJ1ZmZlci5mcm9tKHByaXZLZXkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBcImhleFwiKSwgZW5jUGFyYW1zKTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YSA9IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgY29uc3Qgc3Vic3BhY2VEYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkU3Vic3BhY2VEYXRhKTtcbiAgcmV0dXJuIHN1YnNwYWNlRGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldERldmljZVNoYXJlKG0sIHdlYkF1dGhuUmVmSGV4LCBzdWJzcGFjZSkge1xuICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0QW5kRGVjcnlwdERhdGEobSwgd2ViQXV0aG5SZWZIZXgsIFdFQkFVVEhOX0RFVklDRV9TSEFSRSk7XG4gIGlmIChkYXRhKSByZXR1cm4gZGF0YVtzdWJzcGFjZV07XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBkZWNyeXB0RGF0YSwgTWV0YWRhdGFTdG9yYWdlTGF5ZXIgYXMgZGVmYXVsdCwgZWMsIGVuY1BhcmFtc0J1ZlRvSGV4LCBlbmNQYXJhbXNIZXhUb0J1ZiwgZW5jcnlwdEFuZFNldERhdGEsIGVuY3J5cHREYXRhLCBnZXRBbmREZWNyeXB0RGF0YSwgZ2V0RGV2aWNlU2hhcmUsIGdldFRvcnVzU2hhcmUsIGtlY2NhazI1Niwgc2V0RGV2aWNlU2hhcmUsIHNldFRvcnVzU2hhcmUgfTtcbiJdLCJuYW1lcyI6WyJfb2JqZWN0U3ByZWFkIiwiX2RlZmluZVByb3BlcnR5Iiwic2V0QVBJS2V5Iiwic2V0RW1iZWRIb3N0IiwicG9zdCIsInN0cmluZ2lmeSIsImVjIiwiZWMkMSIsImtlY2NhazI1NiIsImtlY2NhazI1NiQxIiwiZW5jcnlwdCIsImdldFB1YmxpYyIsImRlY3J5cHQiLCJhIiwiQnVmZmVyIiwiZnJvbSIsIk1ldGFkYXRhU3RvcmFnZUxheWVyIiwiY29uc3RydWN0b3IiLCJtZXRhZGF0YUhvc3QiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJzZXJ2ZXJUaW1lT2Zmc2V0IiwiYXBpS2V5IiwiZW1iZWRIb3N0IiwiZ2VuZXJhdGVNZXRhZGF0YVBhcmFtcyIsIm1lc3NhZ2UiLCJwcml2YXRlS2V5SGV4IiwiX3NpZyRyZWNvdmVyeVBhcmFtJHRvIiwiX3NpZyRyZWNvdmVyeVBhcmFtIiwia2V5Iiwia2V5RnJvbVByaXZhdGUiLCJzZXREYXRhIiwiZGF0YSIsInRpbWVzdGFtcCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsInNpZyIsInNpZ24iLCJwdWJfa2V5X1giLCJnZXRYIiwicHViX2tleV9ZIiwiZ2V0WSIsInNldF9kYXRhIiwic2lnbmF0dXJlIiwiciIsInMiLCJyZWNvdmVyeVBhcmFtIiwicGFkU3RhcnQiLCJzbGljZSIsImdlbmVyYXRlUHViS2V5UGFyYW1zIiwic2V0TWV0YWRhdGEiLCJuYW1lc3BhY2UiLCJvcHRpb25zIiwicGFyYW1zIiwibWV0YWRhdGFSZXNwb25zZSIsInVzZUFQSUtleSIsImdldE1ldGFkYXRhIiwicHViS2V5IiwiV0VCQVVUSE5fVE9SVVNfU0hBUkUiLCJXRUJBVVRITl9ERVZJQ0VfU0hBUkUiLCJlbmNQYXJhbXNIZXhUb0J1ZiIsImVuY1BhcmFtc0hleCIsIml2IiwiZXBoZW1QdWJsaWNLZXkiLCJjaXBoZXJ0ZXh0IiwibWFjIiwiZW5jUGFyYW1zQnVmVG9IZXgiLCJlbmNQYXJhbXMiLCJlbmNyeXB0RGF0YSIsInByaXZLZXlIZXgiLCJkIiwic2VyaWFsaXplZERlYyIsIkpTT04iLCJzZXJpYWxpemVkQnVmIiwic0RhdGEiLCJkZWNyeXB0RGF0YSIsInBhcnNlIiwia2V5UGFpciIsImdldFByaXZhdGUiLCJnZXRBbmREZWNyeXB0RGF0YSIsIm0iLCJzZXJpYWxpemVkRGF0YSIsImVuY3J5cHRBbmRTZXREYXRhIiwibWV0YWRhdGFQYXJhbXMiLCJzZXRUb3J1c1NoYXJlIiwid2ViQXV0aG5QdWJLZXkiLCJ3ZWJBdXRoblJlZkhleCIsInN1YnNwYWNlIiwic3Vic3BhY2VEYXRhIiwicmVmS2V5UGFpciIsInByaXZLZXkiLCJrZXlGcm9tUHVibGljIiwieCIsInkiLCJzZXJpYWxpemVkU3Vic3BhY2VEYXRhIiwic2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1ZiIsImVuY1N1YnNwYWNlRGF0YSIsImVuY1N1YnNwYWNlRGF0YUhleCIsInNldERldmljZVNoYXJlIiwiZ2V0VG9ydXNTaGFyZSIsIndlYkF1dGhuS2V5SGV4IiwiZ2V0RGV2aWNlU2hhcmUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePostMessageStream: () => (/* binding */ BasePostMessageStream),\n/* harmony export */   EthereumProviderError: () => (/* binding */ EthereumProviderError),\n/* harmony export */   IGNORE_SUBSTREAM: () => (/* binding */ IGNORE_SUBSTREAM),\n/* harmony export */   JRPCEngine: () => (/* binding */ JRPCEngine),\n/* harmony export */   JSON_RPC_SERVER_ERROR_MESSAGE: () => (/* binding */ JSON_RPC_SERVER_ERROR_MESSAGE),\n/* harmony export */   JsonRpcError: () => (/* binding */ JsonRpcError),\n/* harmony export */   ObjectMultiplex: () => (/* binding */ ObjectMultiplex),\n/* harmony export */   PostMessageStream: () => (/* binding */ PostMessageStream),\n/* harmony export */   SafeEventEmitter: () => (/* binding */ SafeEventEmitter),\n/* harmony export */   SerializableError: () => (/* binding */ SerializableError),\n/* harmony export */   Substream: () => (/* binding */ Substream),\n/* harmony export */   createAsyncMiddleware: () => (/* binding */ createAsyncMiddleware),\n/* harmony export */   createEngineStream: () => (/* binding */ createEngineStream),\n/* harmony export */   createErrorMiddleware: () => (/* binding */ createErrorMiddleware),\n/* harmony export */   createIdRemapMiddleware: () => (/* binding */ createIdRemapMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createScaffoldMiddleware: () => (/* binding */ createScaffoldMiddleware),\n/* harmony export */   createStreamMiddleware: () => (/* binding */ createStreamMiddleware),\n/* harmony export */   dataHasCause: () => (/* binding */ dataHasCause),\n/* harmony export */   errorCodes: () => (/* binding */ errorCodes),\n/* harmony export */   errorValues: () => (/* binding */ errorValues),\n/* harmony export */   getMessageFromCode: () => (/* binding */ getMessageFromCode),\n/* harmony export */   getRpcPromiseCallback: () => (/* binding */ getRpcPromiseCallback),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isValidCode: () => (/* binding */ isValidCode),\n/* harmony export */   isValidString: () => (/* binding */ isValidString),\n/* harmony export */   mergeMiddleware: () => (/* binding */ mergeMiddleware),\n/* harmony export */   providerAsMiddleware: () => (/* binding */ providerAsMiddleware),\n/* harmony export */   providerErrors: () => (/* binding */ providerErrors),\n/* harmony export */   providerFromEngine: () => (/* binding */ providerFromEngine),\n/* harmony export */   providerFromMiddleware: () => (/* binding */ providerFromMiddleware),\n/* harmony export */   rpcErrors: () => (/* binding */ rpcErrors),\n/* harmony export */   serializeCause: () => (/* binding */ serializeCause),\n/* harmony export */   serializeError: () => (/* binding */ serializeError),\n/* harmony export */   setupMultiplex: () => (/* binding */ setupMultiplex)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/lib/ours/index.js\");\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(readable_stream__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-safe-stringify */ \"(ssr)/./node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! end-of-stream */ \"(ssr)/./node_modules/end-of-stream/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(end_of_stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! once */ \"(ssr)/./node_modules/once/once.js\");\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n\nfunction noop() {\n    return undefined;\n}\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { name, target, targetWindow = window, targetOrigin = \"*\" } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_init\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_haveSyn\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetWindow\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetOrigin\", void 0);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_onMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_synIntervalId\", void 0);\n        if (!name || !target) {\n            throw new Error(\"Invalid input.\");\n        }\n        this._init = false;\n        this._haveSyn = false;\n        this._name = name;\n        this._target = target; // target origin\n        this._targetWindow = targetWindow;\n        this._targetOrigin = targetOrigin;\n        this._onMessage = this.onMessage.bind(this);\n        this._synIntervalId = null;\n        window.addEventListener(\"message\", this._onMessage, false);\n        this._handShake();\n    }\n    _break() {\n        this.cork();\n        this._write(BRK, null, noop);\n        this._haveSyn = false;\n        this._init = false;\n    }\n    _handShake() {\n        this._write(SYN, null, noop);\n        this.cork();\n    }\n    _onData(data) {\n        if (!this._init) {\n            // listen for handshake\n            if (data === SYN) {\n                this._haveSyn = true;\n                this._write(ACK, null, noop);\n            } else if (data === ACK) {\n                this._init = true;\n                if (!this._haveSyn) {\n                    this._write(ACK, null, noop);\n                }\n                this.uncork();\n            }\n        } else if (data === BRK) {\n            this._break();\n        } else {\n            // forward message\n            try {\n                this.push(data);\n            } catch (err) {\n                this.emit(\"error\", err);\n            }\n        }\n    }\n    _postMessage(data) {\n        const originConstraint = this._targetOrigin;\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n    onMessage(event) {\n        const message = event.data;\n        // validate message\n        if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n            return;\n        }\n        this._onData(message.data);\n    }\n    _read() {\n        return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _write(data, _, cb) {\n        this._postMessage(data);\n        cb();\n    }\n    _destroy() {\n        window.removeEventListener(\"message\", this._onMessage, false);\n    }\n}\nconst errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n};\nconst errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    \"4001\": {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    \"4100\": {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    \"4200\": {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    \"4900\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    \"4901\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n};\nconst FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nconst FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nconst JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n/**\n * Returns whether the given code is valid.\n * A code is valid if it is an integer.\n *\n * @param code - The error code.\n * @returns Whether the given code is valid.\n */ function isValidCode(code) {\n    return Number.isInteger(code);\n}\nfunction isValidString(value) {\n    return typeof value === \"string\" && value.length > 0;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */ function isObject(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */ function isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while(Object.getPrototypeOf(proto) !== null){\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    } catch (_) {\n        return false;\n    }\n}\n/**\n * Check if the given code is a valid JSON-RPC server error code.\n *\n * @param code - The error code.\n * @returns Whether the given code is a valid JSON-RPC server error code.\n */ function isJsonRpcServerError(code) {\n    return code >= -32099 && code <= -32000;\n}\nfunction isJsonRpcError(value) {\n    const castValue = value;\n    if (!castValue) return false;\n    if (!isValidCode(castValue.code) || !isValidString(castValue.message)) return false;\n    if (castValue.stack && !isValidString(castValue.stack)) return false;\n    return true;\n}\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n *\n * @param code - The error code.\n * @param fallbackMessage - The fallback message to use if the code has no\n * corresponding message.\n * @returns The message for the given code, or the fallback message if the code\n * has no corresponding message.\n */ function getMessageFromCode(code) {\n    let fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n    if (isValidCode(code)) {\n        const codeString = code.toString();\n        if (Object.hasOwn(errorValues, codeString)) {\n            return errorValues[codeString].message;\n        }\n        if (isJsonRpcServerError(code)) {\n            return JSON_RPC_SERVER_ERROR_MESSAGE;\n        }\n    }\n    return fallbackMessage;\n}\nconst FALLBACK_ERROR = {\n    code: FALLBACK_ERROR_CODE,\n    message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nfunction isValidJson(str) {\n    try {\n        JSON.parse(JSON.stringify(str, (strKey, strVal)=>{\n            if (strKey === \"__proto__\" || strKey === \"constructor\") {\n                throw new Error(\"Not valid json\");\n            }\n            if (typeof strVal === \"function\" || typeof strVal === \"symbol\") {\n                throw new Error(\"Not valid json\");\n            }\n            return strVal;\n        }), (propKey, propValue)=>{\n            // Strip __proto__ and constructor properties to prevent prototype pollution.\n            if (propKey === \"__proto__\" || propKey === \"constructor\") {\n                return undefined;\n            }\n            return propValue;\n        });\n    // this means, it's a valid json so far\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n/**\n * Extracts all JSON-serializable properties from an object.\n *\n * @param object - The object in question.\n * @returns An object containing all the JSON-serializable properties.\n */ function serializeObject(object) {\n    return Object.getOwnPropertyNames(object).reduce((acc, key)=>{\n        const value = object[key];\n        if (isValidJson(value)) {\n            acc[key] = value;\n        }\n        return acc;\n    }, {});\n}\n/**\n * Serializes an unknown error to be used as the `cause` in a fallback error.\n *\n * @param error - The unknown error.\n * @returns A JSON-serializable object containing as much information about the original error as possible.\n */ function serializeCause(error) {\n    if (Array.isArray(error)) {\n        return error.map((entry)=>{\n            if (isValidJson(entry)) {\n                return entry;\n            } else if (isObject(entry)) {\n                return serializeObject(entry);\n            }\n            return null;\n        });\n    } else if (isObject(error)) {\n        return serializeObject(error);\n    }\n    if (isValidJson(error)) {\n        return error;\n    }\n    return null;\n}\n/**\n * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`\n *\n * @param error - The error in question.\n * @param fallbackError - A JSON serializable fallback error.\n * @returns A JSON serializable error object.\n */ function buildError(error, fallbackError) {\n    // If an error specifies a `serialize` function, we call it and return the result.\n    if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n        return error.serialize();\n    }\n    if (isJsonRpcError(error)) {\n        return error;\n    }\n    // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.\n    const cause = serializeCause(error);\n    const fallbackWithCause = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, fallbackError), {}, {\n        data: {\n            cause\n        }\n    });\n    return fallbackWithCause;\n}\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.cause property.\n *\n * @param error - The error to serialize.\n * @param options - Options bag.\n * @param options.fallbackError - The error to return if the given error is\n * not compatible. Should be a JSON serializable value.\n * @param options.shouldIncludeStack - Whether to include the error's stack\n * on the returned object.\n * @returns The serialized error.\n */ function serializeError(error) {\n    let { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isJsonRpcError(fallbackError)) {\n        throw new Error(\"Must provide fallback error with integer number code and string message.\");\n    }\n    const serialized = buildError(error, fallbackError);\n    if (!shouldIncludeStack) {\n        delete serialized.stack;\n    }\n    return serialized;\n}\n/**\n * Returns true if supplied error data has a usable `cause` property; false otherwise.\n *\n * @param data - Optional data to validate.\n * @returns Whether cause property is present and an object.\n */ function dataHasCause(data) {\n    return isObject(data) && Object.hasOwn(data, \"cause\") && isObject(data.cause);\n}\n/**\n * Check if the given code is a valid JSON-RPC error code.\n *\n * @param code - The code to check.\n * @returns Whether the code is valid.\n */ function isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n/**\n * A JSON replacer function that omits circular references.\n *\n * @param _ - The key being replaced.\n * @param value - The value being replaced.\n * @returns The value to use in place of the original value.\n */ function stringifyReplacer(_, value) {\n    if (value === \"[Circular]\") {\n        return undefined;\n    }\n    return value;\n}\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n *\n * Permits any integer error code.\n */ class JsonRpcError extends Error {\n    constructor(code, message, data){\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a non-empty string.');\n        }\n        if (dataHasCause(data)) {\n            super(message, {\n                cause: data.cause\n            });\n            // Browser backwards-compatibility fallback\n            // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"cause\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n            if (!Object.hasOwn(this, \"cause\")) {\n                Object.assign(this, {\n                    cause: data.cause\n                });\n            }\n        } else {\n            super(message);\n            // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"cause\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n        }\n        if (data !== undefined) {\n            this.data = data;\n        }\n        this.code = code;\n        this.cause = data === null || data === void 0 ? void 0 : data.cause;\n    }\n    /**\n   * Get the error as JSON-serializable object.\n   *\n   * @returns A plain object with all public class properties.\n   */ serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message\n        };\n        if (this.data !== undefined) {\n            // `this.data` is not guaranteed to be a plain object, but this simplifies\n            // the type guard below. We can safely cast it because we know it's a\n            // JSON-serializable value.\n            serialized.data = this.data;\n            if (isPlainObject(this.data)) {\n                serialized.data.cause = serializeCause(this.data.cause);\n            }\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    /**\n   * Get a string representation of the serialized error, omitting any circular\n   * references.\n   *\n   * @returns A string representation of the serialized error.\n   */ toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default()(this.serialize(), stringifyReplacer, 2);\n    }\n}\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */ class EthereumProviderError extends JsonRpcError {\n    /**\n   * Create an Ethereum Provider JSON-RPC error.\n   *\n   * @param code - The JSON-RPC error code. Must be an integer in the\n   * `1000 <= n <= 4999` range.\n   * @param message - The JSON-RPC error message.\n   * @param data - Optional data to include in the error.\n   */ constructor(code, message, data){\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        super(code, message, data);\n    }\n}\n/**\n * Get an error message and optional data from an options bag.\n *\n * @param arg - The error message or options bag.\n * @returns A tuple containing the error message and optional data.\n */ function parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === \"string\") {\n            return [\n                arg\n            ];\n        } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n            const { message, data } = arg;\n            if (message && typeof message !== \"string\") {\n                throw new Error(\"Must specify string message.\");\n            }\n            return [\n                message !== null && message !== void 0 ? message : undefined,\n                data\n            ];\n        }\n    }\n    return [];\n}\n/**\n * Get a generic JSON-RPC error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link JsonRpcError} class.\n */ function getJsonRpcError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new JsonRpcError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);\n}\n/**\n * Get an Ethereum Provider error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link EthereumProviderError} class.\n */ function getEthProviderError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new EthereumProviderError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);\n}\nconst rpcErrors = {\n    /**\n   * Get a JSON RPC 2.0 Parse (-32700) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ parse: (arg)=>getJsonRpcError(errorCodes.rpc.parse, arg),\n    /**\n   * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidRequest: (arg)=>getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n    /**\n   * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidParams: (arg)=>getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n    /**\n   * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ methodNotFound: (arg)=>getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n    /**\n   * Get a JSON RPC 2.0 Internal (-32603) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ internal: (arg)=>getJsonRpcError(errorCodes.rpc.internal, arg),\n    /**\n   * Get a JSON RPC 2.0 Server error.\n   * Permits integer error codes in the [ -32099 <= -32005 ] range.\n   * Codes -32000 through -32004 are reserved by EIP-1474.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ server: (opts)=>{\n        if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n            throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n        }\n        const { code } = opts;\n        if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n            throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n        }\n        return getJsonRpcError(code, opts);\n    },\n    /**\n   * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidInput: (arg)=>getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n    /**\n   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ resourceNotFound: (arg)=>getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n    /**\n   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ resourceUnavailable: (arg)=>getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n    /**\n   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ transactionRejected: (arg)=>getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n    /**\n   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ methodNotSupported: (arg)=>getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n    /**\n   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ limitExceeded: (arg)=>getJsonRpcError(errorCodes.rpc.limitExceeded, arg)\n};\nconst providerErrors = {\n    /**\n   * Get an Ethereum Provider User Rejected Request (4001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ userRejectedRequest: (arg)=>{\n        return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n    },\n    /**\n   * Get an Ethereum Provider Unauthorized (4100) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ unauthorized: (arg)=>{\n        return getEthProviderError(errorCodes.provider.unauthorized, arg);\n    },\n    /**\n   * Get an Ethereum Provider Unsupported Method (4200) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ unsupportedMethod: (arg)=>{\n        return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n    },\n    /**\n   * Get an Ethereum Provider Not Connected (4900) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ disconnected: (arg)=>{\n        return getEthProviderError(errorCodes.provider.disconnected, arg);\n    },\n    /**\n   * Get an Ethereum Provider Chain Not Connected (4901) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ chainDisconnected: (arg)=>{\n        return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n    },\n    /**\n   * Get a custom Ethereum Provider error.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ custom: (opts)=>{\n        if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n            throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n        }\n        const { code, message, data } = opts;\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        return new EthereumProviderError(code, message, data);\n    }\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */ function safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    } catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(()=>{\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for(let i = 0; i < n; i += 1){\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events__WEBPACK_IMPORTED_MODULE_4__.EventEmitter {\n    emit(type) {\n        let doError = type === \"error\";\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        } else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === \"function\") {\n            safeApply(handler, this, args);\n        } else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for(let i = 0; i < len; i += 1){\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nclass SerializableError extends Error {\n    constructor(_ref){\n        let { code, message, data } = _ref;\n        if (!Number.isInteger(code)) {\n            throw new Error(\"code must be an integer\");\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error(\"message must be string\");\n        }\n        super(message);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n        this.code = code;\n        if (data !== undefined) {\n            this.data = data;\n        }\n    }\n    toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default()({\n            code: this.code,\n            message: this.message,\n            data: this.data,\n            stack: this.stack\n        });\n    }\n}\nconst getRpcPromiseCallback = function(resolve, reject) {\n    let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return (error, response)=>{\n        if (error || response.error) {\n            reject(error || response.error);\n        } else if (!unwrapResult || Array.isArray(response)) {\n            resolve(response);\n        } else {\n            resolve(response.result);\n        }\n    };\n};\nfunction createErrorMiddleware(log) {\n    return (req, res, next, end)=>{\n        try {\n            // json-rpc-engine will terminate the request when it notices this error\n            if (typeof req.method !== \"string\" || !req.method) {\n                res.error = new SerializableError({\n                    code: -32603,\n                    message: \"invalid method\"\n                });\n                end();\n                return;\n            }\n            next((done)=>{\n                const { error } = res;\n                if (!error) {\n                    return done();\n                }\n                log.error(`OpenLogin - RPC Error: ${error.message}`, error);\n                return done();\n            });\n        } catch (error) {\n            log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);\n            res.error = new SerializableError({\n                code: -32603,\n                message: error.message\n            });\n            end();\n        }\n    };\n}\nfunction createStreamMiddleware() {\n    const idMap = {};\n    function readNoop() {\n        return false;\n    }\n    const events = new SafeEventEmitter();\n    function processResponse(res) {\n        const context = idMap[res.id];\n        if (!context) {\n            throw new Error(`StreamMiddleware - Unknown response id \"${res.id}\"`);\n        }\n        delete idMap[res.id];\n        // copy whole res onto original res\n        Object.assign(context.res, res);\n        // run callback on empty stack,\n        // prevent internal stream-handler from catching errors\n        setTimeout(context.end);\n    }\n    function processNotification(res) {\n        events.emit(\"notification\", res);\n    }\n    function processMessage(res, _encoding, cb) {\n        let err;\n        try {\n            const isNotification = !res.id;\n            if (isNotification) {\n                processNotification(res);\n            } else {\n                processResponse(res);\n            }\n        } catch (_err) {\n            err = _err;\n        }\n        // continue processing stream\n        cb(err);\n    }\n    const stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read: readNoop,\n        write: processMessage\n    });\n    const middleware = (req, res, next, end)=>{\n        // write req to stream\n        stream.push(req);\n        // register request on id map\n        idMap[req.id] = {\n            req,\n            res,\n            next,\n            end\n        };\n    };\n    return {\n        events,\n        middleware,\n        stream\n    };\n}\nfunction createScaffoldMiddleware(handlers) {\n    return (req, res, next, end)=>{\n        const handler = handlers[req.method];\n        // if no handler, return\n        if (handler === undefined) {\n            return next();\n        }\n        // if handler is fn, call as middleware\n        if (typeof handler === \"function\") {\n            return handler(req, res, next, end);\n        }\n        // if handler is some other value, use as result\n        res.result = handler;\n        return end();\n    };\n}\nfunction createIdRemapMiddleware() {\n    return (req, res, next, _end)=>{\n        const originalId = req.id;\n        const newId = Math.random().toString(36).slice(2);\n        req.id = newId;\n        res.id = newId;\n        next((done)=>{\n            req.id = originalId;\n            res.id = originalId;\n            done();\n        });\n    };\n}\nfunction createLoggerMiddleware(logger) {\n    return (req, res, next, _)=>{\n        logger.debug(\"REQ\", req, \"RES\", res);\n        next();\n    };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n    return async (req, res, next, end)=>{\n        // nextPromise is the key to the implementation\n        // it is resolved by the return handler passed to the\n        // \"next\" function\n        let resolveNextPromise;\n        const nextPromise = new Promise((resolve)=>{\n            resolveNextPromise = resolve;\n        });\n        let returnHandlerCallback = null;\n        let nextWasCalled = false;\n        // This will be called by the consumer's async middleware.\n        const asyncNext = async ()=>{\n            nextWasCalled = true;\n            // We pass a return handler to next(). When it is called by the engine,\n            // the consumer's async middleware will resume executing.\n            next((runReturnHandlersCallback)=>{\n                // This callback comes from JRPCEngine._runReturnHandlers\n                returnHandlerCallback = runReturnHandlersCallback;\n                resolveNextPromise();\n            });\n            await nextPromise;\n        };\n        try {\n            await asyncMiddleware(req, res, asyncNext);\n            if (nextWasCalled) {\n                await nextPromise; // we must wait until the return handler is called\n                returnHandlerCallback(null);\n            } else {\n                end(null);\n            }\n        } catch (err) {\n            const error = err;\n            if (returnHandlerCallback) {\n                returnHandlerCallback(error);\n            } else {\n                end(error);\n            }\n        }\n    };\n}\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */ class JRPCEngine extends SafeEventEmitter {\n    constructor(){\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_middleware\", void 0);\n        this._middleware = [];\n    }\n    /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */ static async _runAllMiddleware(req, res, middlewareStack) {\n        const returnHandlers = [];\n        let error = null;\n        let isComplete = false;\n        // Go down stack of middleware, call and collect optional returnHandlers\n        for (const middleware of middlewareStack){\n            [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n            if (isComplete) {\n                break;\n            }\n        }\n        return [\n            error,\n            isComplete,\n            returnHandlers.reverse()\n        ];\n    }\n    /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * and a boolean indicating whether the request should end.\n   */ static _runMiddleware(req, res, middleware, returnHandlers) {\n        return new Promise((resolve)=>{\n            const end = (err)=>{\n                const error = err || res.error;\n                if (error) {\n                    if (typeof error === \"object\" && Object.keys(error).includes(\"stack\") === false) error.stack = \"Stack trace is not available.\";\n                    res.error = serializeError(error, {\n                        shouldIncludeStack: true,\n                        fallbackError: {\n                            message: (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString()),\n                            code: (error === null || error === void 0 ? void 0 : error.code) || -32603,\n                            stack: (error === null || error === void 0 ? void 0 : error.stack) || \"Stack trace is not available.\",\n                            data: (error === null || error === void 0 ? void 0 : error.data) || (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString())\n                        }\n                    });\n                }\n                // True indicates that the request should end\n                resolve([\n                    error,\n                    true\n                ]);\n            };\n            const next = (returnHandler)=>{\n                if (res.error) {\n                    end(res.error);\n                } else {\n                    if (returnHandler) {\n                        if (typeof returnHandler !== \"function\") {\n                            end(new SerializableError({\n                                code: -32603,\n                                message: \"JRPCEngine: 'next' return handlers must be functions\"\n                            }));\n                        }\n                        returnHandlers.push(returnHandler);\n                    }\n                    // False indicates that the request should not end\n                    resolve([\n                        null,\n                        false\n                    ]);\n                }\n            };\n            try {\n                middleware(req, res, next, end);\n            } catch (error) {\n                end(error);\n            }\n        });\n    }\n    /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */ static async _runReturnHandlers(handlers) {\n        for (const handler of handlers){\n            await new Promise((resolve, reject)=>{\n                handler((err)=>err ? reject(err) : resolve());\n            });\n        }\n    }\n    /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */ static _checkForCompletion(_req, res, isComplete) {\n        if (!(\"result\" in res) && !(\"error\" in res)) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Response has no error or result for request\"\n            });\n        }\n        if (!isComplete) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Nothing ended request\"\n            });\n        }\n    }\n    /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */ push(middleware) {\n        this._middleware.push(middleware);\n    }\n    /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @param callback - An error-first callback that will receive the response.\n   */ /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @param callback - An error-first callback that will receive the array of\n   * responses.\n   */ /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @returns A promise that resolves with the response, or rejects with an\n   * error.\n   */ /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @returns A promise that resolves with the array of responses, or rejects\n   * with an error.\n   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    handle(req, cb) {\n        if (cb && typeof cb !== \"function\") {\n            throw new Error('\"callback\" must be a function if provided.');\n        }\n        if (Array.isArray(req)) {\n            if (cb) {\n                return this._handleBatch(req, cb);\n            }\n            return this._handleBatch(req);\n        }\n        if (cb) {\n            return this._handle(req, cb);\n        }\n        return this._promiseHandle(req);\n    }\n    /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */ asMiddleware() {\n        return async (req, res, next, end)=>{\n            try {\n                const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n                if (isComplete) {\n                    await JRPCEngine._runReturnHandlers(returnHandlers);\n                    return end(middlewareError);\n                }\n                return next(async (handlerCallback)=>{\n                    try {\n                        await JRPCEngine._runReturnHandlers(returnHandlers);\n                    } catch (error) {\n                        return handlerCallback(error);\n                    }\n                    return handlerCallback();\n                });\n            } catch (error) {\n                return end(error);\n            }\n        };\n    }\n    /**\n   * Like _handle, but for batch requests.\n   */ /**\n   * Like _handle, but for batch requests.\n   */ async _handleBatch(reqs, cb) {\n        // The order here is important\n        try {\n            // 2. Wait for all requests to finish, or throw on some kind of fatal\n            // error\n            const responses = await Promise.all(// 1. Begin executing each request in the order received\n            reqs.map(this._promiseHandle.bind(this)));\n            // 3. Return batch response\n            if (cb) {\n                return cb(null, responses);\n            }\n            return responses;\n        } catch (error) {\n            if (cb) {\n                return cb(error);\n            }\n            throw error;\n        }\n    }\n    /**\n   * A promise-wrapped _handle.\n   */ _promiseHandle(req) {\n        return new Promise((resolve, reject)=>{\n            this._handle(req, (_err, res)=>{\n                // There will always be a response, and it will always have any error\n                // that is caught and propagated.\n                if (_err && res === undefined) {\n                    reject(_err);\n                } else resolve(res);\n            }).catch(reject);\n        });\n    }\n    /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */ async _handle(callerReq, cb) {\n        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"request must be plain object\"\n            });\n            return cb(error, {\n                id: undefined,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        if (typeof callerReq.method !== \"string\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"method must be string\"\n            });\n            return cb(error, {\n                id: callerReq.id,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        const req = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, callerReq);\n        const res = {\n            id: req.id,\n            jsonrpc: req.jsonrpc\n        };\n        let error = null;\n        try {\n            await this._processRequest(req, res);\n        } catch (_error) {\n            // A request handler error, a re-thrown middleware error, or something\n            // unexpected.\n            error = _error;\n        }\n        if (error) {\n            // Ensure no result is present on an errored response\n            delete res.result;\n            if (!res.error) {\n                var _error2, _error3, _error4, _error5, _error6, _error7, _error8;\n                if (typeof error === \"object\" && Object.keys(error).includes(\"stack\") === false) error.stack = \"Stack trace is not available.\";\n                res.error = serializeError(error, {\n                    shouldIncludeStack: true,\n                    fallbackError: {\n                        message: ((_error2 = error) === null || _error2 === void 0 ? void 0 : _error2.message) || ((_error3 = error) === null || _error3 === void 0 ? void 0 : _error3.toString()),\n                        code: ((_error4 = error) === null || _error4 === void 0 ? void 0 : _error4.code) || -32603,\n                        stack: ((_error5 = error) === null || _error5 === void 0 ? void 0 : _error5.stack) || \"Stack trace is not available.\",\n                        data: ((_error6 = error) === null || _error6 === void 0 ? void 0 : _error6.data) || ((_error7 = error) === null || _error7 === void 0 ? void 0 : _error7.message) || ((_error8 = error) === null || _error8 === void 0 ? void 0 : _error8.toString())\n                    }\n                });\n            }\n        }\n        return cb(error, res);\n    }\n    /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */ async _processRequest(req, res) {\n        const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n        // Throw if \"end\" was not called, or if the response has neither a result\n        // nor an error.\n        JRPCEngine._checkForCompletion(req, res, isComplete);\n        // The return handlers should run even if an error was encountered during\n        // middleware processing.\n        await JRPCEngine._runReturnHandlers(returnHandlers);\n        // Now we re-throw the middleware processing error, if any, to catch it\n        // further up the call chain.\n        if (error) {\n            throw error;\n        }\n    }\n}\nfunction mergeMiddleware(middlewareStack) {\n    const engine = new JRPCEngine();\n    middlewareStack.forEach((middleware)=>engine.push(middleware));\n    return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n    if (!opts || !opts.engine) {\n        throw new Error(\"Missing engine parameter!\");\n    }\n    const { engine } = opts;\n    // eslint-disable-next-line prefer-const\n    let stream;\n    function read() {\n        return undefined;\n    }\n    function write(req, _encoding, cb) {\n        engine.handle(req, (_err, res)=>{\n            stream.push(res);\n        });\n        cb();\n    }\n    stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read,\n        write\n    });\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            stream.push(message);\n        });\n    }\n    return stream;\n}\nfunction providerFromEngine(engine) {\n    const provider = new SafeEventEmitter();\n    // handle both rpc send methods\n    provider.sendAsync = async (req)=>{\n        const res = await engine.handle(req);\n        if (res.error) {\n            var _res$error, _res$error2, _res$error3, _res$error4, _res$error5, _res$error6, _res$error7;\n            if (typeof res.error === \"object\" && Object.keys(res.error).includes(\"stack\") === false) res.error.stack = \"Stack trace is not available.\";\n            const err = serializeError(res.error, {\n                fallbackError: {\n                    message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.toString()),\n                    code: ((_res$error3 = res.error) === null || _res$error3 === void 0 ? void 0 : _res$error3.code) || -32603,\n                    stack: ((_res$error4 = res.error) === null || _res$error4 === void 0 ? void 0 : _res$error4.stack) || \"Stack trace is not available.\",\n                    data: ((_res$error5 = res.error) === null || _res$error5 === void 0 ? void 0 : _res$error5.data) || ((_res$error6 = res.error) === null || _res$error6 === void 0 ? void 0 : _res$error6.message) || ((_res$error7 = res.error) === null || _res$error7 === void 0 ? void 0 : _res$error7.toString())\n                },\n                shouldIncludeStack: true\n            });\n            throw rpcErrors.internal(err);\n        }\n        return res.result;\n    };\n    provider.send = (req, callback)=>{\n        if (typeof callback !== \"function\") {\n            throw new Error('Must provide callback to \"send\" method.');\n        }\n        engine.handle(req, callback);\n    };\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            provider.emit(\"data\", null, message);\n        });\n    }\n    provider.request = async (args)=>{\n        const req = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, args), {}, {\n            id: Math.random().toString(36).slice(2),\n            jsonrpc: \"2.0\"\n        });\n        const res = await provider.sendAsync(req);\n        return res;\n    };\n    return provider;\n}\nfunction providerFromMiddleware(middleware) {\n    const engine = new JRPCEngine();\n    engine.push(middleware);\n    const provider = providerFromEngine(engine);\n    return provider;\n}\nfunction providerAsMiddleware(provider) {\n    return async (req, res, _next, end)=>{\n        // send request to provider\n        try {\n            const providerRes = await provider.sendAsync(req);\n            res.result = providerRes;\n            return end();\n        } catch (error) {\n            return end(error);\n        }\n    };\n}\nclass Substream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { parent, name } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_parent\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        this._parent = parent;\n        this._name = name;\n    }\n    /**\n   * Explicitly sets read operations to a no-op.\n   */ _read() {\n        return undefined;\n    }\n    /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */ _write(chunk, _encoding, callback) {\n        this._parent.push({\n            name: this._name,\n            data: chunk\n        });\n        callback();\n    }\n}\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(){\n        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, opts), {}, {\n            objectMode: true\n        }));\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_substreams\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"getStream\", void 0);\n        this._substreams = {};\n    }\n    createStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // create substream\n        const substream = new Substream({\n            parent: this,\n            name\n        });\n        this._substreams[name] = substream;\n        // listen for parent stream to end\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        anyStreamEnd(this, (_error)=>substream.destroy(_error || undefined));\n        return substream;\n    }\n    // ignore streams (dont display orphaned data warning)\n    ignoreStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // set\n        this._substreams[name] = IGNORE_SUBSTREAM;\n    }\n    _read() {\n        return undefined;\n    }\n    _write(chunk, _encoding, callback) {\n        const { name, data } = chunk;\n        if (!name) {\n            window.console.warn(`ObjectMultiplex - malformed chunk without name \"${chunk}\"`);\n            return callback();\n        }\n        // get corresponding substream\n        const substream = this._substreams[name];\n        if (!substream) {\n            window.console.warn(`ObjectMultiplex - orphaned data for stream \"${name}\"`);\n            return callback();\n        }\n        // push data into substream\n        if (substream !== IGNORE_SUBSTREAM) {\n            substream.push(data);\n        }\n        return callback();\n    }\n}\n// util\nfunction anyStreamEnd(stream, _cb) {\n    const cb = once__WEBPACK_IMPORTED_MODULE_6___default()(_cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n        readable: false\n    }, cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n        writable: false\n    }, cb);\n}\nfunction setupMultiplex(stream) {\n    const mux = new ObjectMultiplex();\n    mux.getStream = function streamHelper(name) {\n        if (this._substreams[name]) {\n            return this._substreams[name];\n        }\n        return this.createStream(name);\n    };\n    pump__WEBPACK_IMPORTED_MODULE_7___default()(stream, mux, stream, (err)=>{\n        if (err) window.console.error(err);\n    });\n    return mux;\n}\nclass PostMessageStream extends BasePostMessageStream {\n    _postMessage(data) {\n        let originConstraint = this._targetOrigin;\n        if (typeof data === \"object\") {\n            const dataObj = data;\n            if (typeof dataObj.data === \"object\") {\n                const dataObjData = dataObj.data;\n                if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n                    const dataObjDataParam = dataObjData.params[0];\n                    if (dataObjDataParam._origin) {\n                        originConstraint = dataObjDataParam._origin;\n                    }\n                    // add a constraint for the response\n                    dataObjDataParam._origin = window.location.origin;\n                }\n            }\n        }\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9kaXN0L29wZW5sb2dpbkpycGMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDM0I7QUFDTztBQUNpQjtBQUMzQjtBQUNOO0FBQ1I7QUFDQTtBQUV4QixTQUFTUTtJQUNQLE9BQU9DO0FBQ1Q7QUFDQSxNQUFNQyxNQUFNO0FBQ1osTUFBTUMsTUFBTTtBQUNaLE1BQU1DLE1BQU07QUFDWixNQUFNQyw4QkFBOEJaLG1EQUFNQTtJQUN4Q2EsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLElBQUksRUFDRkMsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLGVBQWVDLE1BQU0sRUFDckJDLGVBQWUsR0FBRyxFQUNuQixHQUFHTDtRQUNKLEtBQUssQ0FBQztZQUNKTSxZQUFZO1FBQ2Q7UUFDQXJCLDRFQUFlQSxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7UUFDcENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxZQUFZLEtBQUs7UUFDdkNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7UUFDcENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxXQUFXLEtBQUs7UUFDdENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsS0FBSztRQUM1Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixLQUFLO1FBQzVDLDhEQUE4RDtRQUM5REEsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGNBQWMsS0FBSztRQUN6Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGtCQUFrQixLQUFLO1FBQzdDLElBQUksQ0FBQ2dCLFFBQVEsQ0FBQ0MsUUFBUTtZQUNwQixNQUFNLElBQUlLLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FB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QUFHN1IsT0FBTzhSLFFBQVEsQ0FBQ2hRLE1BQU07Z0JBQ25EO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ3RCLGFBQWEsQ0FBQ21CLFdBQVcsQ0FBQztZQUM3QjdCLFFBQVEsSUFBSSxDQUFDUyxPQUFPO1lBQ3BCYTtRQUNGLEdBQUdNO0lBQ0w7QUFDRjtBQUVpcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2x6enQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9kaXN0L29wZW5sb2dpbkpycGMuZXNtLmpzPzhhYTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IER1cGxleCB9IGZyb20gJ3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgc2FmZVN0cmluZ2lmeSBmcm9tICdmYXN0LXNhZmUtc3RyaW5naWZ5JztcbmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IGVvcyBmcm9tICdlbmQtb2Ytc3RyZWFtJztcbmltcG9ydCBvbmNlIGZyb20gJ29uY2UnO1xuaW1wb3J0IHB1bXAgZnJvbSAncHVtcCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5jb25zdCBTWU4gPSBcIlNZTlwiO1xuY29uc3QgQUNLID0gXCJBQ0tcIjtcbmNvbnN0IEJSSyA9IFwiQlJLXCI7XG5jbGFzcyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0gZXh0ZW5kcyBEdXBsZXgge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIG5hbWUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0YXJnZXRXaW5kb3cgPSB3aW5kb3csXG4gICAgICB0YXJnZXRPcmlnaW4gPSBcIipcIlxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW5pdFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYXZlU3luXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25hbWVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldFdpbmRvd1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRPcmlnaW5cIiwgdm9pZCAwKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vbk1lc3NhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3luSW50ZXJ2YWxJZFwiLCB2b2lkIDApO1xuICAgIGlmICghbmFtZSB8fCAhdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0LlwiKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdCA9IGZhbHNlO1xuICAgIHRoaXMuX2hhdmVTeW4gPSBmYWxzZTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7IC8vIHRhcmdldCBvcmlnaW5cbiAgICB0aGlzLl90YXJnZXRXaW5kb3cgPSB0YXJnZXRXaW5kb3c7XG4gICAgdGhpcy5fdGFyZ2V0T3JpZ2luID0gdGFyZ2V0T3JpZ2luO1xuICAgIHRoaXMuX29uTWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc3luSW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uTWVzc2FnZSwgZmFsc2UpO1xuICAgIHRoaXMuX2hhbmRTaGFrZSgpO1xuICB9XG4gIF9icmVhaygpIHtcbiAgICB0aGlzLmNvcmsoKTtcbiAgICB0aGlzLl93cml0ZShCUkssIG51bGwsIG5vb3ApO1xuICAgIHRoaXMuX2hhdmVTeW4gPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0ID0gZmFsc2U7XG4gIH1cbiAgX2hhbmRTaGFrZSgpIHtcbiAgICB0aGlzLl93cml0ZShTWU4sIG51bGwsIG5vb3ApO1xuICAgIHRoaXMuY29yaygpO1xuICB9XG4gIF9vbkRhdGEoZGF0YSkge1xuICAgIGlmICghdGhpcy5faW5pdCkge1xuICAgICAgLy8gbGlzdGVuIGZvciBoYW5kc2hha2VcbiAgICAgIGlmIChkYXRhID09PSBTWU4pIHtcbiAgICAgICAgdGhpcy5faGF2ZVN5biA9IHRydWU7XG4gICAgICAgIHRoaXMuX3dyaXRlKEFDSywgbnVsbCwgbm9vcCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IEFDSykge1xuICAgICAgICB0aGlzLl9pbml0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXZlU3luKSB7XG4gICAgICAgICAgdGhpcy5fd3JpdGUoQUNLLCBudWxsLCBub29wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuY29yaygpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gQlJLKSB7XG4gICAgICB0aGlzLl9icmVhaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3J3YXJkIG1lc3NhZ2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcG9zdE1lc3NhZ2UoZGF0YSkge1xuICAgIGNvbnN0IG9yaWdpbkNvbnN0cmFpbnQgPSB0aGlzLl90YXJnZXRPcmlnaW47XG4gICAgdGhpcy5fdGFyZ2V0V2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxuICAgICAgZGF0YVxuICAgIH0sIG9yaWdpbkNvbnN0cmFpbnQpO1xuICB9XG4gIG9uTWVzc2FnZShldmVudCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuXG4gICAgLy8gdmFsaWRhdGUgbWVzc2FnZVxuICAgIGlmICh0aGlzLl90YXJnZXRPcmlnaW4gIT09IFwiKlwiICYmIGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5fdGFyZ2V0T3JpZ2luIHx8IGV2ZW50LnNvdXJjZSAhPT0gdGhpcy5fdGFyZ2V0V2luZG93IHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UudGFyZ2V0ICE9PSB0aGlzLl9uYW1lIHx8ICFtZXNzYWdlLmRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb25EYXRhKG1lc3NhZ2UuZGF0YSk7XG4gIH1cbiAgX3JlYWQoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIF93cml0ZShkYXRhLCBfLCBjYikge1xuICAgIHRoaXMuX3Bvc3RNZXNzYWdlKGRhdGEpO1xuICAgIGNiKCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uTWVzc2FnZSwgZmFsc2UpO1xuICB9XG59XG5cbmNvbnN0IGVycm9yQ29kZXMgPSB7XG4gIHJwYzoge1xuICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgIHJlc291cmNlTm90Rm91bmQ6IC0zMjAwMSxcbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAtMzIwMDIsXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogLTMyMDA0LFxuICAgIGxpbWl0RXhjZWVkZWQ6IC0zMjAwNSxcbiAgICBwYXJzZTogLTMyNzAwLFxuICAgIGludmFsaWRSZXF1ZXN0OiAtMzI2MDAsXG4gICAgbWV0aG9kTm90Rm91bmQ6IC0zMjYwMSxcbiAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgaW50ZXJuYWw6IC0zMjYwM1xuICB9LFxuICBwcm92aWRlcjoge1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IDQwMDEsXG4gICAgdW5hdXRob3JpemVkOiA0MTAwLFxuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgIGRpc2Nvbm5lY3RlZDogNDkwMCxcbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogNDkwMVxuICB9XG59O1xuY29uc3QgZXJyb3JWYWx1ZXMgPSB7XG4gIFwiLTMyNzAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgSlNPTiB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci4gQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQuXCJcbiAgfSxcbiAgXCItMzI2MDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0IG9iamVjdC5cIlxuICB9LFxuICBcIi0zMjYwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS5cIlxuICB9LFxuICBcIi0zMjYwMlwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykuXCJcbiAgfSxcbiAgXCItMzI2MDNcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IuXCJcbiAgfSxcbiAgXCItMzIwMDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIGlucHV0LlwiXG4gIH0sXG4gIFwiLTMyMDAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiUmVzb3VyY2Ugbm90IGZvdW5kLlwiXG4gIH0sXG4gIFwiLTMyMDAyXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiUmVzb3VyY2UgdW5hdmFpbGFibGUuXCJcbiAgfSxcbiAgXCItMzIwMDNcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiByZWplY3RlZC5cIlxuICB9LFxuICBcIi0zMjAwNFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIk1ldGhvZCBub3Qgc3VwcG9ydGVkLlwiXG4gIH0sXG4gIFwiLTMyMDA1XCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiUmVxdWVzdCBsaW1pdCBleGNlZWRlZC5cIlxuICB9LFxuICBcIjQwMDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LlwiXG4gIH0sXG4gIFwiNDEwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlRoZSByZXF1ZXN0ZWQgYWNjb3VudCBhbmQvb3IgbWV0aG9kIGhhcyBub3QgYmVlbiBhdXRob3JpemVkIGJ5IHRoZSB1c2VyLlwiXG4gIH0sXG4gIFwiNDIwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlRoZSByZXF1ZXN0ZWQgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBFdGhlcmV1bSBwcm92aWRlci5cIlxuICB9LFxuICBcIjQ5MDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gYWxsIGNoYWlucy5cIlxuICB9LFxuICBcIjQ5MDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNwZWNpZmllZCBjaGFpbi5cIlxuICB9XG59O1xuXG5jb25zdCBGQUxMQkFDS19FUlJPUl9DT0RFID0gZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWw7XG5jb25zdCBGQUxMQkFDS19NRVNTQUdFID0gXCJVbnNwZWNpZmllZCBlcnJvciBtZXNzYWdlLiBUaGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0LlwiO1xuY29uc3QgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSBcIlVuc3BlY2lmaWVkIHNlcnZlciBlcnJvci5cIjtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBjb2RlIGlzIHZhbGlkLlxuICogQSBjb2RlIGlzIHZhbGlkIGlmIGl0IGlzIGFuIGludGVnZXIuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoY29kZSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cblxuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIHtAbGluayBSdW50aW1lT2JqZWN0fS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaGFzIGEgcnVudGltZSB0eXBlIG9mIGBvYmplY3RgIGFuZCBpc1xuICogbmVpdGhlciBgbnVsbGAgbm9yIGFuIGBBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRydWUgaWYgYW4gb2JqZWN0IGlzIHRoZSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCxcbiAqIGZhbHNlIGlmIHRoZSBvYmplY3QgaXMgbm90IHBsYWluIChlLmcuIGZ1bmN0aW9uKS5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGNvZGUgaXMgYSB2YWxpZCBKU09OLVJQQyBzZXJ2ZXIgZXJyb3IgY29kZS5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBlcnJvciBjb2RlLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyBhIHZhbGlkIEpTT04tUlBDIHNlcnZlciBlcnJvciBjb2RlLlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IC0zMjA5OSAmJiBjb2RlIDw9IC0zMjAwMDtcbn1cbmZ1bmN0aW9uIGlzSnNvblJwY0Vycm9yKHZhbHVlKSB7XG4gIGNvbnN0IGNhc3RWYWx1ZSA9IHZhbHVlO1xuICBpZiAoIWNhc3RWYWx1ZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzVmFsaWRDb2RlKGNhc3RWYWx1ZS5jb2RlKSB8fCAhaXNWYWxpZFN0cmluZyhjYXN0VmFsdWUubWVzc2FnZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGNhc3RWYWx1ZS5zdGFjayAmJiAhaXNWYWxpZFN0cmluZyhjYXN0VmFsdWUuc3RhY2spKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xuICogbm8gY29ycmVzcG9uZGluZyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0gZmFsbGJhY2tNZXNzYWdlIC0gVGhlIGZhbGxiYWNrIG1lc3NhZ2UgdG8gdXNlIGlmIHRoZSBjb2RlIGhhcyBub1xuICogY29ycmVzcG9uZGluZyBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIG1lc3NhZ2UgZm9yIHRoZSBnaXZlbiBjb2RlLCBvciB0aGUgZmFsbGJhY2sgbWVzc2FnZSBpZiB0aGUgY29kZVxuICogaGFzIG5vIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpIHtcbiAgbGV0IGZhbGxiYWNrTWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRkFMTEJBQ0tfTUVTU0FHRTtcbiAgaWYgKGlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgY29uc3QgY29kZVN0cmluZyA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihlcnJvclZhbHVlcywgY29kZVN0cmluZykpIHtcbiAgICAgIHJldHVybiBlcnJvclZhbHVlc1tjb2RlU3RyaW5nXS5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcbiAgICAgIHJldHVybiBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrTWVzc2FnZTtcbn1cbmNvbnN0IEZBTExCQUNLX0VSUk9SID0ge1xuICBjb2RlOiBGQUxMQkFDS19FUlJPUl9DT0RFLFxuICBtZXNzYWdlOiBnZXRNZXNzYWdlRnJvbUNvZGUoRkFMTEJBQ0tfRVJST1JfQ09ERSlcbn07XG5mdW5jdGlvbiBpc1ZhbGlkSnNvbihzdHIpIHtcbiAgdHJ5IHtcbiAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0ciwgKHN0cktleSwgc3RyVmFsKSA9PiB7XG4gICAgICBpZiAoc3RyS2V5ID09PSBcIl9fcHJvdG9fX1wiIHx8IHN0cktleSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCB2YWxpZCBqc29uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzdHJWYWwgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2Ygc3RyVmFsID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCB2YWxpZCBqc29uXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clZhbDtcbiAgICB9KSwgKHByb3BLZXksIHByb3BWYWx1ZSkgPT4ge1xuICAgICAgLy8gU3RyaXAgX19wcm90b19fIGFuZCBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvbi5cbiAgICAgIGlmIChwcm9wS2V5ID09PSBcIl9fcHJvdG9fX1wiIHx8IHByb3BLZXkgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICB9KTtcbiAgICAvLyB0aGlzIG1lYW5zLCBpdCdzIGEgdmFsaWQganNvbiBzbyBmYXJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBhbGwgSlNPTi1zZXJpYWxpemFibGUgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCBpbiBxdWVzdGlvbi5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgSlNPTi1zZXJpYWxpemFibGUgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAoaXNWYWxpZEpzb24odmFsdWUpKSB7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogU2VyaWFsaXplcyBhbiB1bmtub3duIGVycm9yIHRvIGJlIHVzZWQgYXMgdGhlIGBjYXVzZWAgaW4gYSBmYWxsYmFjayBlcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgdW5rbm93biBlcnJvci5cbiAqIEByZXR1cm5zIEEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IGNvbnRhaW5pbmcgYXMgbXVjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXJyb3IgYXMgcG9zc2libGUuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNhdXNlKGVycm9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvci5tYXAoZW50cnkgPT4ge1xuICAgICAgaWYgKGlzVmFsaWRKc29uKGVudHJ5KSkge1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KGVudHJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGVycm9yKSkge1xuICAgIHJldHVybiBzZXJpYWxpemVPYmplY3QoZXJyb3IpO1xuICB9XG4gIGlmIChpc1ZhbGlkSnNvbihlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IGdpdmVuIGFuIGVycm9yIGFuZCBhIEpTT04gc2VyaWFsaXphYmxlIGBmYWxsYmFja0Vycm9yYFxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBpbiBxdWVzdGlvbi5cbiAqIEBwYXJhbSBmYWxsYmFja0Vycm9yIC0gQSBKU09OIHNlcmlhbGl6YWJsZSBmYWxsYmFjayBlcnJvci5cbiAqIEByZXR1cm5zIEEgSlNPTiBzZXJpYWxpemFibGUgZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBidWlsZEVycm9yKGVycm9yLCBmYWxsYmFja0Vycm9yKSB7XG4gIC8vIElmIGFuIGVycm9yIHNwZWNpZmllcyBhIGBzZXJpYWxpemVgIGZ1bmN0aW9uLCB3ZSBjYWxsIGl0IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcInNlcmlhbGl6ZVwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBlcnJvci5zZXJpYWxpemUoKTtcbiAgfVxuICBpZiAoaXNKc29uUnBjRXJyb3IoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gSWYgdGhlIGVycm9yIGRvZXMgbm90IG1hdGNoIHRoZSBKc29uUnBjRXJyb3IgdHlwZSwgdXNlIHRoZSBmYWxsYmFjayBlcnJvciwgYnV0IHRyeSB0byBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBhcyBgY2F1c2VgLlxuICBjb25zdCBjYXVzZSA9IHNlcmlhbGl6ZUNhdXNlKGVycm9yKTtcbiAgY29uc3QgZmFsbGJhY2tXaXRoQ2F1c2UgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGZhbGxiYWNrRXJyb3IpLCB7fSwge1xuICAgIGRhdGE6IHtcbiAgICAgIGNhdXNlXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZhbGxiYWNrV2l0aENhdXNlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGVycm9yIHRvIGFuIEV0aGVyZXVtIEpTT04gUlBDLWNvbXBhdGlibGUgZXJyb3Igb2JqZWN0LlxuICogSWYgdGhlIGdpdmVuIGVycm9yIGlzIG5vdCBmdWxseSBjb21wYXRpYmxlLCBpdCB3aWxsIGJlIHByZXNlcnZlZCBvbiB0aGVcbiAqIHJldHVybmVkIG9iamVjdCdzIGRhdGEuY2F1c2UgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBiYWcuXG4gKiBAcGFyYW0gb3B0aW9ucy5mYWxsYmFja0Vycm9yIC0gVGhlIGVycm9yIHRvIHJldHVybiBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXNcbiAqIG5vdCBjb21wYXRpYmxlLiBTaG91bGQgYmUgYSBKU09OIHNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zLnNob3VsZEluY2x1ZGVTdGFjayAtIFdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgZXJyb3IncyBzdGFja1xuICogb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvcikge1xuICBsZXQge1xuICAgIGZhbGxiYWNrRXJyb3IgPSBGQUxMQkFDS19FUlJPUixcbiAgICBzaG91bGRJbmNsdWRlU3RhY2sgPSB0cnVlXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBpZiAoIWlzSnNvblJwY0Vycm9yKGZhbGxiYWNrRXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGZhbGxiYWNrIGVycm9yIHdpdGggaW50ZWdlciBudW1iZXIgY29kZSBhbmQgc3RyaW5nIG1lc3NhZ2UuXCIpO1xuICB9XG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBidWlsZEVycm9yKGVycm9yLCBmYWxsYmFja0Vycm9yKTtcbiAgaWYgKCFzaG91bGRJbmNsdWRlU3RhY2spIHtcbiAgICBkZWxldGUgc2VyaWFsaXplZC5zdGFjaztcbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgc3VwcGxpZWQgZXJyb3IgZGF0YSBoYXMgYSB1c2FibGUgYGNhdXNlYCBwcm9wZXJ0eTsgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSBkYXRhIC0gT3B0aW9uYWwgZGF0YSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgY2F1c2UgcHJvcGVydHkgaXMgcHJlc2VudCBhbmQgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBkYXRhSGFzQ2F1c2UoZGF0YSkge1xuICByZXR1cm4gaXNPYmplY3QoZGF0YSkgJiYgT2JqZWN0Lmhhc093bihkYXRhLCBcImNhdXNlXCIpICYmIGlzT2JqZWN0KGRhdGEuY2F1c2UpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBjb2RlIGlzIGEgdmFsaWQgSlNPTi1SUEMgZXJyb3IgY29kZS5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBjb2RlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgY29kZSBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEV0aFByb3ZpZGVyQ29kZShjb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpICYmIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDQ5OTk7XG59XG5cbi8qKlxuICogQSBKU09OIHJlcGxhY2VyIGZ1bmN0aW9uIHRoYXQgb21pdHMgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0gXyAtIFRoZSBrZXkgYmVpbmcgcmVwbGFjZWQuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgYmVpbmcgcmVwbGFjZWQuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBcIltDaXJjdWxhcl1cIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBKU09OIFJQQyAyLjAgZXJyb3JzIGFuZCBFdGhlcmV1bSBSUEMgZXJyb3JzXG4gKiBwZXIgRUlQLTE0NzQuXG4gKlxuICogUGVybWl0cyBhbnkgaW50ZWdlciBlcnJvciBjb2RlLlxuICovXG5jbGFzcyBKc29uUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGlmIChkYXRhSGFzQ2F1c2UoZGF0YSkpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UsIHtcbiAgICAgICAgY2F1c2U6IGRhdGEuY2F1c2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBCcm93c2VyIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZhbGxiYWNrXG4gICAgICAvLyBUaGUgYGNhdXNlYCBkZWZpbml0aW9uIGNhbiBiZSByZW1vdmVkIHdoZW4gdHNjb25maWcgbGliIGFuZC9vciB0YXJnZXQgaGF2ZSBjaGFuZ2VkIHRvID49ZXMyMDIyXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB2b2lkIDApO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRoaXMsIFwiY2F1c2VcIikpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgY2F1c2U6IGRhdGEuY2F1c2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgLy8gVGhlIGBjYXVzZWAgZGVmaW5pdGlvbiBjYW4gYmUgcmVtb3ZlZCB3aGVuIHRzY29uZmlnIGxpYiBhbmQvb3IgdGFyZ2V0IGhhdmUgY2hhbmdlZCB0byA+PWVzMjAyMlxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2F1c2VcIiwgdm9pZCAwKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgdm9pZCAwKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmNhdXNlID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmNhdXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXJyb3IgYXMgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHBsYWluIG9iamVjdCB3aXRoIGFsbCBwdWJsaWMgY2xhc3MgcHJvcGVydGllcy5cbiAgICovXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgfTtcbiAgICBpZiAodGhpcy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGB0aGlzLmRhdGFgIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGEgcGxhaW4gb2JqZWN0LCBidXQgdGhpcyBzaW1wbGlmaWVzXG4gICAgICAvLyB0aGUgdHlwZSBndWFyZCBiZWxvdy4gV2UgY2FuIHNhZmVseSBjYXN0IGl0IGJlY2F1c2Ugd2Uga25vdyBpdCdzIGFcbiAgICAgIC8vIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlLlxuICAgICAgc2VyaWFsaXplZC5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGhpcy5kYXRhKSkge1xuICAgICAgICBzZXJpYWxpemVkLmRhdGEuY2F1c2UgPSBzZXJpYWxpemVDYXVzZSh0aGlzLmRhdGEuY2F1c2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgc2VyaWFsaXplZC5zdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvciwgb21pdHRpbmcgYW55IGNpcmN1bGFyXG4gICAqIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZXJpYWxpemVkIGVycm9yLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHNhZmVTdHJpbmdpZnkodGhpcy5zZXJpYWxpemUoKSwgc3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICB9XG59XG5cbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9ycyBwZXIgRUlQLTExOTMuXG4gKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXG4gKi9cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXJFcnJvciBleHRlbmRzIEpzb25ScGNFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRXRoZXJldW0gUHJvdmlkZXIgSlNPTi1SUEMgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIC0gVGhlIEpTT04tUlBDIGVycm9yIGNvZGUuIE11c3QgYmUgYW4gaW50ZWdlciBpbiB0aGVcbiAgICogYDEwMDAgPD0gbiA8PSA0OTk5YCByYW5nZS5cbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgSlNPTi1SUEMgZXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIGRhdGEgLSBPcHRpb25hbCBkYXRhIHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIGlmICghaXNWYWxpZEV0aFByb3ZpZGVyQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAxMDAwIDw9IGNvZGUgPD0gNDk5OScpO1xuICAgIH1cbiAgICBzdXBlcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBhbiBlcnJvciBtZXNzYWdlIGFuZCBvcHRpb25hbCBkYXRhIGZyb20gYW4gb3B0aW9ucyBiYWcuXG4gKlxuICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICogQHJldHVybnMgQSB0dXBsZSBjb250YWluaW5nIHRoZSBlcnJvciBtZXNzYWdlIGFuZCBvcHRpb25hbCBkYXRhLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wdHMoYXJnKSB7XG4gIGlmIChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFthcmddO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSBhcmc7XG4gICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHNwZWNpZnkgc3RyaW5nIG1lc3NhZ2UuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFttZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiB1bmRlZmluZWQsIGRhdGFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogR2V0IGEgZ2VuZXJpYyBKU09OLVJQQyBlcnJvciBjbGFzcyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBlcnJvciBjb2RlLlxuICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjRXJyb3IoY29kZSwgYXJnKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBkYXRhXSA9IHBhcnNlT3B0cyhhcmcpO1xuICByZXR1cm4gbmV3IEpzb25ScGNFcnJvcihjb2RlLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksIGRhdGEpO1xufVxuXG4vKipcbiAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBlcnJvciBjbGFzcyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBlcnJvciBjb2RlLlxuICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICovXG5mdW5jdGlvbiBnZXRFdGhQcm92aWRlckVycm9yKGNvZGUsIGFyZykge1xuICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSBwYXJzZU9wdHMoYXJnKTtcbiAgcmV0dXJuIG5ldyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmNvbnN0IHJwY0Vycm9ycyA9IHtcbiAgLyoqXG4gICAqIEdldCBhIEpTT04gUlBDIDIuMCBQYXJzZSAoLTMyNzAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBwYXJzZTogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5wYXJzZSwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFJlcXVlc3QgKC0zMjYwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgaW52YWxpZFJlcXVlc3Q6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFJlcXVlc3QsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW52YWxpZCBQYXJhbXMgKC0zMjYwMikgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgaW52YWxpZFBhcmFtczogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5pbnZhbGlkUGFyYW1zLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIE1ldGhvZCBOb3QgRm91bmQgKC0zMjYwMSkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgbWV0aG9kTm90Rm91bmQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMubWV0aG9kTm90Rm91bmQsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW50ZXJuYWwgKC0zMjYwMykgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgaW50ZXJuYWw6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgU2VydmVyIGVycm9yLlxuICAgKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgLTMyMDk5IDw9IC0zMjAwNSBdIHJhbmdlLlxuICAgKiBDb2RlcyAtMzIwMDAgdGhyb3VnaCAtMzIwMDQgYXJlIHJlc2VydmVkIGJ5IEVJUC0xNDc0LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBlcnJvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgc2VydmVyOiBvcHRzID0+IHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXRoZXJldW0gUlBDIFNlcnZlciBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb2RlXG4gICAgfSA9IG9wdHM7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpIHx8IGNvZGUgPiAtMzIwMDUgfHwgY29kZSA8IC0zMjA5OSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAtMzIwOTkgPD0gY29kZSA8PSAtMzIwMDUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25ScGNFcnJvcihjb2RlLCBvcHRzKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBJbnZhbGlkIElucHV0ICgtMzIwMDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludmFsaWRJbnB1dDogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5pbnZhbGlkSW5wdXQsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgTm90IEZvdW5kICgtMzIwMDEpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIHJlc291cmNlTm90Rm91bmQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBVbmF2YWlsYWJsZSAoLTMyMDAyKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICByZXNvdXJjZVVuYXZhaWxhYmxlOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnJlc291cmNlVW5hdmFpbGFibGUsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgVHJhbnNhY3Rpb24gUmVqZWN0ZWQgKC0zMjAwMykgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgdHJhbnNhY3Rpb25SZWplY3RlZDogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy50cmFuc2FjdGlvblJlamVjdGVkLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIE1ldGhvZCBOb3QgU3VwcG9ydGVkICgtMzIwMDQpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIG1ldGhvZE5vdFN1cHBvcnRlZDogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTGltaXQgRXhjZWVkZWQgKC0zMjAwNSkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgbGltaXRFeGNlZWRlZDogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5saW1pdEV4Y2VlZGVkLCBhcmcpXG59O1xuY29uc3QgcHJvdmlkZXJFcnJvcnMgPSB7XG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVXNlciBSZWplY3RlZCBSZXF1ZXN0ICg0MDAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiBhcmcgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCwgYXJnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbmF1dGhvcml6ZWQgKDQxMDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICovXG4gIHVuYXV0aG9yaXplZDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgYXJnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbnN1cHBvcnRlZCBNZXRob2QgKDQyMDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICovXG4gIHVuc3VwcG9ydGVkTWV0aG9kOiBhcmcgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgTm90IENvbm5lY3RlZCAoNDkwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgZGlzY29ubmVjdGVkOiBhcmcgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIuZGlzY29ubmVjdGVkLCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIENoYWluIE5vdCBDb25uZWN0ZWQgKDQ5MDEpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICovXG4gIGNoYWluRGlzY29ubmVjdGVkOiBhcmcgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIuY2hhaW5EaXNjb25uZWN0ZWQsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYSBjdXN0b20gRXRoZXJldW0gUHJvdmlkZXIgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIC0gVGhlIGVycm9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBjdXN0b206IG9wdHMgPT4ge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcmV1bSBQcm92aWRlciBjdXN0b20gZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29kZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkYXRhXG4gICAgfSA9IG9wdHM7XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgUmVmbGVjdC5hcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gVGhyb3cgZXJyb3IgYWZ0ZXIgdGltZW91dCBzbyBhcyBub3QgdG8gaW50ZXJydXB0IHRoZSBzdGFja1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhcnJheUNsb25lKGFycikge1xuICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgY29uc3QgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuY2xhc3MgU2FmZUV2ZW50RW1pdHRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGVtaXQodHlwZSkge1xuICAgIGxldCBkb0Vycm9yID0gdHlwZSA9PT0gXCJlcnJvclwiO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoIWRvRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChkb0Vycm9yKSB7XG4gICAgICBsZXQgZXI7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIFtlcl0gPSBhcmdzO1xuICAgICAgfVxuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBVbmhhbmRsZWQgZXJyb3IuJHtlciA/IGAgKCR7ZXIubWVzc2FnZX0pYCA6IFwiXCJ9YCk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICBjb25zdCBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzYWZlQXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuY2xhc3MgU2VyaWFsaXphYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgY29kZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkYXRhXG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2RlIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXNzYWdlIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHNhZmVTdHJpbmdpZnkoe1xuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBnZXRScGNQcm9taXNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGxldCB1bndyYXBSZXN1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIHJldHVybiAoZXJyb3IsIHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKGVycm9yIHx8IHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IgfHwgcmVzcG9uc2UuZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoIXVud3JhcFJlc3VsdCB8fCBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JNaWRkbGV3YXJlKGxvZykge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8ganNvbi1ycGMtZW5naW5lIHdpbGwgdGVybWluYXRlIHRoZSByZXF1ZXN0IHdoZW4gaXQgbm90aWNlcyB0aGlzIGVycm9yXG4gICAgICBpZiAodHlwZW9mIHJlcS5tZXRob2QgIT09IFwic3RyaW5nXCIgfHwgIXJlcS5tZXRob2QpIHtcbiAgICAgICAgcmVzLmVycm9yID0gbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgICAgbWVzc2FnZTogXCJpbnZhbGlkIG1ldGhvZFwiXG4gICAgICAgIH0pO1xuICAgICAgICBlbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV4dChkb25lID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0gPSByZXM7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5lcnJvcihgT3BlbkxvZ2luIC0gUlBDIEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihgT3BlbkxvZ2luIC0gUlBDIEVycm9yIHRocm93bjogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgIHJlcy5lcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlKCkge1xuICBjb25zdCBpZE1hcCA9IHt9O1xuICBmdW5jdGlvbiByZWFkTm9vcCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZXZlbnRzID0gbmV3IFNhZmVFdmVudEVtaXR0ZXIoKTtcbiAgZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBpZE1hcFtyZXMuaWRdO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJlYW1NaWRkbGV3YXJlIC0gVW5rbm93biByZXNwb25zZSBpZCBcIiR7cmVzLmlkfVwiYCk7XG4gICAgfVxuICAgIGRlbGV0ZSBpZE1hcFtyZXMuaWRdO1xuICAgIC8vIGNvcHkgd2hvbGUgcmVzIG9udG8gb3JpZ2luYWwgcmVzXG4gICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LnJlcywgcmVzKTtcbiAgICAvLyBydW4gY2FsbGJhY2sgb24gZW1wdHkgc3RhY2ssXG4gICAgLy8gcHJldmVudCBpbnRlcm5hbCBzdHJlYW0taGFuZGxlciBmcm9tIGNhdGNoaW5nIGVycm9yc1xuICAgIHNldFRpbWVvdXQoY29udGV4dC5lbmQpO1xuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NOb3RpZmljYXRpb24ocmVzKSB7XG4gICAgZXZlbnRzLmVtaXQoXCJub3RpZmljYXRpb25cIiwgcmVzKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShyZXMsIF9lbmNvZGluZywgY2IpIHtcbiAgICBsZXQgZXJyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc05vdGlmaWNhdGlvbiA9ICFyZXMuaWQ7XG4gICAgICBpZiAoaXNOb3RpZmljYXRpb24pIHtcbiAgICAgICAgcHJvY2Vzc05vdGlmaWNhdGlvbihyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlKHJlcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgZXJyID0gX2VycjtcbiAgICB9XG4gICAgLy8gY29udGludWUgcHJvY2Vzc2luZyBzdHJlYW1cbiAgICBjYihlcnIpO1xuICB9XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBEdXBsZXgoe1xuICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgcmVhZDogcmVhZE5vb3AsXG4gICAgd3JpdGU6IHByb2Nlc3NNZXNzYWdlXG4gIH0pO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAvLyB3cml0ZSByZXEgdG8gc3RyZWFtXG4gICAgc3RyZWFtLnB1c2gocmVxKTtcbiAgICAvLyByZWdpc3RlciByZXF1ZXN0IG9uIGlkIG1hcFxuICAgIGlkTWFwW3JlcS5pZF0gPSB7XG4gICAgICByZXEsXG4gICAgICByZXMsXG4gICAgICBuZXh0LFxuICAgICAgZW5kXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBldmVudHMsXG4gICAgbWlkZGxld2FyZSxcbiAgICBzdHJlYW1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZShoYW5kbGVycykge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbcmVxLm1ldGhvZF07XG4gICAgLy8gaWYgbm8gaGFuZGxlciwgcmV0dXJuXG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG4gICAgLy8gaWYgaGFuZGxlciBpcyBmbiwgY2FsbCBhcyBtaWRkbGV3YXJlXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyKHJlcSwgcmVzLCBuZXh0LCBlbmQpO1xuICAgIH1cbiAgICAvLyBpZiBoYW5kbGVyIGlzIHNvbWUgb3RoZXIgdmFsdWUsIHVzZSBhcyByZXN1bHRcbiAgICByZXMucmVzdWx0ID0gaGFuZGxlcjtcbiAgICByZXR1cm4gZW5kKCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSgpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgX2VuZCkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsSWQgPSByZXEuaWQ7XG4gICAgY29uc3QgbmV3SWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgICByZXEuaWQgPSBuZXdJZDtcbiAgICByZXMuaWQgPSBuZXdJZDtcbiAgICBuZXh0KGRvbmUgPT4ge1xuICAgICAgcmVxLmlkID0gb3JpZ2luYWxJZDtcbiAgICAgIHJlcy5pZCA9IG9yaWdpbmFsSWQ7XG4gICAgICBkb25lKCk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlKGxvZ2dlcikge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBfKSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiUkVRXCIsIHJlcSwgXCJSRVNcIiwgcmVzKTtcbiAgICBuZXh0KCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmNNaWRkbGV3YXJlKSB7XG4gIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIC8vIG5leHRQcm9taXNlIGlzIHRoZSBrZXkgdG8gdGhlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gaXQgaXMgcmVzb2x2ZWQgYnkgdGhlIHJldHVybiBoYW5kbGVyIHBhc3NlZCB0byB0aGVcbiAgICAvLyBcIm5leHRcIiBmdW5jdGlvblxuICAgIGxldCByZXNvbHZlTmV4dFByb21pc2U7XG4gICAgY29uc3QgbmV4dFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJlc29sdmVOZXh0UHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbGV0IHJldHVybkhhbmRsZXJDYWxsYmFjayA9IG51bGw7XG4gICAgbGV0IG5leHRXYXNDYWxsZWQgPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgdGhlIGNvbnN1bWVyJ3MgYXN5bmMgbWlkZGxld2FyZS5cbiAgICBjb25zdCBhc3luY05leHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBuZXh0V2FzQ2FsbGVkID0gdHJ1ZTtcblxuICAgICAgLy8gV2UgcGFzcyBhIHJldHVybiBoYW5kbGVyIHRvIG5leHQoKS4gV2hlbiBpdCBpcyBjYWxsZWQgYnkgdGhlIGVuZ2luZSxcbiAgICAgIC8vIHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUgd2lsbCByZXN1bWUgZXhlY3V0aW5nLlxuXG4gICAgICBuZXh0KHJ1blJldHVybkhhbmRsZXJzQ2FsbGJhY2sgPT4ge1xuICAgICAgICAvLyBUaGlzIGNhbGxiYWNrIGNvbWVzIGZyb20gSlJQQ0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnNcbiAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrID0gcnVuUmV0dXJuSGFuZGxlcnNDYWxsYmFjaztcbiAgICAgICAgcmVzb2x2ZU5leHRQcm9taXNlKCk7XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IG5leHRQcm9taXNlO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGFzeW5jTWlkZGxld2FyZShyZXEsIHJlcywgYXN5bmNOZXh0KTtcbiAgICAgIGlmIChuZXh0V2FzQ2FsbGVkKSB7XG4gICAgICAgIGF3YWl0IG5leHRQcm9taXNlOyAvLyB3ZSBtdXN0IHdhaXQgdW50aWwgdGhlIHJldHVybiBoYW5kbGVyIGlzIGNhbGxlZFxuICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2sobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQobnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGVycjtcbiAgICAgIGlmIChyZXR1cm5IYW5kbGVyQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEEgSlNPTi1SUEMgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcHJvY2Vzc29yLlxuICogR2l2ZSBpdCBhIHN0YWNrIG9mIG1pZGRsZXdhcmUsIHBhc3MgaXQgcmVxdWVzdHMsIGFuZCBnZXQgYmFjayByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEpSUENFbmdpbmUgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWlkZGxld2FyZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX21pZGRsZXdhcmUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxseSBleGVjdXRlcyB0aGUgZ2l2ZW4gc3RhY2sgb2YgbWlkZGxld2FyZS5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYW55IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBtaWRkbGV3YXJlIGV4ZWN1dGlvbixcbiAgICogYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCB3YXMgY29tcGxldGVkLCBhbmQgYW4gYXJyYXkgb2ZcbiAgICogbWlkZGxld2FyZS1kZWZpbmVkIHJldHVybiBoYW5kbGVycy5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBfcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZVN0YWNrKSB7XG4gICAgY29uc3QgcmV0dXJuSGFuZGxlcnMgPSBbXTtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAvLyBHbyBkb3duIHN0YWNrIG9mIG1pZGRsZXdhcmUsIGNhbGwgYW5kIGNvbGxlY3Qgb3B0aW9uYWwgcmV0dXJuSGFuZGxlcnNcbiAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2YgbWlkZGxld2FyZVN0YWNrKSB7XG4gICAgICBbZXJyb3IsIGlzQ29tcGxldGVdID0gYXdhaXQgSlJQQ0VuZ2luZS5fcnVuTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZSwgcmV0dXJuSGFuZGxlcnMpO1xuICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbZXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzLnJldmVyc2UoKV07XG4gIH1cblxuICAvKipcbiAgICogUnVucyBhbiBpbmRpdmlkdWFsIG1pZGRsZXdhcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdXRpb24sXG4gICAqIGFuZCBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZXF1ZXN0IHNob3VsZCBlbmQuXG4gICAqL1xuICBzdGF0aWMgX3J1bk1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmUsIHJldHVybkhhbmRsZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgZW5kID0gZXJyID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBlcnIgfHwgcmVzLmVycm9yO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKGVycm9yKS5pbmNsdWRlcyhcInN0YWNrXCIpID09PSBmYWxzZSkgZXJyb3Iuc3RhY2sgPSBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCI7XG4gICAgICAgICAgcmVzLmVycm9yID0gc2VyaWFsaXplRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHNob3VsZEluY2x1ZGVTdGFjazogdHJ1ZSxcbiAgICAgICAgICAgIGZhbGxiYWNrRXJyb3I6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSB8fCAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICBjb2RlOiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpIHx8IC0zMjYwMyxcbiAgICAgICAgICAgICAgc3RhY2s6IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3Iuc3RhY2spIHx8IFwiU3RhY2sgdHJhY2UgaXMgbm90IGF2YWlsYWJsZS5cIixcbiAgICAgICAgICAgICAgZGF0YTogKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5kYXRhKSB8fCAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpIHx8IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IHNob3VsZCBlbmRcbiAgICAgICAgcmVzb2x2ZShbZXJyb3IsIHRydWVdKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXh0ID0gcmV0dXJuSGFuZGxlciA9PiB7XG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICBlbmQocmVzLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmV0dXJuSGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXR1cm5IYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgZW5kKG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSlJQQ0VuZ2luZTogJ25leHQnIHJldHVybiBoYW5kbGVycyBtdXN0IGJlIGZ1bmN0aW9uc1wiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybkhhbmRsZXJzLnB1c2gocmV0dXJuSGFuZGxlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3Qgc2hvdWxkIG5vdCBlbmRcbiAgICAgICAgICByZXNvbHZlKFtudWxsLCBmYWxzZV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCwgZW5kKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGVuZChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsbHkgZXhlY3V0ZXMgYXJyYXkgb2YgcmV0dXJuIGhhbmRsZXJzLiBUaGUgcmVxdWVzdCBhbmQgcmVzcG9uc2UgYXJlXG4gICAqIGFzc3VtZWQgdG8gYmUgaW4gdGhlaXIgc2NvcGUuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgX3J1blJldHVybkhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGhhbmRsZXIoZXJyID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciwgb3IgaWZcbiAgICogdGhlIFwiaXNDb21wbGV0ZVwiIGZsYWcgaXMgZmFsc3kuXG4gICAqL1xuICBzdGF0aWMgX2NoZWNrRm9yQ29tcGxldGlvbihfcmVxLCByZXMsIGlzQ29tcGxldGUpIHtcbiAgICBpZiAoIShcInJlc3VsdFwiIGluIHJlcykgJiYgIShcImVycm9yXCIgaW4gcmVzKSkge1xuICAgICAgdGhyb3cgbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICBtZXNzYWdlOiBcIlJlc3BvbnNlIGhhcyBubyBlcnJvciBvciByZXN1bHQgZm9yIHJlcXVlc3RcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaXNDb21wbGV0ZSkge1xuICAgICAgdGhyb3cgbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICBtZXNzYWdlOiBcIk5vdGhpbmcgZW5kZWQgcmVxdWVzdFwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0byB0aGUgZW5naW5lJ3MgbWlkZGxld2FyZSBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIG1pZGRsZXdhcmUgLSBUaGUgbWlkZGxld2FyZSBmdW5jdGlvbiB0byBhZGQuXG4gICAqL1xuICBwdXNoKG1pZGRsZXdhcmUpIHtcbiAgICB0aGlzLl9taWRkbGV3YXJlLnB1c2gobWlkZGxld2FyZSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgSlNPTi1SUEMgcmVxdWVzdCwgYW5kIHJldHVybiBhIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQW4gZXJyb3ItZmlyc3QgY2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIHJlc3BvbnNlLlxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIGFuIGFycmF5IG9mIEpTT04tUlBDIHJlcXVlc3RzLCBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIHJlc3BvbnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdHMgdG8gaGFuZGxlLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBbiBlcnJvci1maXJzdCBjYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgYXJyYXkgb2ZcbiAgICogcmVzcG9uc2VzLlxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIGEgSlNPTi1SUEMgcmVxdWVzdCwgYW5kIHJldHVybiBhIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IHRvIGhhbmRsZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UsIG9yIHJlamVjdHMgd2l0aCBhblxuICAgKiBlcnJvci5cbiAgICovXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbiBhcnJheSBvZiBKU09OLVJQQyByZXF1ZXN0cywgYW5kIHJldHVybiBhbiBhcnJheSBvZiByZXNwb25zZXMuXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3RzIHRvIGhhbmRsZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYXJyYXkgb2YgcmVzcG9uc2VzLCBvciByZWplY3RzXG4gICAqIHdpdGggYW4gZXJyb3IuXG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGhhbmRsZShyZXEsIGNiKSB7XG4gICAgaWYgKGNiICYmIHR5cGVvZiBjYiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY2FsbGJhY2tcIiBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcSkpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQmF0Y2gocmVxLCBjYik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlQmF0Y2gocmVxKTtcbiAgICB9XG4gICAgaWYgKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlKHJlcSwgY2IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZUhhbmRsZShyZXEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBlbmdpbmUgYXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHB1c2hlZCB0byBvdGhlclxuICAgKiBlbmdpbmVzLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGlzIGVuZ2luZSBhcyBhIG1pZGRsZXdhcmUgZnVuY3Rpb24uXG4gICAqL1xuICBhc01pZGRsZXdhcmUoKSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbbWlkZGxld2FyZUVycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVyc10gPSBhd2FpdCBKUlBDRW5naW5lLl9ydW5BbGxNaWRkbGV3YXJlKHJlcSwgcmVzLCB0aGlzLl9taWRkbGV3YXJlKTtcbiAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICBhd2FpdCBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7XG4gICAgICAgICAgcmV0dXJuIGVuZChtaWRkbGV3YXJlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KGFzeW5jIGhhbmRsZXJDYWxsYmFjayA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJDYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBoYW5kbGVyQ2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExpa2UgX2hhbmRsZSwgYnV0IGZvciBiYXRjaCByZXF1ZXN0cy5cbiAgICovXG5cbiAgLyoqXG4gICAqIExpa2UgX2hhbmRsZSwgYnV0IGZvciBiYXRjaCByZXF1ZXN0cy5cbiAgICovXG5cbiAgYXN5bmMgX2hhbmRsZUJhdGNoKHJlcXMsIGNiKSB7XG4gICAgLy8gVGhlIG9yZGVyIGhlcmUgaXMgaW1wb3J0YW50XG4gICAgdHJ5IHtcbiAgICAgIC8vIDIuIFdhaXQgZm9yIGFsbCByZXF1ZXN0cyB0byBmaW5pc2gsIG9yIHRocm93IG9uIHNvbWUga2luZCBvZiBmYXRhbFxuICAgICAgLy8gZXJyb3JcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgLy8gMS4gQmVnaW4gZXhlY3V0aW5nIGVhY2ggcmVxdWVzdCBpbiB0aGUgb3JkZXIgcmVjZWl2ZWRcbiAgICAgIHJlcXMubWFwKHRoaXMuX3Byb21pc2VIYW5kbGUuYmluZCh0aGlzKSkpO1xuXG4gICAgICAvLyAzLiBSZXR1cm4gYmF0Y2ggcmVzcG9uc2VcbiAgICAgIGlmIChjYikge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgcmVzcG9uc2VzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZXM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICByZXR1cm4gY2IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgcHJvbWlzZS13cmFwcGVkIF9oYW5kbGUuXG4gICAqL1xuICBfcHJvbWlzZUhhbmRsZShyZXEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlKHJlcSwgKF9lcnIsIHJlcykgPT4ge1xuICAgICAgICAvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhIHJlc3BvbnNlLCBhbmQgaXQgd2lsbCBhbHdheXMgaGF2ZSBhbnkgZXJyb3JcbiAgICAgICAgLy8gdGhhdCBpcyBjYXVnaHQgYW5kIHByb3BhZ2F0ZWQuXG4gICAgICAgIGlmIChfZXJyICYmIHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVqZWN0KF9lcnIpO1xuICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXMpO1xuICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgdGhlIHJlcXVlc3Qgb2JqZWN0IGlzIHZhbGlkLCBwcm9jZXNzZXMgaXQsIGFuZCBwYXNzZXMgYW55XG4gICAqIGVycm9yIGFuZCB0aGUgcmVzcG9uc2Ugb2JqZWN0IHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICpcbiAgICogRG9lcyBub3QgcmVqZWN0LlxuICAgKi9cbiAgYXN5bmMgX2hhbmRsZShjYWxsZXJSZXEsIGNiKSB7XG4gICAgaWYgKCFjYWxsZXJSZXEgfHwgQXJyYXkuaXNBcnJheShjYWxsZXJSZXEpIHx8IHR5cGVvZiBjYWxsZXJSZXEgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICBtZXNzYWdlOiBcInJlcXVlc3QgbXVzdCBiZSBwbGFpbiBvYmplY3RcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2IoZXJyb3IsIHtcbiAgICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxlclJlcS5tZXRob2QgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICBtZXNzYWdlOiBcIm1ldGhvZCBtdXN0IGJlIHN0cmluZ1wiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYihlcnJvciwge1xuICAgICAgICBpZDogY2FsbGVyUmVxLmlkLFxuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcSA9IF9vYmplY3RTcHJlYWQoe30sIGNhbGxlclJlcSk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjXG4gICAgfTtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAvLyBBIHJlcXVlc3QgaGFuZGxlciBlcnJvciwgYSByZS10aHJvd24gbWlkZGxld2FyZSBlcnJvciwgb3Igc29tZXRoaW5nXG4gICAgICAvLyB1bmV4cGVjdGVkLlxuICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgLy8gRW5zdXJlIG5vIHJlc3VsdCBpcyBwcmVzZW50IG9uIGFuIGVycm9yZWQgcmVzcG9uc2VcbiAgICAgIGRlbGV0ZSByZXMucmVzdWx0O1xuICAgICAgaWYgKCFyZXMuZXJyb3IpIHtcbiAgICAgICAgdmFyIF9lcnJvcjIsIF9lcnJvcjMsIF9lcnJvcjQsIF9lcnJvcjUsIF9lcnJvcjYsIF9lcnJvcjcsIF9lcnJvcjg7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoZXJyb3IpLmluY2x1ZGVzKFwic3RhY2tcIikgPT09IGZhbHNlKSBlcnJvci5zdGFjayA9IFwiU3RhY2sgdHJhY2UgaXMgbm90IGF2YWlsYWJsZS5cIjtcbiAgICAgICAgcmVzLmVycm9yID0gc2VyaWFsaXplRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICBzaG91bGRJbmNsdWRlU3RhY2s6IHRydWUsXG4gICAgICAgICAgZmFsbGJhY2tFcnJvcjoge1xuICAgICAgICAgICAgbWVzc2FnZTogKChfZXJyb3IyID0gZXJyb3IpID09PSBudWxsIHx8IF9lcnJvcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvcjIubWVzc2FnZSkgfHwgKChfZXJyb3IzID0gZXJyb3IpID09PSBudWxsIHx8IF9lcnJvcjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvcjMudG9TdHJpbmcoKSksXG4gICAgICAgICAgICBjb2RlOiAoKF9lcnJvcjQgPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yNC5jb2RlKSB8fCAtMzI2MDMsXG4gICAgICAgICAgICBzdGFjazogKChfZXJyb3I1ID0gZXJyb3IpID09PSBudWxsIHx8IF9lcnJvcjUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvcjUuc3RhY2spIHx8IFwiU3RhY2sgdHJhY2UgaXMgbm90IGF2YWlsYWJsZS5cIixcbiAgICAgICAgICAgIGRhdGE6ICgoX2Vycm9yNiA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3I2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3I2LmRhdGEpIHx8ICgoX2Vycm9yNyA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3I3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3I3Lm1lc3NhZ2UpIHx8ICgoX2Vycm9yOCA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3I4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3I4LnRvU3RyaW5nKCkpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNiKGVycm9yLCByZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB0aGUgZ2l2ZW4gcmVxdWVzdCBhbmQgcmVzcG9uc2UsIHJ1bnMgYWxsIG1pZGRsZXdhcmUgYW5kIHRoZWlyIHJldHVyblxuICAgKiBoYW5kbGVycywgaWYgYW55LCBhbmQgZW5zdXJlcyB0aGF0IGludGVybmFsIHJlcXVlc3QgcHJvY2Vzc2luZyBzZW1hbnRpY3NcbiAgICogYXJlIHNhdGlzZmllZC5cbiAgICovXG4gIGFzeW5jIF9wcm9jZXNzUmVxdWVzdChyZXEsIHJlcykge1xuICAgIGNvbnN0IFtlcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnNdID0gYXdhaXQgSlJQQ0VuZ2luZS5fcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgdGhpcy5fbWlkZGxld2FyZSk7XG5cbiAgICAvLyBUaHJvdyBpZiBcImVuZFwiIHdhcyBub3QgY2FsbGVkLCBvciBpZiB0aGUgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHRcbiAgICAvLyBub3IgYW4gZXJyb3IuXG4gICAgSlJQQ0VuZ2luZS5fY2hlY2tGb3JDb21wbGV0aW9uKHJlcSwgcmVzLCBpc0NvbXBsZXRlKTtcblxuICAgIC8vIFRoZSByZXR1cm4gaGFuZGxlcnMgc2hvdWxkIHJ1biBldmVuIGlmIGFuIGVycm9yIHdhcyBlbmNvdW50ZXJlZCBkdXJpbmdcbiAgICAvLyBtaWRkbGV3YXJlIHByb2Nlc3NpbmcuXG4gICAgYXdhaXQgSlJQQ0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xuXG4gICAgLy8gTm93IHdlIHJlLXRocm93IHRoZSBtaWRkbGV3YXJlIHByb2Nlc3NpbmcgZXJyb3IsIGlmIGFueSwgdG8gY2F0Y2ggaXRcbiAgICAvLyBmdXJ0aGVyIHVwIHRoZSBjYWxsIGNoYWluLlxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtZXJnZU1pZGRsZXdhcmUobWlkZGxld2FyZVN0YWNrKSB7XG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBKUlBDRW5naW5lKCk7XG4gIG1pZGRsZXdhcmVTdGFjay5mb3JFYWNoKG1pZGRsZXdhcmUgPT4gZW5naW5lLnB1c2gobWlkZGxld2FyZSkpO1xuICByZXR1cm4gZW5naW5lLmFzTWlkZGxld2FyZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW5naW5lU3RyZWFtKG9wdHMpIHtcbiAgaWYgKCFvcHRzIHx8ICFvcHRzLmVuZ2luZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZW5naW5lIHBhcmFtZXRlciFcIik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGVuZ2luZVxuICB9ID0gb3B0cztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQgc3RyZWFtO1xuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGUocmVxLCBfZW5jb2RpbmcsIGNiKSB7XG4gICAgZW5naW5lLmhhbmRsZShyZXEsIChfZXJyLCByZXMpID0+IHtcbiAgICAgIHN0cmVhbS5wdXNoKHJlcyk7XG4gICAgfSk7XG4gICAgY2IoKTtcbiAgfVxuICBzdHJlYW0gPSBuZXcgRHVwbGV4KHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIHJlYWQsXG4gICAgd3JpdGVcbiAgfSk7XG5cbiAgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXG4gIGlmIChlbmdpbmUub24pIHtcbiAgICBlbmdpbmUub24oXCJub3RpZmljYXRpb25cIiwgbWVzc2FnZSA9PiB7XG4gICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3RyZWFtO1xufVxuZnVuY3Rpb24gcHJvdmlkZXJGcm9tRW5naW5lKGVuZ2luZSkge1xuICBjb25zdCBwcm92aWRlciA9IG5ldyBTYWZlRXZlbnRFbWl0dGVyKCk7XG4gIC8vIGhhbmRsZSBib3RoIHJwYyBzZW5kIG1ldGhvZHNcbiAgcHJvdmlkZXIuc2VuZEFzeW5jID0gYXN5bmMgcmVxID0+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBlbmdpbmUuaGFuZGxlKHJlcSk7XG4gICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgdmFyIF9yZXMkZXJyb3IsIF9yZXMkZXJyb3IyLCBfcmVzJGVycm9yMywgX3JlcyRlcnJvcjQsIF9yZXMkZXJyb3I1LCBfcmVzJGVycm9yNiwgX3JlcyRlcnJvcjc7XG4gICAgICBpZiAodHlwZW9mIHJlcy5lcnJvciA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhyZXMuZXJyb3IpLmluY2x1ZGVzKFwic3RhY2tcIikgPT09IGZhbHNlKSByZXMuZXJyb3Iuc3RhY2sgPSBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCI7XG4gICAgICBjb25zdCBlcnIgPSBzZXJpYWxpemVFcnJvcihyZXMuZXJyb3IsIHtcbiAgICAgICAgZmFsbGJhY2tFcnJvcjoge1xuICAgICAgICAgIG1lc3NhZ2U6ICgoX3JlcyRlcnJvciA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvci5tZXNzYWdlKSB8fCAoKF9yZXMkZXJyb3IyID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjIudG9TdHJpbmcoKSksXG4gICAgICAgICAgY29kZTogKChfcmVzJGVycm9yMyA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvcjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3IzLmNvZGUpIHx8IC0zMjYwMyxcbiAgICAgICAgICBzdGFjazogKChfcmVzJGVycm9yNCA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvcjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3I0LnN0YWNrKSB8fCBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICAgICAgZGF0YTogKChfcmVzJGVycm9yNSA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvcjUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3I1LmRhdGEpIHx8ICgoX3JlcyRlcnJvcjYgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3I2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yNi5tZXNzYWdlKSB8fCAoKF9yZXMkZXJyb3I3ID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yNyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjcudG9TdHJpbmcoKSlcbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkSW5jbHVkZVN0YWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbChlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfTtcbiAgcHJvdmlkZXIuc2VuZCA9IChyZXEsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBjYWxsYmFjayB0byBcInNlbmRcIiBtZXRob2QuJyk7XG4gICAgfVxuICAgIGVuZ2luZS5oYW5kbGUocmVxLCBjYWxsYmFjayk7XG4gIH07XG4gIC8vIGZvcndhcmQgbm90aWZpY2F0aW9uc1xuICBpZiAoZW5naW5lLm9uKSB7XG4gICAgZW5naW5lLm9uKFwibm90aWZpY2F0aW9uXCIsIG1lc3NhZ2UgPT4ge1xuICAgICAgcHJvdmlkZXIuZW1pdChcImRhdGFcIiwgbnVsbCwgbWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgcHJvdmlkZXIucmVxdWVzdCA9IGFzeW5jIGFyZ3MgPT4ge1xuICAgIGNvbnN0IHJlcSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXJncyksIHt9LCB7XG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXG4gICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZnVuY3Rpb24gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShtaWRkbGV3YXJlKSB7XG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBKUlBDRW5naW5lKCk7XG4gIGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpO1xuICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xuICByZXR1cm4gcHJvdmlkZXI7XG59XG5mdW5jdGlvbiBwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyUmVzID0gYXdhaXQgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSk7XG4gICAgICByZXMucmVzdWx0ID0gcHJvdmlkZXJSZXM7XG4gICAgICByZXR1cm4gZW5kKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlbmQoZXJyb3IpO1xuICAgIH1cbiAgfTtcbn1cblxuY2xhc3MgU3Vic3RyZWFtIGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBwYXJlbnQsXG4gICAgICBuYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoe1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmFtZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsaWNpdGx5IHNldHMgcmVhZCBvcGVyYXRpb25zIHRvIGEgbm8tb3AuXG4gICAqL1xuICBfcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4gdG8gdGhpcyB3cml0YWJsZSBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSBjaHVuayAtIEFyYml0cmFyeSBvYmplY3QgdG8gd3JpdGVcbiAgICogQHBhcmFtIGVuY29kaW5nIC0gRW5jb2RpbmcgdG8gdXNlIHdoZW4gd3JpdGluZyBwYXlsb2FkXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxlZCB3aGVuIHdyaXRpbmcgaXMgY29tcGxldGUgb3IgYW4gZXJyb3Igb2NjdXJzXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9wYXJlbnQucHVzaCh7XG4gICAgICBuYW1lOiB0aGlzLl9uYW1lLFxuICAgICAgZGF0YTogY2h1bmtcbiAgICB9KTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmNvbnN0IElHTk9SRV9TVUJTVFJFQU0gPSBTeW1ib2woXCJJR05PUkVfU1VCU1RSRUFNXCIpO1xuY2xhc3MgT2JqZWN0TXVsdGlwbGV4IGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0cyksIHt9LCB7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdWJzdHJlYW1zXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0U3RyZWFtXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fc3Vic3RyZWFtcyA9IHt9O1xuICB9XG4gIGNyZWF0ZVN0cmVhbShuYW1lKSB7XG4gICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHN1YnN0cmVhbVxuICAgIGNvbnN0IHN1YnN0cmVhbSA9IG5ldyBTdWJzdHJlYW0oe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBzdWJzdHJlYW07XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHBhcmVudCBzdHJlYW0gdG8gZW5kXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIGFueVN0cmVhbUVuZCh0aGlzLCBfZXJyb3IgPT4gc3Vic3RyZWFtLmRlc3Ryb3koX2Vycm9yIHx8IHVuZGVmaW5lZCkpO1xuICAgIHJldHVybiBzdWJzdHJlYW07XG4gIH1cblxuICAvLyBpZ25vcmUgc3RyZWFtcyAoZG9udCBkaXNwbGF5IG9ycGhhbmVkIGRhdGEgd2FybmluZylcbiAgaWdub3JlU3RyZWFtKG5hbWUpIHtcbiAgICAvLyB2YWxpZGF0ZSBuYW1lXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3RNdWx0aXBsZXggLSBTdWJzdHJlYW0gZm9yIG5hbWUgXCIke25hbWV9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICB9XG4gICAgLy8gc2V0XG4gICAgdGhpcy5fc3Vic3RyZWFtc1tuYW1lXSA9IElHTk9SRV9TVUJTVFJFQU07XG4gIH1cbiAgX3JlYWQoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZGF0YVxuICAgIH0gPSBjaHVuaztcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG1hbGZvcm1lZCBjaHVuayB3aXRob3V0IG5hbWUgXCIke2NodW5rfVwiYCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgY29ycmVzcG9uZGluZyBzdWJzdHJlYW1cbiAgICBjb25zdCBzdWJzdHJlYW0gPSB0aGlzLl9zdWJzdHJlYW1zW25hbWVdO1xuICAgIGlmICghc3Vic3RyZWFtKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuKGBPYmplY3RNdWx0aXBsZXggLSBvcnBoYW5lZCBkYXRhIGZvciBzdHJlYW0gXCIke25hbWV9XCJgKTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8vIHB1c2ggZGF0YSBpbnRvIHN1YnN0cmVhbVxuICAgIGlmIChzdWJzdHJlYW0gIT09IElHTk9SRV9TVUJTVFJFQU0pIHtcbiAgICAgIHN1YnN0cmVhbS5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vLyB1dGlsXG5mdW5jdGlvbiBhbnlTdHJlYW1FbmQoc3RyZWFtLCBfY2IpIHtcbiAgY29uc3QgY2IgPSBvbmNlKF9jYik7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogZmFsc2VcbiAgfSwgY2IpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sIGNiKTtcbn1cbmZ1bmN0aW9uIHNldHVwTXVsdGlwbGV4KHN0cmVhbSkge1xuICBjb25zdCBtdXggPSBuZXcgT2JqZWN0TXVsdGlwbGV4KCk7XG4gIG11eC5nZXRTdHJlYW0gPSBmdW5jdGlvbiBzdHJlYW1IZWxwZXIobmFtZSkge1xuICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic3RyZWFtc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RyZWFtKG5hbWUpO1xuICB9O1xuICBwdW1wKHN0cmVhbSwgbXV4LCBzdHJlYW0sIGVyciA9PiB7XG4gICAgaWYgKGVycikgd2luZG93LmNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSk7XG4gIHJldHVybiBtdXg7XG59XG5cbmNsYXNzIFBvc3RNZXNzYWdlU3RyZWFtIGV4dGVuZHMgQmFzZVBvc3RNZXNzYWdlU3RyZWFtIHtcbiAgX3Bvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICBsZXQgb3JpZ2luQ29uc3RyYWludCA9IHRoaXMuX3RhcmdldE9yaWdpbjtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGRhdGFPYmogPSBkYXRhO1xuICAgICAgaWYgKHR5cGVvZiBkYXRhT2JqLmRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgZGF0YU9iakRhdGEgPSBkYXRhT2JqLmRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFPYmpEYXRhLnBhcmFtcykgJiYgZGF0YU9iakRhdGEucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBkYXRhT2JqRGF0YVBhcmFtID0gZGF0YU9iakRhdGEucGFyYW1zWzBdO1xuICAgICAgICAgIGlmIChkYXRhT2JqRGF0YVBhcmFtLl9vcmlnaW4pIHtcbiAgICAgICAgICAgIG9yaWdpbkNvbnN0cmFpbnQgPSBkYXRhT2JqRGF0YVBhcmFtLl9vcmlnaW47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIGEgY29uc3RyYWludCBmb3IgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgZGF0YU9iakRhdGFQYXJhbS5fb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl90YXJnZXRXaW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsXG4gICAgICBkYXRhXG4gICAgfSwgb3JpZ2luQ29uc3RyYWludCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmFzZVBvc3RNZXNzYWdlU3RyZWFtLCBFdGhlcmV1bVByb3ZpZGVyRXJyb3IsIElHTk9SRV9TVUJTVFJFQU0sIEpSUENFbmdpbmUsIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFLCBKc29uUnBjRXJyb3IsIE9iamVjdE11bHRpcGxleCwgUG9zdE1lc3NhZ2VTdHJlYW0sIFNhZmVFdmVudEVtaXR0ZXIsIFNlcmlhbGl6YWJsZUVycm9yLCBTdWJzdHJlYW0sIGNyZWF0ZUFzeW5jTWlkZGxld2FyZSwgY3JlYXRlRW5naW5lU3RyZWFtLCBjcmVhdGVFcnJvck1pZGRsZXdhcmUsIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlLCBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlLCBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUsIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUsIGRhdGFIYXNDYXVzZSwgZXJyb3JDb2RlcywgZXJyb3JWYWx1ZXMsIGdldE1lc3NhZ2VGcm9tQ29kZSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrLCBpc09iamVjdCwgaXNQbGFpbk9iamVjdCwgaXNWYWxpZENvZGUsIGlzVmFsaWRTdHJpbmcsIG1lcmdlTWlkZGxld2FyZSwgcHJvdmlkZXJBc01pZGRsZXdhcmUsIHByb3ZpZGVyRXJyb3JzLCBwcm92aWRlckZyb21FbmdpbmUsIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUsIHJwY0Vycm9ycywgc2VyaWFsaXplQ2F1c2UsIHNlcmlhbGl6ZUVycm9yLCBzZXR1cE11bHRpcGxleCB9O1xuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIkR1cGxleCIsInNhZmVTdHJpbmdpZnkiLCJfb2JqZWN0U3ByZWFkIiwiRXZlbnRFbWl0dGVyIiwiZW9zIiwib25jZSIsInB1bXAiLCJub29wIiwidW5kZWZpbmVkIiwiU1lOIiwiQUNLIiwiQlJLIiwiQmFzZVBvc3RNZXNzYWdlU3RyZWFtIiwiY29uc3RydWN0b3IiLCJfcmVmIiwibmFtZSIsInRhcmdldCIsInRhcmdldFdpbmRvdyIsIndpbmRvdyIsInRhcmdldE9yaWdpbiIsIm9iamVjdE1vZGUiLCJFcnJvciIsIl9pbml0IiwiX2hhdmVTeW4iLCJfbmFtZSIsIl90YXJnZXQiLCJfdGFyZ2V0V2luZG93IiwiX3RhcmdldE9yaWdpbiIsIl9vbk1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJiaW5kIiwiX3N5bkludGVydmFsSWQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2hhbmRTaGFrZSIsIl9icmVhayIsImNvcmsiLCJfd3JpdGUiLCJfb25EYXRhIiwiZGF0YSIsInVuY29yayIsInB1c2giLCJlcnIiLCJlbWl0IiwiX3Bvc3RNZXNzYWdlIiwib3JpZ2luQ29uc3RyYWludCIsInBvc3RNZXNzYWdlIiwiZXZlbnQiLCJtZXNzYWdlIiwib3JpZ2luIiwic291cmNlIiwiX3JlYWQiLCJfIiwiY2IiLCJfZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlcnJvckNvZGVzIiwicnBjIiwiaW52YWxpZElucHV0IiwicmVzb3VyY2VOb3RGb3VuZCIsInJlc291cmNlVW5hdmFpbGFibGUiLCJ0cmFuc2FjdGlvblJlamVjdGVkIiwibWV0aG9kTm90U3VwcG9ydGVkIiwibGltaXRFeGNlZWRlZCIsInBhcnNlIiwiaW52YWxpZFJlcXVlc3QiLCJtZXRob2ROb3RGb3VuZCIsImludmFsaWRQYXJhbXMiLCJpbnRlcm5hbCIsInByb3ZpZGVyIiwidXNlclJlamVjdGVkUmVxdWVzdCIsInVuYXV0aG9yaXplZCIsInVuc3VwcG9ydGVkTWV0aG9kIiwiZGlzY29ubmVjdGVkIiwiY2hhaW5EaXNjb25uZWN0ZWQiLCJlcnJvclZhbHVlcyIsInN0YW5kYXJkIiwiRkFMTEJBQ0tfRVJST1JfQ09ERSIsIkZBTExCQUNLX01FU1NBR0UiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSIsImlzVmFsaWRDb2RlIiwiY29kZSIsIk51bWJlciIsImlzSW50ZWdlciIsImlzVmFsaWRTdHJpbmciLCJ2YWx1ZSIsImxlbmd0aCIsImlzT2JqZWN0IiwiQm9vbGVhbiIsIkFycmF5IiwiaXNBcnJheSIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiaXNKc29uUnBjU2VydmVyRXJyb3IiLCJpc0pzb25ScGNFcnJvciIsImNhc3RWYWx1ZSIsInN0YWNrIiwiZ2V0TWVzc2FnZUZyb21Db2RlIiwiZmFsbGJhY2tNZXNzYWdlIiwiYXJndW1lbnRzIiwiY29kZVN0cmluZyIsInRvU3RyaW5nIiwiaGFzT3duIiwiRkFMTEJBQ0tfRVJST1IiLCJpc1ZhbGlkSnNvbiIsInN0ciIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdHJLZXkiLCJzdHJWYWwiLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiZSIsInNlcmlhbGl6ZU9iamVjdCIsIm9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJzZXJpYWxpemVDYXVzZSIsImVycm9yIiwibWFwIiwiZW50cnkiLCJidWlsZEVycm9yIiwiZmFsbGJhY2tFcnJvciIsInNlcmlhbGl6ZSIsImNhdXNlIiwiZmFsbGJhY2tXaXRoQ2F1c2UiLCJzZXJpYWxpemVFcnJvciIsInNob3VsZEluY2x1ZGVTdGFjayIsInNlcmlhbGl6ZWQiLCJkYXRhSGFzQ2F1c2UiLCJpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlIiwic3RyaW5naWZ5UmVwbGFjZXIiLCJKc29uUnBjRXJyb3IiLCJhc3NpZ24iLCJFdGhlcmV1bVByb3ZpZGVyRXJyb3IiLCJwYXJzZU9wdHMiLCJhcmciLCJnZXRKc29uUnBjRXJyb3IiLCJnZXRFdGhQcm92aWRlckVycm9yIiwicnBjRXJyb3JzIiwic2VydmVyIiwib3B0cyIsInByb3ZpZGVyRXJyb3JzIiwiY3VzdG9tIiwic2FmZUFwcGx5IiwiaGFuZGxlciIsImNvbnRleHQiLCJhcmdzIiwiUmVmbGVjdCIsImFwcGx5Iiwic2V0VGltZW91dCIsImFycmF5Q2xvbmUiLCJhcnIiLCJuIiwiY29weSIsImkiLCJTYWZlRXZlbnRFbWl0dGVyIiwidHlwZSIsImRvRXJyb3IiLCJldmVudHMiLCJfZXZlbnRzIiwiX2xlbiIsIl9rZXkiLCJlciIsImxlbiIsImxpc3RlbmVycyIsIlNlcmlhbGl6YWJsZUVycm9yIiwiZ2V0UnBjUHJvbWlzZUNhbGxiYWNrIiwicmVzb2x2ZSIsInJlamVjdCIsInVud3JhcFJlc3VsdCIsInJlc3BvbnNlIiwicmVzdWx0IiwiY3JlYXRlRXJyb3JNaWRkbGV3YXJlIiwibG9nIiwicmVxIiwicmVzIiwibmV4dCIsImVuZCIsIm1ldGhvZCIsImRvbmUiLCJjcmVhdGVTdHJlYW1NaWRkbGV3YXJlIiwiaWRNYXAiLCJyZWFkTm9vcCIsInByb2Nlc3NSZXNwb25zZSIsImlkIiwicHJvY2Vzc05vdGlmaWNhdGlvbiIsInByb2Nlc3NNZXNzYWdlIiwiX2VuY29kaW5nIiwiaXNOb3RpZmljYXRpb24iLCJfZXJyIiwic3RyZWFtIiwicmVhZCIsIndyaXRlIiwibWlkZGxld2FyZSIsImNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSIsImhhbmRsZXJzIiwiY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUiLCJfZW5kIiwib3JpZ2luYWxJZCIsIm5ld0lkIiwiTWF0aCIsInJhbmRvbSIsInNsaWNlIiwiY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSIsImxvZ2dlciIsImRlYnVnIiwiY3JlYXRlQXN5bmNNaWRkbGV3YXJlIiwiYXN5bmNNaWRkbGV3YXJlIiwicmVzb2x2ZU5leHRQcm9taXNlIiwibmV4dFByb21pc2UiLCJQcm9taXNlIiwicmV0dXJuSGFuZGxlckNhbGxiYWNrIiwibmV4dFdhc0NhbGxlZCIsImFzeW5jTmV4dCIsInJ1blJldHVybkhhbmRsZXJzQ2FsbGJhY2siLCJKUlBDRW5naW5lIiwiX21pZGRsZXdhcmUiLCJfcnVuQWxsTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVTdGFjayIsInJldHVybkhhbmRsZXJzIiwiaXNDb21wbGV0ZSIsIl9ydW5NaWRkbGV3YXJlIiwicmV2ZXJzZSIsImtleXMiLCJpbmNsdWRlcyIsInJldHVybkhhbmRsZXIiLCJfcnVuUmV0dXJuSGFuZGxlcnMiLCJfY2hlY2tGb3JDb21wbGV0aW9uIiwiX3JlcSIsImhhbmRsZSIsIl9oYW5kbGVCYXRjaCIsIl9oYW5kbGUiLCJfcHJvbWlzZUhhbmRsZSIsImFzTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVFcnJvciIsImhhbmRsZXJDYWxsYmFjayIsInJlcXMiLCJyZXNwb25zZXMiLCJhbGwiLCJjYXRjaCIsImNhbGxlclJlcSIsImpzb25ycGMiLCJfcHJvY2Vzc1JlcXVlc3QiLCJfZXJyb3IiLCJfZXJyb3IyIiwiX2Vycm9yMyIsIl9lcnJvcjQiLCJfZXJyb3I1IiwiX2Vycm9yNiIsIl9lcnJvcjciLCJfZXJyb3I4IiwibWVyZ2VNaWRkbGV3YXJlIiwiZW5naW5lIiwiZm9yRWFjaCIsImNyZWF0ZUVuZ2luZVN0cmVhbSIsIm9uIiwicHJvdmlkZXJGcm9tRW5naW5lIiwic2VuZEFzeW5jIiwiX3JlcyRlcnJvciIsIl9yZXMkZXJyb3IyIiwiX3JlcyRlcnJvcjMiLCJfcmVzJGVycm9yNCIsIl9yZXMkZXJyb3I1IiwiX3JlcyRlcnJvcjYiLCJfcmVzJGVycm9yNyIsInNlbmQiLCJjYWxsYmFjayIsInJlcXVlc3QiLCJwcm92aWRlckZyb21NaWRkbGV3YXJlIiwicHJvdmlkZXJBc01pZGRsZXdhcmUiLCJfbmV4dCIsInByb3ZpZGVyUmVzIiwiU3Vic3RyZWFtIiwicGFyZW50IiwiX3BhcmVudCIsImNodW5rIiwiSUdOT1JFX1NVQlNUUkVBTSIsIlN5bWJvbCIsIk9iamVjdE11bHRpcGxleCIsIl9zdWJzdHJlYW1zIiwiY3JlYXRlU3RyZWFtIiwic3Vic3RyZWFtIiwiYW55U3RyZWFtRW5kIiwiZGVzdHJveSIsImlnbm9yZVN0cmVhbSIsImNvbnNvbGUiLCJ3YXJuIiwiX2NiIiwicmVhZGFibGUiLCJ3cml0YWJsZSIsInNldHVwTXVsdGlwbGV4IiwibXV4IiwiZ2V0U3RyZWFtIiwic3RyZWFtSGVscGVyIiwiUG9zdE1lc3NhZ2VTdHJlYW0iLCJkYXRhT2JqIiwiZGF0YU9iakRhdGEiLCJwYXJhbXMiLCJkYXRhT2JqRGF0YVBhcmFtIiwiX29yaWdpbiIsImxvY2F0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD_ENV: () => (/* binding */ BUILD_ENV),\n/* harmony export */   BrowserStorage: () => (/* binding */ BrowserStorage),\n/* harmony export */   LANGUAGES: () => (/* binding */ LANGUAGES),\n/* harmony export */   LANGUAGE_MAP: () => (/* binding */ LANGUAGE_MAP),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   MFA_FACTOR: () => (/* binding */ MFA_FACTOR),\n/* harmony export */   MFA_LEVELS: () => (/* binding */ MFA_LEVELS),\n/* harmony export */   MemoryStore: () => (/* binding */ MemoryStore),\n/* harmony export */   OPENLOGIN_ACTIONS: () => (/* binding */ OPENLOGIN_ACTIONS),\n/* harmony export */   OPENLOGIN_NETWORK: () => (/* binding */ OPENLOGIN_NETWORK),\n/* harmony export */   SUPPORTED_KEY_CURVES: () => (/* binding */ SUPPORTED_KEY_CURVES),\n/* harmony export */   THEME_MODES: () => (/* binding */ THEME_MODES),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* reexport safe */ _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* reexport safe */ _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   UX_MODE: () => (/* binding */ UX_MODE),\n/* harmony export */   applyWhiteLabelTheme: () => (/* binding */ applyWhiteLabelTheme),\n/* harmony export */   base64toJSON: () => (/* binding */ base64toJSON),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   generateWhiteLabelTheme: () => (/* binding */ generateWhiteLabelTheme),\n/* harmony export */   getColorsList: () => (/* binding */ getColorsList),\n/* harmony export */   jsonToBase64: () => (/* binding */ jsonToBase64),\n/* harmony export */   safeatob: () => (/* binding */ safeatob),\n/* harmony export */   safebtoa: () => (/* binding */ safebtoa),\n/* harmony export */   storageAvailable: () => (/* binding */ storageAvailable),\n/* harmony export */   storeKey: () => (/* binding */ storeKey)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url */ \"(ssr)/./node_modules/base64url/index.js\");\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(base64url__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/constants */ \"(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! color */ \"(ssr)/./node_modules/color/index.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(color__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\nconst base64url = (base64url__WEBPACK_IMPORTED_MODULE_1___default());\nfunction safebtoa(str) {\n    return base64url.encode(str);\n}\nfunction safeatob(str) {\n    // Going backwards: from bytestream, to percent-encoding, to original string.\n    return base64url.decode(str);\n}\nfunction base64toJSON(b64str) {\n    return JSON.parse(base64url.decode(b64str));\n}\nfunction jsonToBase64(json) {\n    return base64url.encode(JSON.stringify(json));\n}\nfunction storageAvailable(type) {\n    let storageExists = false;\n    let storageLength = 0;\n    let storage;\n    try {\n        storage = window[type];\n        storageExists = true;\n        storageLength = storage.length;\n        const x = \"__storage_test__\";\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    } catch (err) {\n        const error = err;\n        return error && // everything except Firefox\n        (error.code === 22 || // Firefox\n        error.code === 1014 || // test name field too, because code might not be present\n        // everything except Firefox\n        error.name === \"QuotaExceededError\" || // Firefox\n        error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n        storageExists && storageLength !== 0;\n    }\n}\nclass MemoryStore {\n    constructor(){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"store\", new Map());\n    }\n    getItem(key) {\n        return this.store.get(key) || null;\n    }\n    setItem(key, value) {\n        this.store.set(key, value);\n    }\n    removeItem(key) {\n        this.store.delete(key);\n    }\n}\nclass BrowserStorage {\n    constructor(storeKey, storage){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"storage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_storeKey\", void 0);\n        this.storage = storage;\n        this._storeKey = storeKey;\n        try {\n            if (!storage.getItem(storeKey)) {\n                this.resetStore();\n            }\n        } catch (error) {\n        // Storage is not available\n        }\n    }\n    static getInstance(key) {\n        let storageKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"local\";\n        if (!this.instanceMap.has(key)) {\n            let storage;\n            if (storageKey === \"local\" && storageAvailable(\"localStorage\")) {\n                storage = window.localStorage;\n            } else if (storageKey === \"session\" && storageAvailable(\"sessionStorage\")) {\n                storage = window.sessionStorage;\n            } else {\n                storage = new MemoryStore();\n            }\n            this.instanceMap.set(key, new this(key, storage));\n        }\n        return this.instanceMap.get(key);\n    }\n    toJSON() {\n        return this.storage.getItem(this._storeKey);\n    }\n    resetStore() {\n        const currStore = this.getStore();\n        this.storage.removeItem(this._storeKey);\n        return currStore;\n    }\n    getStore() {\n        return JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n    }\n    get(key) {\n        const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n        return store[key];\n    }\n    set(key, value) {\n        const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n        store[key] = value;\n        this.storage.setItem(this._storeKey, JSON.stringify(store));\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(BrowserStorage, \"instanceMap\", new Map());\nconst storeKey = \"openlogin_store\";\nconst UX_MODE = {\n    POPUP: \"popup\",\n    REDIRECT: \"redirect\"\n};\nconst OPENLOGIN_NETWORK = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_SAPPHIRE_NETWORK), _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_LEGACY_NETWORK);\nconst SUPPORTED_KEY_CURVES = {\n    SECP256K1: \"secp256k1\",\n    ED25519: \"ed25519\"\n};\nconst LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    FARCASTER: \"farcaster\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\",\n    SMS_PASSWORDLESS: \"sms_passwordless\",\n    WEBAUTHN: \"webauthn\",\n    JWT: \"jwt\"\n};\nconst MFA_LEVELS = {\n    DEFAULT: \"default\",\n    OPTIONAL: \"optional\",\n    MANDATORY: \"mandatory\",\n    NONE: \"none\"\n};\nconst OPENLOGIN_ACTIONS = {\n    LOGIN: \"login\",\n    ENABLE_MFA: \"enable_mfa\",\n    MANAGE_MFA: \"manage_mfa\",\n    MODIFY_SOCIAL_FACTOR: \"modify_social_factor\"\n};\nconst BUILD_ENV = {\n    PRODUCTION: \"production\",\n    DEVELOPMENT: \"development\",\n    STAGING: \"staging\",\n    TESTING: \"testing\"\n};\n/**\n * {@label loginProviderType}\n */ // autocomplete workaround https://github.com/microsoft/TypeScript/issues/29729\nconst LANGUAGES = {\n    en: \"en\",\n    ja: \"ja\",\n    ko: \"ko\",\n    de: \"de\",\n    zh: \"zh\",\n    es: \"es\",\n    fr: \"fr\",\n    pt: \"pt\",\n    nl: \"nl\",\n    tr: \"tr\"\n};\nconst LANGUAGE_MAP = {\n    en: \"english\",\n    ja: \"japanese\",\n    ko: \"korean\",\n    de: \"german\",\n    zh: \"mandarin\",\n    es: \"spanish\",\n    fr: \"french\",\n    pt: \"portuguese\",\n    nl: \"dutch\",\n    tr: \"turkish\"\n};\nconst THEME_MODES = {\n    light: \"light\",\n    dark: \"dark\",\n    auto: \"auto\"\n};\nconst MFA_FACTOR = {\n    DEVICE: \"deviceShareFactor\",\n    BACKUP_SHARE: \"backUpShareFactor\",\n    SOCIAL_BACKUP: \"socialBackupFactor\",\n    PASSWORD: \"passwordFactor\",\n    PASSKEYS: \"passkeysFactor\",\n    AUTHENTICATOR: \"authenticatorFactor\"\n};\nfunction getColorsList() {\n    let colorsAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n    let colorsShiftAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n    let mixColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"black\";\n    let rotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let saturation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;\n    let mainColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"#0346ff\";\n    const colorsList = [];\n    let step;\n    for(step = 0; step < colorsAmount; step += 1){\n        colorsList.push(color__WEBPACK_IMPORTED_MODULE_4___default()(mainColor).rotate((step + 1) / colorsAmount * -rotate).saturate((step + 1) / colorsAmount * (saturation / 100)).mix(color__WEBPACK_IMPORTED_MODULE_4___default()(mixColor), colorsShiftAmount / 100 * (step + 1) / colorsAmount).hex());\n    }\n    return colorsList;\n}\nfunction generateWhiteLabelTheme(primary) {\n    const darkSet = getColorsList(3, 50, \"black\", 0, 20, primary);\n    const lightSet = getColorsList(6, 85, \"white\", 0, 20, primary);\n    return [\n        ...darkSet.reverse(),\n        primary,\n        ...lightSet\n    ];\n}\nfunction applyWhiteLabelTheme(rootElement, theme) {\n    if (theme.primary) {\n        const themeSet = generateWhiteLabelTheme(theme.primary);\n        rootElement.style.setProperty(\"--app-primary-900\", themeSet[0]);\n        rootElement.style.setProperty(\"--app-primary-800\", themeSet[1]);\n        rootElement.style.setProperty(\"--app-primary-700\", themeSet[2]);\n        rootElement.style.setProperty(\"--app-primary-600\", themeSet[3]);\n        rootElement.style.setProperty(\"--app-primary-500\", themeSet[4]);\n        rootElement.style.setProperty(\"--app-primary-400\", themeSet[5]);\n        rootElement.style.setProperty(\"--app-primary-300\", themeSet[6]);\n        rootElement.style.setProperty(\"--app-primary-200\", themeSet[7]);\n        rootElement.style.setProperty(\"--app-primary-100\", themeSet[8]);\n        rootElement.style.setProperty(\"--app-primary-50\", themeSet[9]);\n    }\n    if (theme.onPrimary) {\n        rootElement.style.setProperty(\"--app-on-primary\", theme.onPrimary);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvZGlzdC9vcGVubG9naW5VdGlscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUMvQjtBQUM0QjtBQUNtQjtBQUNBO0FBQzFEO0FBRTFCLE1BQU1NLFlBQVlMLGtEQUFZQTtBQUM5QixTQUFTTSxTQUFTQyxHQUFHO0lBQ25CLE9BQU9GLFVBQVVHLE1BQU0sQ0FBQ0Q7QUFDMUI7QUFDQSxTQUFTRSxTQUFTRixHQUFHO0lBQ25CLDZFQUE2RTtJQUM3RSxPQUFPRixVQUFVSyxNQUFNLENBQUNIO0FBQzFCO0FBQ0EsU0FBU0ksYUFBYUMsTUFBTTtJQUMxQixPQUFPQyxLQUFLQyxLQUFLLENBQUNULFVBQVVLLE1BQU0sQ0FBQ0U7QUFDckM7QUFDQSxTQUFTRyxhQUFhQyxJQUFJO0lBQ3hCLE9BQU9YLFVBQVVHLE1BQU0sQ0FBQ0ssS0FBS0ksU0FBUyxDQUFDRDtBQUN6QztBQUNBLFNBQVNFLGlCQUFpQkMsSUFBSTtJQUM1QixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDO0lBQ0osSUFBSTtRQUNGQSxVQUFVQyxNQUFNLENBQUNKLEtBQUs7UUFDdEJDLGdCQUFnQjtRQUNoQkMsZ0JBQWdCQyxRQUFRRSxNQUFNO1FBQzlCLE1BQU1DLElBQUk7UUFDVkgsUUFBUUksT0FBTyxDQUFDRCxHQUFHQTtRQUNuQkgsUUFBUUssVUFBVSxDQUFDRjtRQUNuQixPQUFPO0lBQ1QsRUFBRSxPQUFPRyxLQUFLO1FBQ1osTUFBTUMsUUFBUUQ7UUFDZCxPQUFPQyxTQUNQLDRCQUE0QjtRQUM1QkEsQ0FBQUEsTUFBTUMsSUFBSSxLQUFLLE1BQ2YsVUFBVTtRQUNWRCxNQUFNQyxJQUFJLEtBQUssUUFDZix5REFBeUQ7UUFDekQsNEJBQTRCO1FBQzVCRCxNQUFNRSxJQUFJLEtBQUssd0JBQ2YsVUFBVTtRQUNW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cUJGLFFBQVEsQ0FBQyxFQUFFO1FBQzlERixZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxxQkFBcUJGLFFBQVEsQ0FBQyxFQUFFO1FBQzlERixZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxvQkFBb0JGLFFBQVEsQ0FBQyxFQUFFO0lBQy9EO0lBQ0EsSUFBSUQsTUFBTUksU0FBUyxFQUFFO1FBQ25CTCxZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxvQkFBb0JILE1BQU1JLFNBQVM7SUFDbkU7QUFDRjtBQUUwViIsInNvdXJjZXMiOlsid2VicGFjazovL3NvbHp6dC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi11dGlscy9kaXN0L29wZW5sb2dpblV0aWxzLmVzbS5qcz9mOTNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgYmFzZTY0dXJsTGliIGZyb20gJ2Jhc2U2NHVybCc7XG5pbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IHsgVE9SVVNfU0FQUEhJUkVfTkVUV09SSywgVE9SVVNfTEVHQUNZX05FVFdPUksgfSBmcm9tICdAdG9ydXNsYWJzL2NvbnN0YW50cyc7XG5leHBvcnQgeyBUT1JVU19MRUdBQ1lfTkVUV09SSywgVE9SVVNfU0FQUEhJUkVfTkVUV09SSyB9IGZyb20gJ0B0b3J1c2xhYnMvY29uc3RhbnRzJztcbmltcG9ydCBDb2xvciBmcm9tICdjb2xvcic7XG5cbmNvbnN0IGJhc2U2NHVybCA9IGJhc2U2NHVybExpYjtcbmZ1bmN0aW9uIHNhZmVidG9hKHN0cikge1xuICByZXR1cm4gYmFzZTY0dXJsLmVuY29kZShzdHIpO1xufVxuZnVuY3Rpb24gc2FmZWF0b2Ioc3RyKSB7XG4gIC8vIEdvaW5nIGJhY2t3YXJkczogZnJvbSBieXRlc3RyZWFtLCB0byBwZXJjZW50LWVuY29kaW5nLCB0byBvcmlnaW5hbCBzdHJpbmcuXG4gIHJldHVybiBiYXNlNjR1cmwuZGVjb2RlKHN0cik7XG59XG5mdW5jdGlvbiBiYXNlNjR0b0pTT04oYjY0c3RyKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKGJhc2U2NHVybC5kZWNvZGUoYjY0c3RyKSk7XG59XG5mdW5jdGlvbiBqc29uVG9CYXNlNjQoanNvbikge1xuICByZXR1cm4gYmFzZTY0dXJsLmVuY29kZShKU09OLnN0cmluZ2lmeShqc29uKSk7XG59XG5mdW5jdGlvbiBzdG9yYWdlQXZhaWxhYmxlKHR5cGUpIHtcbiAgbGV0IHN0b3JhZ2VFeGlzdHMgPSBmYWxzZTtcbiAgbGV0IHN0b3JhZ2VMZW5ndGggPSAwO1xuICBsZXQgc3RvcmFnZTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gd2luZG93W3R5cGVdO1xuICAgIHN0b3JhZ2VFeGlzdHMgPSB0cnVlO1xuICAgIHN0b3JhZ2VMZW5ndGggPSBzdG9yYWdlLmxlbmd0aDtcbiAgICBjb25zdCB4ID0gXCJfX3N0b3JhZ2VfdGVzdF9fXCI7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHgsIHgpO1xuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSh4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgcmV0dXJuIGVycm9yICYmIChcbiAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgZXJyb3IuY29kZSA9PT0gMjIgfHxcbiAgICAvLyBGaXJlZm94XG4gICAgZXJyb3IuY29kZSA9PT0gMTAxNCB8fFxuICAgIC8vIHRlc3QgbmFtZSBmaWVsZCB0b28sIGJlY2F1c2UgY29kZSBtaWdodCBub3QgYmUgcHJlc2VudFxuICAgIC8vIGV2ZXJ5dGhpbmcgZXhjZXB0IEZpcmVmb3hcbiAgICBlcnJvci5uYW1lID09PSBcIlF1b3RhRXhjZWVkZWRFcnJvclwiIHx8XG4gICAgLy8gRmlyZWZveFxuICAgIGVycm9yLm5hbWUgPT09IFwiTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRURcIikgJiZcbiAgICAvLyBhY2tub3dsZWRnZSBRdW90YUV4Y2VlZGVkRXJyb3Igb25seSBpZiB0aGVyZSdzIHNvbWV0aGluZyBhbHJlYWR5IHN0b3JlZFxuICAgIHN0b3JhZ2VFeGlzdHMgJiYgc3RvcmFnZUxlbmd0aCAhPT0gMDtcbiAgfVxufVxuXG5jbGFzcyBNZW1vcnlTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JlXCIsIG5ldyBNYXAoKSk7XG4gIH1cbiAgZ2V0SXRlbShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXQoa2V5KSB8fCBudWxsO1xuICB9XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3RvcmUuc2V0KGtleSwgdmFsdWUpO1xuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgdGhpcy5zdG9yZS5kZWxldGUoa2V5KTtcbiAgfVxufVxuY2xhc3MgQnJvd3NlclN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcihzdG9yZUtleSwgc3RvcmFnZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RvcmVLZXlcIiwgdm9pZCAwKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMuX3N0b3JlS2V5ID0gc3RvcmVLZXk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc3RvcmFnZS5nZXRJdGVtKHN0b3JlS2V5KSkge1xuICAgICAgICB0aGlzLnJlc2V0U3RvcmUoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlXG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZShrZXkpIHtcbiAgICBsZXQgc3RvcmFnZUtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJsb2NhbFwiO1xuICAgIGlmICghdGhpcy5pbnN0YW5jZU1hcC5oYXMoa2V5KSkge1xuICAgICAgbGV0IHN0b3JhZ2U7XG4gICAgICBpZiAoc3RvcmFnZUtleSA9PT0gXCJsb2NhbFwiICYmIHN0b3JhZ2VBdmFpbGFibGUoXCJsb2NhbFN0b3JhZ2VcIikpIHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICB9IGVsc2UgaWYgKHN0b3JhZ2VLZXkgPT09IFwic2Vzc2lvblwiICYmIHN0b3JhZ2VBdmFpbGFibGUoXCJzZXNzaW9uU3RvcmFnZVwiKSkge1xuICAgICAgICBzdG9yYWdlID0gd2luZG93LnNlc3Npb25TdG9yYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmFnZSA9IG5ldyBNZW1vcnlTdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnN0YW5jZU1hcC5zZXQoa2V5LCBuZXcgdGhpcyhrZXksIHN0b3JhZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VNYXAuZ2V0KGtleSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLl9zdG9yZUtleSk7XG4gIH1cbiAgcmVzZXRTdG9yZSgpIHtcbiAgICBjb25zdCBjdXJyU3RvcmUgPSB0aGlzLmdldFN0b3JlKCk7XG4gICAgdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5fc3RvcmVLZXkpO1xuICAgIHJldHVybiBjdXJyU3RvcmU7XG4gIH1cbiAgZ2V0U3RvcmUoKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmVLZXkpIHx8IFwie31cIik7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IHN0b3JlID0gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLl9zdG9yZUtleSkgfHwgXCJ7fVwiKTtcbiAgICByZXR1cm4gc3RvcmVba2V5XTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHN0b3JlID0gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLl9zdG9yZUtleSkgfHwgXCJ7fVwiKTtcbiAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5fc3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KHN0b3JlKSk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShCcm93c2VyU3RvcmFnZSwgXCJpbnN0YW5jZU1hcFwiLCBuZXcgTWFwKCkpO1xuXG5jb25zdCBzdG9yZUtleSA9IFwib3BlbmxvZ2luX3N0b3JlXCI7XG5jb25zdCBVWF9NT0RFID0ge1xuICBQT1BVUDogXCJwb3B1cFwiLFxuICBSRURJUkVDVDogXCJyZWRpcmVjdFwiXG59O1xuY29uc3QgT1BFTkxPR0lOX05FVFdPUksgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIFRPUlVTX1NBUFBISVJFX05FVFdPUkspLCBUT1JVU19MRUdBQ1lfTkVUV09SSyk7XG5jb25zdCBTVVBQT1JURURfS0VZX0NVUlZFUyA9IHtcbiAgU0VDUDI1NksxOiBcInNlY3AyNTZrMVwiLFxuICBFRDI1NTE5OiBcImVkMjU1MTlcIlxufTtcbmNvbnN0IExPR0lOX1BST1ZJREVSID0ge1xuICBHT09HTEU6IFwiZ29vZ2xlXCIsXG4gIEZBQ0VCT09LOiBcImZhY2Vib29rXCIsXG4gIFJFRERJVDogXCJyZWRkaXRcIixcbiAgRElTQ09SRDogXCJkaXNjb3JkXCIsXG4gIFRXSVRDSDogXCJ0d2l0Y2hcIixcbiAgQVBQTEU6IFwiYXBwbGVcIixcbiAgTElORTogXCJsaW5lXCIsXG4gIEdJVEhVQjogXCJnaXRodWJcIixcbiAgS0FLQU86IFwia2FrYW9cIixcbiAgTElOS0VESU46IFwibGlua2VkaW5cIixcbiAgVFdJVFRFUjogXCJ0d2l0dGVyXCIsXG4gIFdFSUJPOiBcIndlaWJvXCIsXG4gIFdFQ0hBVDogXCJ3ZWNoYXRcIixcbiAgRkFSQ0FTVEVSOiBcImZhcmNhc3RlclwiLFxuICBFTUFJTF9QQVNTV09SRExFU1M6IFwiZW1haWxfcGFzc3dvcmRsZXNzXCIsXG4gIFNNU19QQVNTV09SRExFU1M6IFwic21zX3Bhc3N3b3JkbGVzc1wiLFxuICBXRUJBVVRITjogXCJ3ZWJhdXRoblwiLFxuICBKV1Q6IFwiand0XCJcbn07XG5jb25zdCBNRkFfTEVWRUxTID0ge1xuICBERUZBVUxUOiBcImRlZmF1bHRcIixcbiAgT1BUSU9OQUw6IFwib3B0aW9uYWxcIixcbiAgTUFOREFUT1JZOiBcIm1hbmRhdG9yeVwiLFxuICBOT05FOiBcIm5vbmVcIlxufTtcbmNvbnN0IE9QRU5MT0dJTl9BQ1RJT05TID0ge1xuICBMT0dJTjogXCJsb2dpblwiLFxuICBFTkFCTEVfTUZBOiBcImVuYWJsZV9tZmFcIixcbiAgTUFOQUdFX01GQTogXCJtYW5hZ2VfbWZhXCIsXG4gIE1PRElGWV9TT0NJQUxfRkFDVE9SOiBcIm1vZGlmeV9zb2NpYWxfZmFjdG9yXCJcbn07XG5jb25zdCBCVUlMRF9FTlYgPSB7XG4gIFBST0RVQ1RJT046IFwicHJvZHVjdGlvblwiLFxuICBERVZFTE9QTUVOVDogXCJkZXZlbG9wbWVudFwiLFxuICBTVEFHSU5HOiBcInN0YWdpbmdcIixcbiAgVEVTVElORzogXCJ0ZXN0aW5nXCJcbn07XG5cbi8qKlxuICoge0BsYWJlbCBsb2dpblByb3ZpZGVyVHlwZX1cbiAqL1xuXG4vLyBhdXRvY29tcGxldGUgd29ya2Fyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI5NzI5XG5cbmNvbnN0IExBTkdVQUdFUyA9IHtcbiAgZW46IFwiZW5cIixcbiAgamE6IFwiamFcIixcbiAga286IFwia29cIixcbiAgZGU6IFwiZGVcIixcbiAgemg6IFwiemhcIixcbiAgZXM6IFwiZXNcIixcbiAgZnI6IFwiZnJcIixcbiAgcHQ6IFwicHRcIixcbiAgbmw6IFwibmxcIixcbiAgdHI6IFwidHJcIlxufTtcbmNvbnN0IExBTkdVQUdFX01BUCA9IHtcbiAgZW46IFwiZW5nbGlzaFwiLFxuICBqYTogXCJqYXBhbmVzZVwiLFxuICBrbzogXCJrb3JlYW5cIixcbiAgZGU6IFwiZ2VybWFuXCIsXG4gIHpoOiBcIm1hbmRhcmluXCIsXG4gIGVzOiBcInNwYW5pc2hcIixcbiAgZnI6IFwiZnJlbmNoXCIsXG4gIHB0OiBcInBvcnR1Z3Vlc2VcIixcbiAgbmw6IFwiZHV0Y2hcIixcbiAgdHI6IFwidHVya2lzaFwiXG59O1xuY29uc3QgVEhFTUVfTU9ERVMgPSB7XG4gIGxpZ2h0OiBcImxpZ2h0XCIsXG4gIGRhcms6IFwiZGFya1wiLFxuICBhdXRvOiBcImF1dG9cIlxufTtcbmNvbnN0IE1GQV9GQUNUT1IgPSB7XG4gIERFVklDRTogXCJkZXZpY2VTaGFyZUZhY3RvclwiLFxuICBCQUNLVVBfU0hBUkU6IFwiYmFja1VwU2hhcmVGYWN0b3JcIixcbiAgU09DSUFMX0JBQ0tVUDogXCJzb2NpYWxCYWNrdXBGYWN0b3JcIixcbiAgUEFTU1dPUkQ6IFwicGFzc3dvcmRGYWN0b3JcIixcbiAgUEFTU0tFWVM6IFwicGFzc2tleXNGYWN0b3JcIixcbiAgQVVUSEVOVElDQVRPUjogXCJhdXRoZW50aWNhdG9yRmFjdG9yXCJcbn07XG5cbmZ1bmN0aW9uIGdldENvbG9yc0xpc3QoKSB7XG4gIGxldCBjb2xvcnNBbW91bnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDM7XG4gIGxldCBjb2xvcnNTaGlmdEFtb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNTA7XG4gIGxldCBtaXhDb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJibGFja1wiO1xuICBsZXQgcm90YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICBsZXQgc2F0dXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMjA7XG4gIGxldCBtYWluQ29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IFwiIzAzNDZmZlwiO1xuICBjb25zdCBjb2xvcnNMaXN0ID0gW107XG4gIGxldCBzdGVwO1xuICBmb3IgKHN0ZXAgPSAwOyBzdGVwIDwgY29sb3JzQW1vdW50OyBzdGVwICs9IDEpIHtcbiAgICBjb2xvcnNMaXN0LnB1c2goQ29sb3IobWFpbkNvbG9yKS5yb3RhdGUoKHN0ZXAgKyAxKSAvIGNvbG9yc0Ftb3VudCAqIC1yb3RhdGUpLnNhdHVyYXRlKChzdGVwICsgMSkgLyBjb2xvcnNBbW91bnQgKiAoc2F0dXJhdGlvbiAvIDEwMCkpLm1peChDb2xvcihtaXhDb2xvciksIGNvbG9yc1NoaWZ0QW1vdW50IC8gMTAwICogKHN0ZXAgKyAxKSAvIGNvbG9yc0Ftb3VudCkuaGV4KCkpO1xuICB9XG4gIHJldHVybiBjb2xvcnNMaXN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVXaGl0ZUxhYmVsVGhlbWUocHJpbWFyeSkge1xuICBjb25zdCBkYXJrU2V0ID0gZ2V0Q29sb3JzTGlzdCgzLCA1MCwgXCJibGFja1wiLCAwLCAyMCwgcHJpbWFyeSk7XG4gIGNvbnN0IGxpZ2h0U2V0ID0gZ2V0Q29sb3JzTGlzdCg2LCA4NSwgXCJ3aGl0ZVwiLCAwLCAyMCwgcHJpbWFyeSk7XG4gIHJldHVybiBbLi4uZGFya1NldC5yZXZlcnNlKCksIHByaW1hcnksIC4uLmxpZ2h0U2V0XTtcbn1cbmZ1bmN0aW9uIGFwcGx5V2hpdGVMYWJlbFRoZW1lKHJvb3RFbGVtZW50LCB0aGVtZSkge1xuICBpZiAodGhlbWUucHJpbWFyeSkge1xuICAgIGNvbnN0IHRoZW1lU2V0ID0gZ2VuZXJhdGVXaGl0ZUxhYmVsVGhlbWUodGhlbWUucHJpbWFyeSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTkwMFwiLCB0aGVtZVNldFswXSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTgwMFwiLCB0aGVtZVNldFsxXSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTcwMFwiLCB0aGVtZVNldFsyXSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTYwMFwiLCB0aGVtZVNldFszXSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTUwMFwiLCB0aGVtZVNldFs0XSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTQwMFwiLCB0aGVtZVNldFs1XSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTMwMFwiLCB0aGVtZVNldFs2XSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTIwMFwiLCB0aGVtZVNldFs3XSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTEwMFwiLCB0aGVtZVNldFs4XSk7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1wcmltYXJ5LTUwXCIsIHRoZW1lU2V0WzldKTtcbiAgfVxuICBpZiAodGhlbWUub25QcmltYXJ5KSB7XG4gICAgcm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWFwcC1vbi1wcmltYXJ5XCIsIHRoZW1lLm9uUHJpbWFyeSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQlVJTERfRU5WLCBCcm93c2VyU3RvcmFnZSwgTEFOR1VBR0VTLCBMQU5HVUFHRV9NQVAsIExPR0lOX1BST1ZJREVSLCBNRkFfRkFDVE9SLCBNRkFfTEVWRUxTLCBNZW1vcnlTdG9yZSwgT1BFTkxPR0lOX0FDVElPTlMsIE9QRU5MT0dJTl9ORVRXT1JLLCBTVVBQT1JURURfS0VZX0NVUlZFUywgVEhFTUVfTU9ERVMsIFVYX01PREUsIGFwcGx5V2hpdGVMYWJlbFRoZW1lLCBiYXNlNjR0b0pTT04sIGJhc2U2NHVybCwgZ2VuZXJhdGVXaGl0ZUxhYmVsVGhlbWUsIGdldENvbG9yc0xpc3QsIGpzb25Ub0Jhc2U2NCwgc2FmZWF0b2IsIHNhZmVidG9hLCBzdG9yYWdlQXZhaWxhYmxlLCBzdG9yZUtleSB9O1xuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsImJhc2U2NHVybExpYiIsIl9vYmplY3RTcHJlYWQiLCJUT1JVU19TQVBQSElSRV9ORVRXT1JLIiwiVE9SVVNfTEVHQUNZX05FVFdPUksiLCJDb2xvciIsImJhc2U2NHVybCIsInNhZmVidG9hIiwic3RyIiwiZW5jb2RlIiwic2FmZWF0b2IiLCJkZWNvZGUiLCJiYXNlNjR0b0pTT04iLCJiNjRzdHIiLCJKU09OIiwicGFyc2UiLCJqc29uVG9CYXNlNjQiLCJqc29uIiwic3RyaW5naWZ5Iiwic3RvcmFnZUF2YWlsYWJsZSIsInR5cGUiLCJzdG9yYWdlRXhpc3RzIiwic3RvcmFnZUxlbmd0aCIsInN0b3JhZ2UiLCJ3aW5kb3ciLCJsZW5ndGgiLCJ4Iiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlcnIiLCJlcnJvciIsImNvZGUiLCJuYW1lIiwiTWVtb3J5U3RvcmUiLCJjb25zdHJ1Y3RvciIsIk1hcCIsImdldEl0ZW0iLCJrZXkiLCJzdG9yZSIsImdldCIsInZhbHVlIiwic2V0IiwiZGVsZXRlIiwiQnJvd3NlclN0b3JhZ2UiLCJzdG9yZUtleSIsIl9zdG9yZUtleSIsInJlc2V0U3RvcmUiLCJnZXRJbnN0YW5jZSIsInN0b3JhZ2VLZXkiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJpbnN0YW5jZU1hcCIsImhhcyIsImxvY2FsU3RvcmFnZSIsInNlc3Npb25TdG9yYWdlIiwidG9KU09OIiwiY3VyclN0b3JlIiwiZ2V0U3RvcmUiLCJVWF9NT0RFIiwiUE9QVVAiLCJSRURJUkVDVCIsIk9QRU5MT0dJTl9ORVRXT1JLIiwiU1VQUE9SVEVEX0tFWV9DVVJWRVMiLCJTRUNQMjU2SzEiLCJFRDI1NTE5IiwiTE9HSU5fUFJPVklERVIiLCJHT09HTEUiLCJGQUNFQk9PSyIsIlJFRERJVCIsIkRJU0NPUkQiLCJUV0lUQ0giLCJBUFBMRSIsIkxJTkUiLCJHSVRIVUIiLCJLQUtBTyIsIkxJTktFRElOIiwiVFdJVFRFUiIsIldFSUJPIiwiV0VDSEFUIiwiRkFSQ0FTVEVSIiwiRU1BSUxfUEFTU1dPUkRMRVNTIiwiU01TX1BBU1NXT1JETEVTUyIsIldFQkFVVEhOIiwiSldUIiwiTUZBX0xFVkVMUyIsIkRFRkFVTFQiLCJPUFRJT05BTCIsIk1BTkRBVE9SWSIsIk5PTkUiLCJPUEVOTE9HSU5fQUNUSU9OUyIsIkxPR0lOIiwiRU5BQkxFX01GQSIsIk1BTkFHRV9NRkEiLCJNT0RJRllfU09DSUFMX0ZBQ1RPUiIsIkJVSUxEX0VOViIsIlBST0RVQ1RJT04iLCJERVZFTE9QTUVOVCIsIlNUQUdJTkciLCJURVNUSU5HIiwiTEFOR1VBR0VTIiwiZW4iLCJqYSIsImtvIiwiZGUiLCJ6aCIsImVzIiwiZnIiLCJwdCIsIm5sIiwidHIiLCJMQU5HVUFHRV9NQVAiLCJUSEVNRV9NT0RFUyIsImxpZ2h0IiwiZGFyayIsImF1dG8iLCJNRkFfRkFDVE9SIiwiREVWSUNFIiwiQkFDS1VQX1NIQVJFIiwiU09DSUFMX0JBQ0tVUCIsIlBBU1NXT1JEIiwiUEFTU0tFWVMiLCJBVVRIRU5USUNBVE9SIiwiZ2V0Q29sb3JzTGlzdCIsImNvbG9yc0Ftb3VudCIsImNvbG9yc1NoaWZ0QW1vdW50IiwibWl4Q29sb3IiLCJyb3RhdGUiLCJzYXR1cmF0aW9uIiwibWFpbkNvbG9yIiwiY29sb3JzTGlzdCIsInN0ZXAiLCJwdXNoIiwic2F0dXJhdGUiLCJtaXgiLCJoZXgiLCJnZW5lcmF0ZVdoaXRlTGFiZWxUaGVtZSIsInByaW1hcnkiLCJkYXJrU2V0IiwibGlnaHRTZXQiLCJyZXZlcnNlIiwiYXBwbHlXaGl0ZUxhYmVsVGhlbWUiLCJyb290RWxlbWVudCIsInRoZW1lIiwidGhlbWVTZXQiLCJzdHlsZSIsInNldFByb3BlcnR5Iiwib25QcmltYXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUTTON_POSITION: () => (/* binding */ BUTTON_POSITION),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   PAYMENT_PROVIDER: () => (/* binding */ PAYMENT_PROVIDER),\n/* harmony export */   TORUS_BUILD_ENV: () => (/* binding */ TORUS_BUILD_ENV),\n/* harmony export */   TorusInPageProvider: () => (/* binding */ TorusInPageProvider),\n/* harmony export */   \"default\": () => (/* binding */ Torus)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/base-controllers */ \"(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! eth-rpc-errors */ \"(ssr)/./node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/./node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__);\n\n\n\n\n\n\n\n\n\n\nvar version = \"2.1.0\";\n/* eslint-disable @typescript-eslint/no-explicit-any */ function isStream(stream) {\n    return stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\n}\nfunction isWritableStream(stream) {\n    return isStream(stream) && stream.writable !== false && typeof stream._write === \"function\" && typeof stream._writableState === \"object\";\n}\nfunction isReadableStream(stream) {\n    return isStream(stream) && stream.readable !== false && typeof stream._read === \"function\" && typeof stream._readableState === \"object\";\n}\nfunction isDuplexStream(stream) {\n    return isWritableStream(stream) && isReadableStream(stream);\n}\nvar messages = {\n    errors: {\n        disconnected: ()=>\"Torus: Lost connection to Torus.\",\n        permanentlyDisconnected: ()=>\"Torus: Disconnected from iframe. Page reload required.\",\n        unsupportedSync: (method)=>`Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,\n        invalidDuplexStream: ()=>\"Must provide a Node.js-style duplex stream.\",\n        invalidOptions: (maxEventListeners)=>`Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,\n        invalidRequestArgs: ()=>`Expected a single, non-array, object argument.`,\n        invalidRequestMethod: ()=>`'args.method' must be a non-empty string.`,\n        invalidRequestParams: ()=>`'args.params' must be an object or array if provided.`,\n        invalidLoggerObject: ()=>`'args.logger' must be an object if provided.`,\n        invalidLoggerMethod: (method)=>`'args.logger' must include required method '${method}'.`\n    },\n    info: {\n        connected: (chainId)=>`Torus: Connected to chain with ID \"${chainId}\".`\n    },\n    warnings: {}\n};\nconst PAYMENT_PROVIDER = {\n    MOONPAY: \"moonpay\",\n    WYRE: \"wyre\",\n    RAMPNETWORK: \"rampnetwork\",\n    XANPOOL: \"xanpool\",\n    MERCURYO: \"mercuryo\",\n    TRANSAK: \"transak\"\n};\nconst TORUS_BUILD_ENV = {\n    PRODUCTION: \"production\",\n    DEVELOPMENT: \"development\",\n    TESTING: \"testing\"\n};\nconst BUTTON_POSITION = {\n    BOTTOM_LEFT: \"bottom-left\",\n    TOP_LEFT: \"top-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    TOP_RIGHT: \"top-right\"\n};\nconst LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst translations = {\n    en: {\n        embed: {\n            continue: \"Continue\",\n            actionRequired: \"Authorization required\",\n            pendingAction: \"Click continue to proceed with your request in a popup\",\n            cookiesRequired: \"Cookies Required\",\n            enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\n            clickHere: \"More Info\"\n        }\n    },\n    de: {\n        embed: {\n            continue: \"Fortsetzen\",\n            actionRequired: \"Autorisierung erforderlich\",\n            pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\n            cookiesRequired: \"Cookies ben\\xf6tigt\",\n            enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\n            clickHere: \"Mehr Info\"\n        }\n    },\n    ja: {\n        embed: {\n            continue: \"\",\n            actionRequired: \"\",\n            pendingAction: \"\",\n            cookiesRequired: \"\",\n            enableCookies: \"TorusCookie\",\n            clickHere: \"\"\n        }\n    },\n    ko: {\n        embed: {\n            continue: \"\",\n            actionRequired: \" \",\n            pendingAction: \"    .\",\n            cookiesRequired: \" \",\n            enableCookies: \"     Torus .\",\n            clickHere: \"  \"\n        }\n    },\n    zh: {\n        embed: {\n            continue: \"\",\n            actionRequired: \"\",\n            pendingAction: \"\",\n            cookiesRequired: \"Cookie\",\n            enableCookies: \"cookieTorus\",\n            clickHere: \"\"\n        }\n    }\n};\nvar configuration = {\n    supportedVerifierList: [\n        LOGIN_PROVIDER.GOOGLE,\n        LOGIN_PROVIDER.REDDIT,\n        LOGIN_PROVIDER.DISCORD\n    ],\n    api: \"https://api.tor.us\",\n    translations,\n    prodTorusUrl: \"\",\n    localStorageKeyPrefix: `torus-`\n};\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_8___default().getLogger(\"solana-embed\");\n// utility functions\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */ function createErrorMiddleware() {\n    return (req, res, next)=>{\n        // json-rpc-engine will terminate the request when it notices this error\n        if (typeof req.method !== \"string\" || !req.method) {\n            res.error = eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: `The request 'method' must be a non-empty string.`,\n                data: req\n            });\n        }\n        next((done)=>{\n            const { error } = res;\n            if (!error) {\n                return done();\n            }\n            log.error(`Torus - RPC Error: ${error.message}`, error);\n            return done();\n        });\n    };\n}\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */ function logStreamDisconnectWarning(remoteLabel, error, emitter) {\n    let warningMsg = `Torus: Lost connection to \"${remoteLabel}\".`;\n    if (error?.stack) {\n        warningMsg += `\\n${error.stack}`;\n    }\n    log.warn(warningMsg);\n    if (emitter && emitter.listenerCount(\"error\") > 0) {\n        emitter.emit(\"error\", warningMsg);\n    }\n}\nconst getWindowId = ()=>Math.random().toString(36).slice(2);\nconst getTorusUrl = async (buildEnv)=>{\n    let torusUrl;\n    let logLevel;\n    // const versionUsed = version;\n    // log.info(\"solana embed version used: \", versionUsed);\n    switch(buildEnv){\n        case \"testing\":\n            torusUrl = \"https://solana-testing.tor.us\";\n            logLevel = \"debug\";\n            break;\n        case \"development\":\n            torusUrl = \"http://localhost:8080\";\n            logLevel = \"debug\";\n            break;\n        default:\n            torusUrl = `https://solana.tor.us`;\n            logLevel = \"error\";\n            break;\n    }\n    return {\n        torusUrl,\n        logLevel\n    };\n};\nconst getUserLanguage = ()=>{\n    let userLanguage = window.navigator.language || \"en-US\";\n    const userLanguages = userLanguage.split(\"-\");\n    userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\n    return userLanguage;\n};\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n    height: 660,\n    width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n    height: 740,\n    width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n    height: 700,\n    width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n    height: 600,\n    width: 400\n};\nfunction storageAvailable(type) {\n    let storage;\n    try {\n        storage = window[type];\n        const x = \"__storage_test__\";\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    } catch (error) {\n        const e = error;\n        return e && // everything except Firefox\n        (e.code === 22 || // Firefox\n        e.code === 1014 || // test name field too, because code might not be present\n        // everything except Firefox\n        e.name === \"QuotaExceededError\" || // Firefox\n        e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n        storage && storage.length !== 0;\n    }\n}\n/**\n * popup handler utils\n */ function getPopupFeatures(_ref) {\n    let { width: w, height: h } = _ref;\n    // Fixes dual-screen position                             Most browsers      Firefox\n    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n    const systemZoom = 1; // No reliable estimate\n    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n    return features;\n}\nclass BaseProvider extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.SafeEventEmitter {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super();\n        /**\n     * Indicating that this provider is a Torus provider.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isTorus\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_rpcEngine\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"jsonRpcConnectionEvents\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_state\", void 0);\n        if (!isDuplexStream(connectionStream)) {\n            throw new Error(messages.errors.invalidDuplexStream());\n        }\n        this.isTorus = true;\n        this.setMaxListeners(maxEventListeners);\n        this._handleConnect = this._handleConnect.bind(this);\n        this._handleDisconnect = this._handleDisconnect.bind(this);\n        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n        this._rpcRequest = this._rpcRequest.bind(this);\n        this._initializeState = this._initializeState.bind(this);\n        this.request = this.request.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        // this.enable = this.enable.bind(this);\n        // setup connectionStream multiplexing\n        const mux = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.ObjectMultiplex();\n        pump__WEBPACK_IMPORTED_MODULE_7___default()(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"Torus\"));\n        // ignore phishing warning message (handled elsewhere)\n        mux.ignoreStream(\"phishing\");\n        // setup own event listeners\n        // connect to async provider\n        const jsonRpcConnection = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.createStreamMiddleware)();\n        pump__WEBPACK_IMPORTED_MODULE_7___default()(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"Torus RpcProvider\"));\n        // handle RPC requests via dapp-side rpc engine\n        const rpcEngine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.JRPCEngine();\n        rpcEngine.push((0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.createIdRemapMiddleware)());\n        rpcEngine.push(createErrorMiddleware());\n        rpcEngine.push((0,_toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.createLoggerMiddleware)({\n            origin: location.origin\n        }));\n        rpcEngine.push(jsonRpcConnection.middleware);\n        this._rpcEngine = rpcEngine;\n        this.jsonRpcConnectionEvents = jsonRpcConnection.events;\n    }\n    /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   */ async request(args) {\n        if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestArgs(),\n                data: args\n            });\n        }\n        const { method, params } = args;\n        if (typeof method !== \"string\" || method.length === 0) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestMethod(),\n                data: args\n            });\n        }\n        if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestParams(),\n                data: args\n            });\n        }\n        return new Promise((resolve, reject)=>{\n            this._rpcRequest({\n                method,\n                params\n            }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n        });\n    }\n    /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */ send(payload, callback) {\n        this._rpcRequest(payload, callback);\n    }\n    /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */ sendAsync(payload) {\n        return new Promise((resolve, reject)=>{\n            this._rpcRequest(payload, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n        });\n    }\n    /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits TorusInpageProvider#disconnect\n   */ _handleStreamDisconnect(streamName, error) {\n        logStreamDisconnectWarning(streamName, error, this);\n        this._handleDisconnect(false, error ? error.message : undefined);\n    }\n}\nconst htmlToElement = (html)=>{\n    const template = window.document.createElement(\"template\");\n    const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n    template.innerHTML = trimmedHtml;\n    return template.content.firstChild;\n};\nfunction isLegacyTransactionInstance(transaction) {\n    return transaction.version === undefined;\n}\nclass PopupHandler extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.SafeEventEmitter {\n    constructor(_ref){\n        let { url, target, features, timeout = 30000 } = _ref;\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"url\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"features\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"window\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"windowTimer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"iClosedWindow\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"timeout\", void 0);\n        this.url = url;\n        this.target = target || \"_blank\";\n        this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);\n        this.window = undefined;\n        this.windowTimer = undefined;\n        this.iClosedWindow = false;\n        this.timeout = timeout;\n        this._setupTimer();\n    }\n    _setupTimer() {\n        this.windowTimer = Number(setInterval(()=>{\n            if (this.window && this.window.closed) {\n                clearInterval(this.windowTimer);\n                setTimeout(()=>{\n                    if (!this.iClosedWindow) {\n                        this.emit(\"close\");\n                    }\n                    this.iClosedWindow = false;\n                    this.window = undefined;\n                }, this.timeout);\n            }\n            if (this.window === undefined) clearInterval(this.windowTimer);\n        }, 500));\n    }\n    open() {\n        this.window = window.open(this.url.href, this.target, this.features);\n        if (this.window?.focus) this.window.focus();\n        return Promise.resolve();\n    }\n    close() {\n        this.iClosedWindow = true;\n        if (this.window) this.window.close();\n    }\n    redirect(locationReplaceOnRedirect) {\n        if (locationReplaceOnRedirect) {\n            window.location.replace(this.url.href);\n        } else {\n            window.location.href = this.url.href;\n        }\n    }\n}\nclass TorusCommunicationProvider extends BaseProvider {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super(connectionStream, {\n            maxEventListeners,\n            jsonRpcStreamName\n        });\n        // private state\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"embedTranslations\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusUrl\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"dappStorageKey\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"windowRefs\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"tryWindowHandle\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlertContainer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusIframe\", void 0);\n        this._state = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, TorusCommunicationProvider._defaultState);\n        // public state\n        this.torusUrl = \"\";\n        this.dappStorageKey = \"\";\n        const languageTranslations = configuration.translations[getUserLanguage()];\n        this.embedTranslations = languageTranslations.embed;\n        this.windowRefs = {};\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on(\"connect\", ()=>{\n            this._state.isConnected = true;\n        });\n        const notificationHandler = (payload)=>{\n            const { method, params } = payload;\n            if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {\n                const { isFullScreen, rid } = params;\n                this._displayIframe({\n                    isFull: isFullScreen,\n                    rid: rid\n                });\n            // TODO: remove this method when wallet adds versioning and stops supporting this method\n            } else if (method === \"create_window\") {\n                const { windowId, url } = params;\n                this._createPopupBlockAlert(windowId, url);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {\n                this._handleCloseWindow(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {\n                const { currentLoginProvider } = params;\n                this._state.isLoggedIn = true;\n                this._state.currentLoginProvider = currentLoginProvider;\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {\n                this._state.isLoggedIn = false;\n                this._state.currentLoginProvider = null;\n                this._displayIframe();\n            }\n        };\n        this.jsonRpcConnectionEvents.on(\"notification\", notificationHandler);\n    }\n    get isLoggedIn() {\n        return this._state.isLoggedIn;\n    }\n    get isIFrameFullScreen() {\n        return this._state.isIFrameFullScreen;\n    }\n    /**\n   * Returns whether the inPage provider is connected to Torus.\n   */ isConnected() {\n        return this._state.isConnected;\n    }\n    async _initializeState(params) {\n        try {\n            const { torusUrl, dappStorageKey, torusAlertContainer, torusIframe } = params;\n            this.torusUrl = torusUrl;\n            this.dappStorageKey = dappStorageKey;\n            this.torusAlertContainer = torusAlertContainer;\n            this.torusIframe = torusIframe;\n            this.torusIframe.addEventListener(\"load\", ()=>{\n                // only do this if iframe is not full screen\n                if (!this._state.isIFrameFullScreen) this._displayIframe();\n            });\n            const { currentLoginProvider, isLoggedIn } = await this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,\n                params: []\n            });\n            // indicate that we've connected, for EIP-1193 compliance\n            this._handleConnect(currentLoginProvider, isLoggedIn);\n        } catch (error) {\n            log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n        } finally{\n            log.info(\"initialized communication state\");\n            this._state.initialized = true;\n            this.emit(\"_initialized\");\n        }\n    }\n    _handleWindow(windowId) {\n        let { url, target, features } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const finalUrl = new URL(url || `${this.torusUrl}/redirect?windowId=${windowId}`);\n        if (this.dappStorageKey) {\n            // If multiple instances, it returns the first one\n            if (finalUrl.hash) finalUrl.hash += `&dappStorageKey=${this.dappStorageKey}`;\n            else finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;\n        }\n        const handledWindow = new PopupHandler({\n            url: finalUrl,\n            target,\n            features\n        });\n        handledWindow.open();\n        if (!handledWindow.window) {\n            this._createPopupBlockAlert(windowId, finalUrl.href);\n            return;\n        }\n        // Add to collection only if window is opened\n        this.windowRefs[windowId] = handledWindow;\n        // We tell the iframe that the window has been successfully opened\n        this.request({\n            method: \"opened_window\",\n            params: {\n                windowId\n            }\n        });\n        handledWindow.once(\"close\", ()=>{\n            // user closed the window\n            delete this.windowRefs[windowId];\n            this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,\n                params: {\n                    windowId\n                }\n            });\n        });\n    }\n    _displayIframe() {\n        let { isFull = false, rid = \"\" } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const style = {};\n        // set phase\n        if (!isFull) {\n            style.display = this._state.torusWidgetVisibility ? \"block\" : \"none\";\n            style.height = \"70px\";\n            style.width = \"70px\";\n            switch(this._state.buttonPosition){\n                case BUTTON_POSITION.TOP_LEFT:\n                    style.top = \"0px\";\n                    style.left = \"0px\";\n                    style.right = \"auto\";\n                    style.bottom = \"auto\";\n                    break;\n                case BUTTON_POSITION.TOP_RIGHT:\n                    style.top = \"0px\";\n                    style.right = \"0px\";\n                    style.left = \"auto\";\n                    style.bottom = \"auto\";\n                    break;\n                case BUTTON_POSITION.BOTTOM_RIGHT:\n                    style.bottom = \"0px\";\n                    style.right = \"0px\";\n                    style.top = \"auto\";\n                    style.left = \"auto\";\n                    break;\n                case BUTTON_POSITION.BOTTOM_LEFT:\n                default:\n                    style.bottom = \"0px\";\n                    style.left = \"0px\";\n                    style.top = \"auto\";\n                    style.right = \"auto\";\n                    break;\n            }\n        } else {\n            style.display = \"block\";\n            style.width = \"100%\";\n            style.height = \"100%\";\n            style.top = \"0px\";\n            style.right = \"0px\";\n            style.left = \"0px\";\n            style.bottom = \"0px\";\n        }\n        Object.assign(this.torusIframe.style, style);\n        this._state.isIFrameFullScreen = isFull;\n        this.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,\n            params: {\n                isIFrameFullScreen: isFull,\n                rid\n            }\n        });\n    }\n    hideTorusButton() {\n        this._state.torusWidgetVisibility = false;\n        this._displayIframe();\n    }\n    showTorusButton() {\n        this._state.torusWidgetVisibility = true;\n        this._displayIframe();\n    }\n    /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */ _rpcRequest(payload, callback) {\n        const cb = callback;\n        const _payload = payload;\n        if (!Array.isArray(_payload)) {\n            if (!_payload.jsonrpc) {\n                _payload.jsonrpc = \"2.0\";\n            }\n        }\n        this.tryWindowHandle(_payload, cb);\n    }\n    /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param currentLoginProvider - The login Provider\n   * emits TorusInpageProvider#connect\n   */ _handleConnect(currentLoginProvider, isLoggedIn) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit(\"connect\", {\n                currentLoginProvider,\n                isLoggedIn\n            });\n            log.debug(messages.info.connected(currentLoginProvider));\n        }\n    }\n    /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */ _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1013, // Try again later\n                errorMessage || messages.errors.disconnected());\n                log.debug(error);\n            } else {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1011, // Internal error\n                errorMessage || messages.errors.permanentlyDisconnected());\n                log.error(error);\n                this._state.currentLoginProvider = null;\n                this._state.isLoggedIn = false;\n                this._state.torusWidgetVisibility = false;\n                this._state.isIFrameFullScreen = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit(\"disconnect\", error);\n        }\n    }\n    // Called if the iframe wants to close the window cause it is done processing the request\n    _handleCloseWindow(params) {\n        const { windowId } = params;\n        if (this.windowRefs[windowId]) {\n            this.windowRefs[windowId].close();\n            delete this.windowRefs[windowId];\n        }\n    }\n    async _createPopupBlockAlert(windowId, url) {\n        const logoUrl = this.getLogoUrl();\n        const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + `<div id=\"torusAlert__logo\"><img src=\"${logoUrl}\" /></div>` + \"<div>\" + `<h1 id=\"torusAlert__title\">${this.embedTranslations.actionRequired}</h1>` + `<p id=\"torusAlert__desc\">${this.embedTranslations.pendingAction}</p>` + \"</div>\" + \"</div>\");\n        const successAlert = htmlToElement(`<div><a id=\"torusAlert__btn\">${this.embedTranslations.continue}</a></div>`);\n        const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\n        btnContainer.appendChild(successAlert);\n        torusAlert.appendChild(btnContainer);\n        const bindOnLoad = ()=>{\n            successAlert.addEventListener(\"click\", ()=>{\n                this._handleWindow(windowId, {\n                    url,\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n                });\n                torusAlert.remove();\n                if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\n            });\n        };\n        const attachOnLoad = ()=>{\n            this.torusAlertContainer.appendChild(torusAlert);\n        };\n        attachOnLoad();\n        bindOnLoad();\n        this.torusAlertContainer.style.display = \"block\";\n    }\n    getLogoUrl() {\n        const logoUrl = `${this.torusUrl}/images/torus_icon-blue.svg`;\n        return logoUrl;\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(TorusCommunicationProvider, \"_defaultState\", {\n    buttonPosition: \"bottom-left\",\n    currentLoginProvider: null,\n    isIFrameFullScreen: false,\n    hasEmittedConnection: false,\n    torusWidgetVisibility: false,\n    initialized: false,\n    isLoggedIn: false,\n    isPermanentlyDisconnected: false,\n    isConnected: false\n});\nclass TorusInPageProvider extends BaseProvider {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super(connectionStream, {\n            maxEventListeners,\n            jsonRpcStreamName\n        });\n        // private state\n        /**\n     * The chain ID of the currently connected Solana chain.\n     * See [chainId.network]{@link https://chainid.network} for more information.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"chainId\", void 0);\n        /**\n     * The user's currently selected Solana address.\n     * If null, Torus is either locked or the user has not permitted any\n     * addresses to be viewed.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"selectedAddress\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"tryWindowHandle\", void 0);\n        this._state = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, TorusInPageProvider._defaultState);\n        // public state\n        this.selectedAddress = null;\n        this.chainId = null;\n        this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n        this._handleChainChanged = this._handleChainChanged.bind(this);\n        this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on(\"connect\", ()=>{\n            this._state.isConnected = true;\n        });\n        const jsonRpcNotificationHandler = (payload)=>{\n            const { method, params } = payload;\n            if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {\n                this._handleAccountsChanged(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {\n                this._handleUnlockStateChanged(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {\n                this._handleChainChanged(params);\n            }\n        };\n        // json rpc notification listener\n        this.jsonRpcConnectionEvents.on(\"notification\", jsonRpcNotificationHandler);\n    }\n    /**\n   * Returns whether the inpage provider is connected to Torus.\n   */ isConnected() {\n        return this._state.isConnected;\n    }\n    // Private Methods\n    //= ===================\n    /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */ async _initializeState() {\n        try {\n            const { accounts, chainId, isUnlocked } = await this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,\n                params: []\n            });\n            // indicate that we've connected, for EIP-1193 compliance\n            this.emit(\"connect\", {\n                chainId\n            });\n            this._handleChainChanged({\n                chainId\n            });\n            this._handleUnlockStateChanged({\n                accounts,\n                isUnlocked\n            });\n            this._handleAccountsChanged(accounts);\n        } catch (error) {\n            log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n        } finally{\n            log.info(\"initialized provider state\");\n            this._state.initialized = true;\n            this.emit(\"_initialized\");\n        }\n    }\n    /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */ _rpcRequest(payload, callback) {\n        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        let cb = callback;\n        const _payload = payload;\n        if (!Array.isArray(_payload)) {\n            if (!_payload.jsonrpc) {\n                _payload.jsonrpc = \"2.0\";\n            }\n            if (_payload.method === \"solana_accounts\" || _payload.method === \"solana_requestAccounts\") {\n                // handle accounts changing\n                cb = (err, res)=>{\n                    this._handleAccountsChanged(res.result || [], _payload.method === \"solana_accounts\", isInternal);\n                    callback(err, res);\n                };\n            } else if (_payload.method === \"wallet_getProviderState\") {\n                this._rpcEngine.handle(payload, cb);\n                return;\n            }\n        }\n        this.tryWindowHandle(_payload, cb);\n    }\n    /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits TorusInpageProvider#connect\n   */ _handleConnect(chainId) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit(\"connect\", {\n                chainId\n            });\n            log.debug(messages.info.connected(chainId));\n        }\n    }\n    /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */ _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1013, // Try again later\n                errorMessage || messages.errors.disconnected());\n                log.debug(error);\n            } else {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1011, // Internal error\n                errorMessage || messages.errors.permanentlyDisconnected());\n                log.error(error);\n                this.chainId = null;\n                this._state.accounts = null;\n                this.selectedAddress = null;\n                this._state.isUnlocked = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit(\"disconnect\", error);\n        }\n    }\n    /**\n   * Called when accounts may have changed.\n   */ _handleAccountsChanged(accounts) {\n        let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        // defensive programming\n        let finalAccounts = accounts;\n        if (!Array.isArray(finalAccounts)) {\n            log.error(\"Torus: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n            finalAccounts = [];\n        }\n        for (const account of accounts){\n            if (typeof account !== \"string\") {\n                log.error(\"Torus: Received non-string account. Please report this bug.\", accounts);\n                finalAccounts = [];\n                break;\n            }\n        }\n        // emit accountsChanged if anything about the accounts array has changed\n        if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default()(this._state.accounts, finalAccounts)) {\n            // we should always have the correct accounts even before solana_accounts\n            // returns, except in cases where isInternal is true\n            if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\n                log.error('Torus: \"solana_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n            }\n            this._state.accounts = finalAccounts;\n            this.emit(\"accountsChanged\", finalAccounts);\n        }\n        // handle selectedAddress\n        if (this.selectedAddress !== finalAccounts[0]) {\n            this.selectedAddress = finalAccounts[0] || null;\n        }\n    }\n    /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits TorusInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */ _handleChainChanged() {\n        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!chainId) {\n            log.error(\"Torus: Received invalid network parameters. Please report this bug.\", {\n                chainId\n            });\n            return;\n        }\n        if (chainId === \"loading\") {\n            this._handleDisconnect(true);\n        } else {\n            this._handleConnect(chainId);\n            if (chainId !== this.chainId) {\n                this.chainId = chainId;\n                if (this._state.initialized) {\n                    this.emit(\"chainChanged\", this.chainId);\n                }\n            }\n        }\n    }\n    /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */ _handleUnlockStateChanged() {\n        let { accounts, isUnlocked } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (typeof isUnlocked !== \"boolean\") {\n            log.error(\"Torus: Received invalid isUnlocked parameter. Please report this bug.\", {\n                isUnlocked\n            });\n            return;\n        }\n        if (isUnlocked !== this._state.isUnlocked) {\n            this._state.isUnlocked = isUnlocked;\n            this._handleAccountsChanged(accounts || []);\n        }\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(TorusInPageProvider, \"_defaultState\", {\n    accounts: null,\n    isConnected: false,\n    isUnlocked: false,\n    initialized: false,\n    isPermanentlyDisconnected: false,\n    hasEmittedConnection: false\n});\n/**\n * Returns whether the given image URL exists\n */ function imgExists(url) {\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = document.createElement(\"img\");\n            img.onload = ()=>resolve(true);\n            img.onerror = ()=>resolve(false);\n            img.src = url;\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n/**\n * Extracts a name for the site from the DOM\n */ const getSiteName = (window1)=>{\n    const { document: document1 } = window1;\n    const siteName = document1.querySelector('head > meta[property=\"og:site_name\"]');\n    if (siteName) {\n        return siteName.content;\n    }\n    const metaTitle = document1.querySelector('head > meta[name=\"title\"]');\n    if (metaTitle) {\n        return metaTitle.content;\n    }\n    if (document1.title && document1.title.length > 0) {\n        return document1.title;\n    }\n    return window1.location.hostname;\n};\n/**\n * Extracts an icon for the site from the DOM\n */ async function getSiteIcon(window1) {\n    try {\n        const { document: document1 } = window1;\n        // Use the site's favicon if it exists\n        let icon = document1.querySelector('head > link[rel=\"shortcut icon\"]');\n        if (icon && await imgExists(icon.href)) {\n            return icon.href;\n        }\n        // Search through available icons in no particular order\n        icon = Array.from(document1.querySelectorAll('head > link[rel=\"icon\"]')).find((_icon)=>Boolean(_icon.href));\n        if (icon && await imgExists(icon.href)) {\n            return icon.href;\n        }\n        return \"\";\n    } catch (error) {\n        return \"\";\n    }\n}\n/**\n * Gets site metadata and returns it\n *\n */ const getSiteMetadata = async ()=>({\n        name: getSiteName(window),\n        icon: await getSiteIcon(window)\n    });\nconst PROVIDER_UNSAFE_METHODS = [\n    \"send_transaction\",\n    \"sign_transaction\",\n    \"sign_all_transactions\",\n    \"sign_message\",\n    \"connect\"\n];\nconst COMMUNICATION_UNSAFE_METHODS = [\n    _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER\n];\nconst isLocalStorageAvailable = storageAvailable(\"localStorage\");\n// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n(async function preLoadIframe() {\n    try {\n        if (typeof document === \"undefined\") return;\n        const torusIframeHtml = document.createElement(\"link\");\n        const { torusUrl } = await getTorusUrl(\"production\");\n        torusIframeHtml.href = `${torusUrl}/frame`;\n        torusIframeHtml.crossOrigin = \"anonymous\";\n        torusIframeHtml.type = \"text/html\";\n        torusIframeHtml.rel = \"prefetch\";\n        if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n            if (torusIframeHtml.relList.supports(\"prefetch\")) {\n                document.head.appendChild(torusIframeHtml);\n            }\n        }\n    } catch (error) {\n        log.warn(error);\n    }\n})();\nclass Torus {\n    constructor(){\n        let { modalZIndex = 99999 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isInitialized\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlert\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"modalZIndex\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"alertZIndex\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"requestedLoginProvider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"provider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"communicationProvider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"dappStorageKey\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isTopupHidden\", false);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlertContainer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusUrl\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusIframe\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"styleLink\", void 0);\n        this.torusUrl = \"\";\n        this.isInitialized = false; // init done\n        this.requestedLoginProvider = null;\n        this.modalZIndex = modalZIndex;\n        this.alertZIndex = modalZIndex + 1000;\n        this.dappStorageKey = \"\";\n    }\n    get isLoggedIn() {\n        if (!this.communicationProvider) return false;\n        return this.communicationProvider.isLoggedIn;\n    }\n    async init() {\n        let { buildEnv = TORUS_BUILD_ENV.PRODUCTION, enableLogging = false, network, showTorusButton = false, useLocalStorage = false, buttonPosition = BUTTON_POSITION.BOTTOM_LEFT, apiKey = \"torus-default\", extraParams = {}, whiteLabel } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (this.isInitialized) throw new Error(\"Already initialized\");\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_4__.setAPIKey)(apiKey);\n        const { torusUrl, logLevel } = await getTorusUrl(buildEnv);\n        log.enableAll();\n        log.info(torusUrl, \"url loaded\");\n        log.info(`Solana Embed Version :${version}`);\n        this.torusUrl = torusUrl;\n        log.setDefaultLevel(logLevel);\n        if (enableLogging) log.enableAll();\n        else log.disableAll();\n        const dappStorageKey = this.handleDappStorageKey(useLocalStorage);\n        const torusIframeUrl = new URL(torusUrl);\n        if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"frame\";\n        else torusIframeUrl.pathname += \"/frame\";\n        const hashParams = new URLSearchParams();\n        if (dappStorageKey) hashParams.append(\"dappStorageKey\", dappStorageKey);\n        hashParams.append(\"origin\", window.location.origin);\n        torusIframeUrl.hash = hashParams.toString();\n        // Iframe code\n        this.torusIframe = htmlToElement(`<iframe\n        id=\"torusIframe\"\n        class=\"torusIframe\"\n        src=\"${torusIframeUrl.href}\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}\"\n      ></iframe>`);\n        this.torusAlertContainer = htmlToElement(`<div id=\"torusAlertContainer\" style=\"display:none; z-index: ${this.alertZIndex.toString()}\"></div>`);\n        this.styleLink = htmlToElement(`<link href=\"${torusUrl}/css/widget.css\" rel=\"stylesheet\" type=\"text/css\">`);\n        return new Promise((resolve, reject)=>{\n            try {\n                this.torusIframe.addEventListener(\"load\", async ()=>{\n                    const dappMetadata = await getSiteMetadata();\n                    // send init params here\n                    this.torusIframe.contentWindow.postMessage({\n                        buttonPosition,\n                        apiKey,\n                        network,\n                        dappMetadata,\n                        extraParams,\n                        whiteLabel\n                    }, torusIframeUrl.origin);\n                    await this._setupWeb3({\n                        torusUrl\n                    });\n                    if (showTorusButton) this.showTorusButton();\n                    if (whiteLabel?.topupHide) this.isTopupHidden = whiteLabel.topupHide;\n                    else this.hideTorusButton();\n                    this.isInitialized = true;\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    window.torus = this;\n                    resolve();\n                });\n                window.document.head.appendChild(this.styleLink);\n                window.document.body.appendChild(this.torusIframe);\n                window.document.body.appendChild(this.torusAlertContainer);\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n    async login() {\n        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!this.isInitialized) throw new Error(\"Call init() first\");\n        try {\n            this.requestedLoginProvider = params.loginProvider || null;\n            if (!this.requestedLoginProvider) {\n                this.communicationProvider._displayIframe({\n                    isFull: true\n                });\n            }\n            // If user is already logged in, we assume they have given access to the website\n            const res = await new Promise((resolve, reject)=>{\n                // We use this method because we want to update inPage provider state with account info\n                this.provider._rpcRequest({\n                    method: \"solana_requestAccounts\",\n                    params: [\n                        this.requestedLoginProvider,\n                        params.login_hint\n                    ]\n                }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n            });\n            if (Array.isArray(res) && res.length > 0) {\n                return res;\n            }\n            // This would never happen, but just in case\n            throw new Error(\"Login failed\");\n        } catch (error) {\n            log.error(\"login failed\", error);\n            throw error;\n        } finally{\n            if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();\n        }\n    }\n    async loginWithPrivateKey(loginParams) {\n        if (!this.isInitialized) throw new Error(\"Call init() first\");\n        const { privateKey, userInfo } = loginParams;\n        const { success } = await this.communicationProvider.request({\n            method: \"login_with_private_key\",\n            params: {\n                privateKey,\n                userInfo\n            }\n        });\n        if (!success) throw new Error(\"Login Failed\");\n    }\n    async logout() {\n        if (!this.communicationProvider.isLoggedIn) throw new Error(\"Not logged in\");\n        await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.LOGOUT,\n            params: []\n        });\n        this.requestedLoginProvider = null;\n    }\n    async cleanUp() {\n        if (this.communicationProvider.isLoggedIn) {\n            await this.logout();\n        }\n        this.clearInit();\n    }\n    clearInit() {\n        function isElement(element) {\n            return element instanceof Element || element instanceof Document;\n        }\n        if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\n            this.styleLink.remove();\n            this.styleLink = undefined;\n        }\n        if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\n            this.torusIframe.remove();\n            this.torusIframe = undefined;\n        }\n        if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\n            this.torusAlert = undefined;\n            this.torusAlertContainer.remove();\n            this.torusAlertContainer = undefined;\n        }\n        this.isInitialized = false;\n    }\n    hideTorusButton() {\n        this.communicationProvider.hideTorusButton();\n    }\n    showTorusButton() {\n        this.communicationProvider.showTorusButton();\n    }\n    async setProvider(params) {\n        await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER,\n            params: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, params)\n        });\n    }\n    async showWallet(path) {\n        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const instanceId = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,\n            params: []\n        });\n        const finalPath = path ? `/${path}` : \"\";\n        const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`);\n        // Using URL constructor to prevent js injection and allow parameter validation.!\n        finalUrl.searchParams.append(\"instanceId\", instanceId);\n        Object.keys(params).forEach((x)=>{\n            finalUrl.searchParams.append(x, params[x]);\n        });\n        if (this.dappStorageKey) {\n            finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;\n        }\n        // No need to track this window state. Hence, no _handleWindow call.\n        const walletWindow = new PopupHandler({\n            url: finalUrl,\n            features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)\n        });\n        walletWindow.open();\n    }\n    async getUserInfo() {\n        const userInfoResponse = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.USER_INFO,\n            params: []\n        });\n        return userInfoResponse;\n    }\n    async initiateTopup(provider, params) {\n        if (!this.isInitialized) throw new Error(\"Torus is not initialized\");\n        const windowId = getWindowId();\n        this.communicationProvider._handleWindow(windowId);\n        const topupResponse = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.TOPUP,\n            params: {\n                provider,\n                params,\n                windowId\n            }\n        });\n        return topupResponse;\n    }\n    // Solana specific API\n    async getAccounts() {\n        const response = await this.provider.request({\n            method: \"getAccounts\",\n            params: []\n        });\n        return response;\n    }\n    async sendTransaction(transaction) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serialize({\n            requireAllSignatures: false\n        }).toString(\"hex\") : Buffer.from(transaction.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"send_transaction\",\n            params: {\n                message,\n                isLegacyTransaction\n            }\n        });\n        return response;\n    }\n    // support sendOptions\n    async signAndSendTransaction(transaction, options) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serialize({\n            requireAllSignatures: false\n        }).toString(\"hex\") : Buffer.from(transaction.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"send_transaction\",\n            params: {\n                message,\n                options,\n                isLegacyTransaction\n            }\n        });\n        return {\n            signature: response\n        };\n    }\n    async signTransaction(transaction) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serializeMessage().toString(\"hex\") : Buffer.from(transaction.message.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"sign_transaction\",\n            params: {\n                message,\n                messageOnly: true,\n                isLegacyTransaction\n            }\n        });\n        // reconstruct signature pair\n        const parsed = JSON.parse(response);\n        const signature = {\n            publicKey: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(parsed.publicKey),\n            signature: Buffer.from(parsed.signature, \"hex\")\n        };\n        transaction.addSignature(signature.publicKey, signature.signature);\n        return transaction;\n    }\n    async signAllTransactions(transactions) {\n        let isLegacyTransaction;\n        const encodedMessage = transactions.map((tx)=>{\n            isLegacyTransaction = isLegacyTransactionInstance(tx);\n            return isLegacyTransaction ? tx.serializeMessage().toString(\"hex\") : Buffer.from(tx.message.serialize()).toString(\"hex\");\n        });\n        const responses = await this.provider.request({\n            method: \"sign_all_transactions\",\n            params: {\n                message: encodedMessage,\n                messageOnly: true,\n                isLegacyTransaction\n            }\n        });\n        // reconstruct signature pairs\n        const signatures = responses.map((item)=>{\n            const parsed = JSON.parse(item);\n            return {\n                publicKey: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(parsed.publicKey),\n                signature: Buffer.from(parsed.signature, \"hex\")\n            };\n        });\n        transactions.forEach((tx, idx)=>{\n            tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);\n            return tx;\n        });\n        return transactions;\n    }\n    async signMessage(data) {\n        const response = await this.provider.request({\n            method: \"sign_message\",\n            params: {\n                data\n            }\n        });\n        return response;\n    }\n    async getGaslessPublicKey() {\n        const response = await this.provider.request({\n            method: \"get_gasless_public_key\",\n            params: []\n        });\n        return response;\n    }\n    // async connect(): Promise<boolean> {\n    //   const response = (await this.provider.request({\n    //     method: \"connect\",\n    //     params: {},\n    //   })) as boolean;\n    //   return response;\n    // }\n    handleDappStorageKey(useLocalStorage) {\n        const localStorageKey = `${configuration.localStorageKeyPrefix}${window.location.hostname}`;\n        let dappStorageKey = \"\";\n        if (isLocalStorageAvailable && useLocalStorage) {\n            const storedKey = window.localStorage.getItem(localStorageKey);\n            if (storedKey) dappStorageKey = storedKey;\n            else {\n                const generatedKey = `torus-app-${getWindowId()}`;\n                window.localStorage.setItem(localStorageKey, generatedKey);\n                dappStorageKey = generatedKey;\n            }\n        }\n        this.dappStorageKey = dappStorageKey;\n        return dappStorageKey;\n    }\n    async _setupWeb3(providerParams) {\n        log.info(\"setupWeb3 running\");\n        // setup background connection\n        const providerStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.BasePostMessageStream({\n            name: \"embed_torus\",\n            target: \"iframe_torus\",\n            targetWindow: this.torusIframe.contentWindow\n        });\n        // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n        const communicationStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.BasePostMessageStream({\n            name: \"embed_communication\",\n            target: \"iframe_communication\",\n            targetWindow: this.torusIframe.contentWindow\n        });\n        // compose the inPage provider\n        const inPageProvider = new TorusInPageProvider(providerStream, {});\n        const communicationProvider = new TorusCommunicationProvider(communicationStream, {});\n        inPageProvider.tryWindowHandle = (payload, cb)=>{\n            const _payload = payload;\n            if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {\n                if (!this.communicationProvider.isLoggedIn) throw new Error(\"User Not Logged In\");\n                const windowId = getWindowId();\n                communicationProvider._handleWindow(windowId, {\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n                });\n                // for inPageProvider methods sending windowId in request instead of params\n                // as params might be positional.\n                _payload.windowId = windowId;\n            }\n            inPageProvider._rpcEngine.handle(_payload, cb);\n        };\n        communicationProvider.tryWindowHandle = (payload, cb)=>{\n            const _payload = payload;\n            if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {\n                const windowId = getWindowId();\n                communicationProvider._handleWindow(windowId, {\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW) // todo: are these features generic for all\n                });\n                // for communication methods sending window id in jrpc req params\n                _payload.params.windowId = windowId;\n            }\n            communicationProvider._rpcEngine.handle(_payload, cb);\n        };\n        // detect solana_requestAccounts and pipe to enable for now\n        const detectAccountRequestPrototypeModifier = (m)=>{\n            const originalMethod = inPageProvider[m];\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const self = this;\n            inPageProvider[m] = function providerFunc(request, cb) {\n                const { method, params = [] } = request;\n                if (method === \"solana_requestAccounts\") {\n                    if (!cb) return self.login({\n                        loginProvider: params[0]\n                    });\n                    self.login({\n                        loginProvider: params[0]\n                    })// eslint-disable-next-line promise/no-callback-in-promise\n                    .then((res)=>cb(null, res))// eslint-disable-next-line promise/no-callback-in-promise\n                    .catch((err)=>cb(err));\n                }\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                return originalMethod.apply(this, [\n                    request,\n                    cb\n                ]);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            };\n        };\n        // Detects call to solana_requestAccounts in request & sendAsync and passes to login\n        detectAccountRequestPrototypeModifier(\"request\");\n        detectAccountRequestPrototypeModifier(\"sendAsync\");\n        detectAccountRequestPrototypeModifier(\"send\");\n        const proxiedInPageProvider = new Proxy(inPageProvider, {\n            // straight up lie that we deleted the property so that it doesn't\n            // throw an error in strict mode\n            deleteProperty: ()=>true\n        });\n        const proxiedCommunicationProvider = new Proxy(communicationProvider, {\n            // straight up lie that we deleted the property so that it doesn't\n            // throw an error in strict mode\n            deleteProperty: ()=>true\n        });\n        this.provider = proxiedInPageProvider;\n        this.communicationProvider = proxiedCommunicationProvider;\n        await Promise.all([\n            inPageProvider._initializeState(),\n            communicationProvider._initializeState(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, providerParams), {}, {\n                dappStorageKey: this.dappStorageKey,\n                torusAlertContainer: this.torusAlertContainer,\n                torusIframe: this.torusIframe\n            }))\n        ]);\n        log.debug(\"Torus - injected provider\");\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvZGlzdC9zb2xhbmFFbWJlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ0c7QUFDeEI7QUFDaUk7QUFDekg7QUFDcUk7QUFDNUg7QUFDckM7QUFDUTtBQUNLO0FBRXJDLElBQUlxQixVQUFVO0FBRWQscURBQXFELEdBQ3JELFNBQVNDLFNBQVNDLE1BQU07SUFDdEIsT0FBT0EsV0FBVyxRQUFRLE9BQU9BLFdBQVcsWUFBWSxPQUFPQSxPQUFPQyxJQUFJLEtBQUs7QUFDakY7QUFDQSxTQUFTQyxpQkFBaUJGLE1BQU07SUFDOUIsT0FBT0QsU0FBU0MsV0FBV0EsT0FBT0csUUFBUSxLQUFLLFNBQVMsT0FBT0gsT0FBT0ksTUFBTSxLQUFLLGNBQWMsT0FBT0osT0FBT0ssY0FBYyxLQUFLO0FBQ2xJO0FBQ0EsU0FBU0MsaUJBQWlCTixNQUFNO0lBQzlCLE9BQU9ELFNBQVNDLFdBQVdBLE9BQU9PLFFBQVEsS0FBSyxTQUFTLE9BQU9QLE9BQU9RLEtBQUssS0FBSyxjQUFjLE9BQU9SLE9BQU9TLGNBQWMsS0FBSztBQUNqSTtBQUNBLFNBQVNDLGVBQWVWLE1BQU07SUFDNUIsT0FBT0UsaUJBQWlCRixXQUFXTSxpQkFBaUJOO0FBQ3REO0FBRUEsSUFBSVcsV0FBVztJQUNiQyxRQUFRO1FBQ05DLGNBQWMsSUFBTTtRQUNwQkMseUJBQXlCLElBQU07UUFDL0JDLGlCQUFpQkMsQ0FBQUEsU0FBVSxDQUFDLDZFQUE2RSxFQUFFQSxPQUFPLDhCQUE4QixDQUFDO1FBQ2pKQyxxQkFBcUIsSUFBTTtRQUMzQkMsZ0JBQWdCQyxDQUFBQSxvQkFBcUIsQ0FBQyxnREFBZ0QsRUFBRUEsa0JBQWtCLENBQUMsQ0FBQztRQUM1R0Msb0JBQW9CLElBQU0sQ0FBQyw4Q0FBOEMsQ0FBQztRQUMxRUMsc0JBQXNCLElBQU0sQ0FBQyx5Q0FBeUMsQ0FBQztRQUN2RUMsc0JBQXNCLElBQU0sQ0FBQyxxREFBcUQsQ0FBQztRQUNuRkMscUJBQXFCLElBQU0sQ0FBQyw0Q0FBNEMsQ0FBQztRQUN6RUMscUJBQXFCUixDQUFBQSxTQUFVLENBQUMsNENBQTRDLEVBQUVBLE9BQU8sRUFBRSxDQUFDO0lBQzFGO0lBQ0FTLE1BQU07UUFDSkMsV0FBV0MsQ0FBQUEsVUFBVyxDQUFDLG1DQUFtQyxFQUFFQSxRQUFRLEVBQUUsQ0FBQztJQUN6RTtJQUNBQyxVQUFVLENBQUM7QUFDYjtBQUVBLE1BQU1DLG1CQUFtQjtJQUN2QkMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLGFBQWE7SUFDYkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLFNBQVM7QUFDWDtBQUNBLE1BQU1DLGtCQUFrQjtJQUN0QkMsWUFBWTtJQUNaQyxhQUFhO0lBQ2JDLFNBQVM7QUFDWDtBQUNBLE1BQU1DLGtCQUFrQjtJQUN0QkMsYUFBYTtJQUNiQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsV0FBVztBQUNiO0FBQ0EsTUFBTUMsaUJBQWlCO0lBQ3JCQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxVQUFVO0lBQ1ZDLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLG9CQUFvQjtBQUN0QjtBQUVBLE1BQU1DLGVBQWU7SUFDbkJDLElBQUk7UUFDRkMsT0FBTztZQUNMQyxVQUFVO1lBQ1ZDLGdCQUFnQjtZQUNoQkMsZUFBZTtZQUNmQyxpQkFBaUI7WUFDakJDLGVBQWU7WUFDZkMsV0FBVztRQUNiO0lBQ0Y7SUFDQUMsSUFBSTtRQUNGUCxPQUFPO1lBQ0xDLFVBQVU7WUFDVkMsZ0JBQWdCO1lBQ2hCQyxlQUFlO1lBQ2ZDLGlCQUFpQjtZQUNqQkMsZUFBZTtZQUNmQyxXQUFXO1FBQ2I7SUFDRjtJQUNBRSxJQUFJO1FBQ0ZSLE9BQU87WUFDTEMsVUFBVTtZQUNWQyxnQkFBZ0I7WUFDaEJDLGVBQWU7WUFDZkMsaUJBQWlCO1lBQ2pCQyxlQUFlO1lBQ2ZDLFdBQVc7UUFDYjtJQUNGO0lBQ0FHLElBQUk7UUFDRlQsT0FBTztZQUNMQyxVQUFVO1lBQ1ZDLGdCQUFnQjtZQUNoQkMsZUFBZTtZQUNmQyxpQkFBaUI7WUFDakJDLGVBQWU7WUFDZkMsV0FBVztRQUNiO0lBQ0Y7SUFDQUksSUFBSTtRQUNGVixPQUFPO1lBQ0xDLFVBQVU7WUFDVkMsZ0JBQWdCO1lBQ2hCQyxlQUFlO1lBQ2ZDLGlCQUFpQjtZQUNqQkMsZUFBZTtZQUNmQyxXQUFXO1FBQ2I7SUFDRjtBQUNGO0FBQ0EsSUFBSUssZ0JBQWdCO0lBQ2xCQyx1QkFBdUI7UUFBQzdCLGVBQWVDLE1BQU07UUFBRUQsZUFBZUcsTUFBTTtRQUFFSCxlQUFlSSxPQUFPO0tBQUM7SUFDN0YwQixLQUFLO0lBQ0xmO0lBQ0FnQixjQUFjO0lBQ2RDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQztBQUNqQztBQUVBLElBQUlDLE1BQU1sRix5REFBa0IsQ0FBQztBQUU3QixvQkFBb0I7QUFFcEI7Ozs7O0NBS0MsR0FDRCxTQUFTb0Y7SUFDUCxPQUFPLENBQUNDLEtBQUtDLEtBQUtDO1FBQ2hCLHdFQUF3RTtRQUN4RSxJQUFJLE9BQU9GLElBQUlqRSxNQUFNLEtBQUssWUFBWSxDQUFDaUUsSUFBSWpFLE1BQU0sRUFBRTtZQUNqRGtFLElBQUlFLEtBQUssR0FBRzNGLHFEQUFTQSxDQUFDNEYsR0FBRyxDQUFDQyxjQUFjLENBQUM7Z0JBQ3ZDQyxTQUFTLENBQUMsZ0RBQWdELENBQUM7Z0JBQzNEQyxNQUFNUDtZQUNSO1FBQ0Y7UUFDQUUsS0FBS00sQ0FBQUE7WUFDSCxNQUFNLEVBQ0pMLEtBQUssRUFDTixHQUFHRjtZQUNKLElBQUksQ0FBQ0UsT0FBTztnQkFDVixPQUFPSztZQUNUO1lBQ0FYLElBQUlNLEtBQUssQ0FBQyxDQUFDLG1CQUFtQixFQUFFQSxNQUFNRyxPQUFPLENBQUMsQ0FBQyxFQUFFSDtZQUNqRCxPQUFPSztRQUNUO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0MsMkJBQTJCQyxXQUFXLEVBQUVQLEtBQUssRUFBRVEsT0FBTztJQUM3RCxJQUFJQyxhQUFhLENBQUMsMkJBQTJCLEVBQUVGLFlBQVksRUFBRSxDQUFDO0lBQzlELElBQUlQLE9BQU9VLE9BQU87UUFDaEJELGNBQWMsQ0FBQyxFQUFFLEVBQUVULE1BQU1VLEtBQUssQ0FBQyxDQUFDO0lBQ2xDO0lBQ0FoQixJQUFJaUIsSUFBSSxDQUFDRjtJQUNULElBQUlELFdBQVdBLFFBQVFJLGFBQWEsQ0FBQyxXQUFXLEdBQUc7UUFDakRKLFFBQVFLLElBQUksQ0FBQyxTQUFTSjtJQUN4QjtBQUNGO0FBQ0EsTUFBTUssY0FBYyxJQUFNQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxLQUFLLENBQUM7QUFDM0QsTUFBTUMsY0FBYyxPQUFNQztJQUN4QixJQUFJQztJQUNKLElBQUlDO0lBQ0osK0JBQStCO0lBQy9CLHdEQUF3RDtJQUN4RCxPQUFRRjtRQUNOLEtBQUs7WUFDSEMsV0FBVztZQUNYQyxXQUFXO1lBQ1g7UUFDRixLQUFLO1lBQ0hELFdBQVc7WUFDWEMsV0FBVztZQUNYO1FBQ0Y7WUFDRUQsV0FBVyxDQUFDLHFCQUFxQixDQUFDO1lBQ2xDQyxXQUFXO1lBQ1g7SUFDSjtJQUNBLE9BQU87UUFDTEQ7UUFDQUM7SUFDRjtBQUNGO0FBQ0EsTUFBTUMsa0JBQWtCO0lBQ3RCLElBQUlDLGVBQWVDLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxJQUFJO0lBQ2hELE1BQU1DLGdCQUFnQkosYUFBYUssS0FBSyxDQUFDO0lBQ3pDTCxlQUFlTSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDNUMsY0FBY2IsWUFBWSxFQUFFb0QsYUFBYSxDQUFDLEVBQUUsSUFBSUEsYUFBYSxDQUFDLEVBQUUsR0FBRztJQUN2SCxPQUFPSjtBQUNUO0FBQ0EsTUFBTVUsa0NBQWtDO0lBQ3RDQyxRQUFRO0lBQ1JDLE9BQU87QUFDVDtBQUNBLE1BQU1DLGlDQUFpQztJQUNyQ0YsUUFBUTtJQUNSQyxPQUFPO0FBQ1Q7QUFDQSxNQUFNRSxnQ0FBZ0M7SUFDcENILFFBQVE7SUFDUkMsT0FBTztBQUNUO0FBQ0EsTUFBTUcsMEJBQTBCO0lBQzlCSixRQUFRO0lBQ1JDLE9BQU87QUFDVDtBQUNBLFNBQVNJLGlCQUFpQkMsSUFBSTtJQUM1QixJQUFJQztJQUNKLElBQUk7UUFDRkEsVUFBVWpCLE1BQU0sQ0FBQ2dCLEtBQUs7UUFDdEIsTUFBTUUsSUFBSTtRQUNWRCxRQUFRRSxPQUFPLENBQUNELEdBQUdBO1FBQ25CRCxRQUFRRyxVQUFVLENBQUNGO1FBQ25CLE9BQU87SUFDVCxFQUFFLE9BQU8zQyxPQUFPO1FBQ2QsTUFBTThDLElBQUk5QztRQUNWLE9BQU84QyxLQUNQLDRCQUE0QjtRQUM1QkEsQ0FBQUEsRUFBRUMsSUFBSSxLQUFLLE1BQ1gsVUFBVTtRQUNWRCxFQUFFQyxJQUFJLEtBQUssUUFDWCx5REFBeUQ7UUFDekQsNEJBQTRCO1FBQzVCRCxFQUFFRSxJQUFJLEtBQUssd0JBQ1gsVUFBVTtRQUNWRixFQUFFRSxJQUFJLEtBQUssNEJBQTJCLEtBQ3RDLDBFQUEwRTtRQUMxRU4sV0FBV0EsUUFBUU8sTUFBTSxLQUFLO0lBQ2hDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELFNBQVNDLGlCQUFpQkMsSUFBSTtJQUM1QixJQUFJLEVBQ0ZmLE9BQU9nQixDQUFDLEVBQ1JqQixRQUFRa0IsQ0FBQyxFQUNWLEdBQUdGO0lBQ0osb0ZBQW9GO0lBQ3BGLE1BQU1HLGlCQUFpQjdCLE9BQU84QixVQUFVLEtBQUtDLFlBQVkvQixPQUFPOEIsVUFBVSxHQUFHOUIsT0FBT2dDLE9BQU87SUFDM0YsTUFBTUMsZ0JBQWdCakMsT0FBT2tDLFNBQVMsS0FBS0gsWUFBWS9CLE9BQU9rQyxTQUFTLEdBQUdsQyxPQUFPbUMsT0FBTztJQUN4RixNQUFNeEIsUUFBUVgsT0FBT29DLFVBQVUsR0FBR3BDLE9BQU9vQyxVQUFVLEdBQUdDLFNBQVNDLGVBQWUsQ0FBQ0MsV0FBVyxHQUFHRixTQUFTQyxlQUFlLENBQUNDLFdBQVcsR0FBR3ZDLE9BQU93QyxNQUFNLENBQUM3QixLQUFLO0lBQ3ZKLE1BQU1ELFNBQVNWLE9BQU95QyxXQUFXLEdBQUd6QyxPQUFPeUMsV0FBVyxHQUFHSixTQUFTQyxlQUFlLENBQUNJLFlBQVksR0FBR0wsU0FBU0MsZUFBZSxDQUFDSSxZQUFZLEdBQUcxQyxPQUFPd0MsTUFBTSxDQUFDOUIsTUFBTTtJQUM3SixNQUFNaUMsYUFBYSxHQUFHLHVCQUF1QjtJQUU3QyxNQUFNQyxPQUFPdEQsS0FBS3VELEdBQUcsQ0FBQyxDQUFDbEMsUUFBUWdCLENBQUFBLElBQUssSUFBSWdCLGFBQWFkO0lBQ3JELE1BQU1pQixNQUFNeEQsS0FBS3VELEdBQUcsQ0FBQyxDQUFDbkMsU0FBU2tCLENBQUFBLElBQUssSUFBSWUsYUFBYVY7SUFDckQsTUFBTWMsV0FBVyxDQUFDLDBEQUEwRCxFQUFFbkIsSUFBSWUsV0FBVyxPQUFPLEVBQUVoQixJQUFJZ0IsV0FBVyxLQUFLLEVBQUVHLElBQUksTUFBTSxFQUFFRixLQUFLLENBQUM7SUFDOUksT0FBT0c7QUFDVDtBQUVBLE1BQU1DLHFCQUFxQjNLLHVFQUFnQkE7SUFDekM0SyxZQUFZQyxnQkFBZ0IsRUFBRXhCLElBQUksQ0FBRTtRQUNsQyxJQUFJLEVBQ0ZwSCxvQkFBb0IsR0FBRyxFQUN2QjZJLG9CQUFvQixVQUFVLEVBQy9CLEdBQUd6QjtRQUNKLEtBQUs7UUFDTDs7S0FFQyxHQUNEN0osNEVBQWVBLENBQUMsSUFBSSxFQUFFLFdBQVcsS0FBSztRQUN0Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGNBQWMsS0FBSztRQUN6Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLDJCQUEyQixLQUFLO1FBQ3REQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxLQUFLO1FBQ3JDLElBQUksQ0FBQ2dDLGVBQWVxSixtQkFBbUI7WUFDckMsTUFBTSxJQUFJRSxNQUFNdEosU0FBU0MsTUFBTSxDQUFDSyxtQkFBbUI7UUFDckQ7UUFDQSxJQUFJLENBQUNpSixPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLGVBQWUsQ0FBQ2hKO1FBQ3JCLElBQUksQ0FBQ2lKLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDbkQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxJQUFJLENBQUNBLGlCQUFpQixDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUN6RCxJQUFJLENBQUNFLHVCQUF1QixHQUFHLElBQUksQ0FBQ0EsdUJBQXVCLENBQUNGLElBQUksQ0FBQyxJQUFJO1FBQ3JFLElBQUksQ0FBQ0csV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVyxDQUFDSCxJQUFJLENBQUMsSUFBSTtRQUM3QyxJQUFJLENBQUNJLGdCQUFnQixHQUFHLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUNKLElBQUksQ0FBQyxJQUFJO1FBQ3ZELElBQUksQ0FBQ0ssT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDTCxJQUFJLENBQUMsSUFBSTtRQUNyQyxJQUFJLENBQUNNLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ04sSUFBSSxDQUFDLElBQUk7UUFDekMsd0NBQXdDO1FBRXhDLHNDQUFzQztRQUN0QyxNQUFNTyxNQUFNLElBQUl6TCxzRUFBZUE7UUFDL0JRLDJDQUFJQSxDQUFDb0ssa0JBQWtCYSxLQUFLYixrQkFBa0IsSUFBSSxDQUFDUSx1QkFBdUIsQ0FBQ0YsSUFBSSxDQUFDLElBQUksRUFBRTtRQUV0RixzREFBc0Q7UUFDdERPLElBQUlDLFlBQVksQ0FBQztRQUVqQiw0QkFBNEI7UUFDNUIsNEJBQTRCO1FBRTVCLE1BQU1DLG9CQUFvQjFMLGlGQUFzQkE7UUFDaERPLDJDQUFJQSxDQUFDbUwsa0JBQWtCOUssTUFBTSxFQUFFNEssSUFBSUcsWUFBWSxDQUFDZixvQkFBb0JjLGtCQUFrQjlLLE1BQU0sRUFBRSxJQUFJLENBQUN1Syx1QkFBdUIsQ0FBQ0YsSUFBSSxDQUFDLElBQUksRUFBRTtRQUV0SSwrQ0FBK0M7UUFDL0MsTUFBTVcsWUFBWSxJQUFJM0wsaUVBQVVBO1FBQ2hDMkwsVUFBVUMsSUFBSSxDQUFDM0wsa0ZBQXVCQTtRQUN0QzBMLFVBQVVDLElBQUksQ0FBQ2pHO1FBQ2ZnRyxVQUFVQyxJQUFJLENBQUNyTSxtRkFBc0JBLENBQUM7WUFDcENzTSxRQUFRQyxTQUFTRCxNQUFNO1FBQ3pCO1FBQ0FGLFVBQVVDLElBQUksQ0FBQ0gsa0JBQWtCTSxVQUFVO1FBQzNDLElBQUksQ0FBQ0MsVUFBVSxHQUFHTDtRQUNsQixJQUFJLENBQUNNLHVCQUF1QixHQUFHUixrQkFBa0JTLE1BQU07SUFDekQ7SUFFQTs7O0dBR0MsR0FDRCxNQUFNYixRQUFRYyxJQUFJLEVBQUU7UUFDbEIsSUFBSSxDQUFDQSxRQUFRLE9BQU9BLFNBQVMsWUFBWUMsTUFBTUMsT0FBTyxDQUFDRixPQUFPO1lBQzVELE1BQU0vTCxxREFBU0EsQ0FBQzRGLEdBQUcsQ0FBQ0MsY0FBYyxDQUFDO2dCQUNqQ0MsU0FBUzVFLFNBQVNDLE1BQU0sQ0FBQ1Esa0JBQWtCO2dCQUMzQ29FLE1BQU1nRztZQUNSO1FBQ0Y7UUFDQSxNQUFNLEVBQ0p4SyxNQUFNLEVBQ04ySyxNQUFNLEVBQ1AsR0FBR0g7UUFDSixJQUFJLE9BQU94SyxXQUFXLFlBQVlBLE9BQU9xSCxNQUFNLEtBQUssR0FBRztZQUNyRCxNQUFNNUkscURBQVNBLENBQUM0RixHQUFHLENBQUNDLGNBQWMsQ0FBQztnQkFDakNDLFNBQVM1RSxTQUFTQyxNQUFNLENBQUNTLG9CQUFvQjtnQkFDN0NtRSxNQUFNZ0c7WUFDUjtRQUNGO1FBQ0EsSUFBSUcsV0FBVy9DLGFBQWEsQ0FBQzZDLE1BQU1DLE9BQU8sQ0FBQ0MsV0FBWSxRQUFPQSxXQUFXLFlBQVlBLFdBQVcsSUFBRyxHQUFJO1lBQ3JHLE1BQU1sTSxxREFBU0EsQ0FBQzRGLEdBQUcsQ0FBQ0MsY0FBYyxDQUFDO2dCQUNqQ0MsU0FBUzVFLFNBQVNDLE1BQU0sQ0FBQ1Usb0JBQW9CO2dCQUM3Q2tFLE1BQU1nRztZQUNSO1FBQ0Y7UUFDQSxPQUFPLElBQUlJLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0IsSUFBSSxDQUFDdEIsV0FBVyxDQUFDO2dCQUNmeEo7Z0JBQ0EySztZQUNGLEdBQUdwTSxnRkFBcUJBLENBQUNzTSxTQUFTQztRQUNwQztJQUNGO0lBQ0E7O0dBRUMsR0FDREMsS0FBS0MsT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDdEIsSUFBSSxDQUFDekIsV0FBVyxDQUFDd0IsU0FBU0M7SUFDNUI7SUFDQTs7R0FFQyxHQUNEdEIsVUFBVXFCLE9BQU8sRUFBRTtRQUNqQixPQUFPLElBQUlKLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0IsSUFBSSxDQUFDdEIsV0FBVyxDQUFDd0IsU0FBU3pNLGdGQUFxQkEsQ0FBQ3NNLFNBQVNDO1FBQzNEO0lBQ0Y7SUFFQTs7OztHQUlDLEdBQ0R2Qix3QkFBd0IyQixVQUFVLEVBQUU5RyxLQUFLLEVBQUU7UUFDekNNLDJCQUEyQndHLFlBQVk5RyxPQUFPLElBQUk7UUFDbEQsSUFBSSxDQUFDa0YsaUJBQWlCLENBQUMsT0FBT2xGLFFBQVFBLE1BQU1HLE9BQU8sR0FBR3FEO0lBQ3hEO0FBa0NGO0FBRUEsTUFBTXVELGdCQUFnQkMsQ0FBQUE7SUFDcEIsTUFBTUMsV0FBV3hGLE9BQU9xQyxRQUFRLENBQUNvRCxhQUFhLENBQUM7SUFDL0MsTUFBTUMsY0FBY0gsS0FBS0ksSUFBSSxJQUFJLHVEQUF1RDtJQUN4RkgsU0FBU0ksU0FBUyxHQUFHRjtJQUNyQixPQUFPRixTQUFTSyxPQUFPLENBQUNDLFVBQVU7QUFDcEM7QUFDQSxTQUFTQyw0QkFBNEJDLFdBQVc7SUFDOUMsT0FBT0EsWUFBWS9NLE9BQU8sS0FBSzhJO0FBQ2pDO0FBRUEsTUFBTWtFLHFCQUFxQjVOLHVFQUFnQkE7SUFDekM0SyxZQUFZdkIsSUFBSSxDQUFFO1FBQ2hCLElBQUksRUFDRndFLEdBQUcsRUFDSEMsTUFBTSxFQUNOcEQsUUFBUSxFQUNScUQsVUFBVSxLQUFLLEVBQ2hCLEdBQUcxRTtRQUNKLEtBQUs7UUFDTDdKLDRFQUFlQSxDQUFDLElBQUksRUFBRSxPQUFPLEtBQUs7UUFDbENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxVQUFVLEtBQUs7UUFDckNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxZQUFZLEtBQUs7UUFDdkNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxVQUFVLEtBQUs7UUFDckNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxlQUFlLEtBQUs7UUFDMUNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsS0FBSztRQUM1Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLFdBQVcsS0FBSztRQUN0QyxJQUFJLENBQUNxTyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxNQUFNLEdBQUdBLFVBQVU7UUFDeEIsSUFBSSxDQUFDcEQsUUFBUSxHQUFHQSxZQUFZdEIsaUJBQWlCWjtRQUM3QyxJQUFJLENBQUNiLE1BQU0sR0FBRytCO1FBQ2QsSUFBSSxDQUFDc0UsV0FBVyxHQUFHdEU7UUFDbkIsSUFBSSxDQUFDdUUsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0YsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0csV0FBVztJQUNsQjtJQUNBQSxjQUFjO1FBQ1osSUFBSSxDQUFDRixXQUFXLEdBQUdHLE9BQU9DLFlBQVk7WUFDcEMsSUFBSSxJQUFJLENBQUN6RyxNQUFNLElBQUksSUFBSSxDQUFDQSxNQUFNLENBQUMwRyxNQUFNLEVBQUU7Z0JBQ3JDQyxjQUFjLElBQUksQ0FBQ04sV0FBVztnQkFDOUJPLFdBQVc7b0JBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQ04sYUFBYSxFQUFFO3dCQUN2QixJQUFJLENBQUNsSCxJQUFJLENBQUM7b0JBQ1o7b0JBQ0EsSUFBSSxDQUFDa0gsYUFBYSxHQUFHO29CQUNyQixJQUFJLENBQUN0RyxNQUFNLEdBQUcrQjtnQkFDaEIsR0FBRyxJQUFJLENBQUNxRSxPQUFPO1lBQ2pCO1lBQ0EsSUFBSSxJQUFJLENBQUNwRyxNQUFNLEtBQUsrQixXQUFXNEUsY0FBYyxJQUFJLENBQUNOLFdBQVc7UUFDL0QsR0FBRztJQUNMO0lBQ0FRLE9BQU87UUFDTCxJQUFJLENBQUM3RyxNQUFNLEdBQUdBLE9BQU82RyxJQUFJLENBQUMsSUFBSSxDQUFDWCxHQUFHLENBQUNZLElBQUksRUFBRSxJQUFJLENBQUNYLE1BQU0sRUFBRSxJQUFJLENBQUNwRCxRQUFRO1FBQ25FLElBQUksSUFBSSxDQUFDL0MsTUFBTSxFQUFFK0csT0FBTyxJQUFJLENBQUMvRyxNQUFNLENBQUMrRyxLQUFLO1FBQ3pDLE9BQU9oQyxRQUFRQyxPQUFPO0lBQ3hCO0lBQ0FnQyxRQUFRO1FBQ04sSUFBSSxDQUFDVixhQUFhLEdBQUc7UUFDckIsSUFBSSxJQUFJLENBQUN0RyxNQUFNLEVBQUUsSUFBSSxDQUFDQSxNQUFNLENBQUNnSCxLQUFLO0lBQ3BDO0lBQ0FDLFNBQVNDLHlCQUF5QixFQUFFO1FBQ2xDLElBQUlBLDJCQUEyQjtZQUM3QmxILE9BQU9zRSxRQUFRLENBQUM2QyxPQUFPLENBQUMsSUFBSSxDQUFDakIsR0FBRyxDQUFDWSxJQUFJO1FBQ3ZDLE9BQU87WUFDTDlHLE9BQU9zRSxRQUFRLENBQUN3QyxJQUFJLEdBQUcsSUFBSSxDQUFDWixHQUFHLENBQUNZLElBQUk7UUFDdEM7SUFDRjtBQUNGO0FBRUEsTUFBTU0sbUNBQW1DcEU7SUFDdkNDLFlBQVlDLGdCQUFnQixFQUFFeEIsSUFBSSxDQUFFO1FBQ2xDLElBQUksRUFDRnBILG9CQUFvQixHQUFHLEVBQ3ZCNkksb0JBQW9CLFVBQVUsRUFDL0IsR0FBR3pCO1FBQ0osS0FBSyxDQUFDd0Isa0JBQWtCO1lBQ3RCNUk7WUFDQTZJO1FBQ0Y7UUFFQSxnQkFBZ0I7UUFDaEJ0TCw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUscUJBQXFCLEtBQUs7UUFDaERBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxZQUFZLEtBQUs7UUFDdkNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxrQkFBa0IsS0FBSztRQUM3Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGNBQWMsS0FBSztRQUN6Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLG1CQUFtQixLQUFLO1FBQzlDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsdUJBQXVCLEtBQUs7UUFDbERBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxlQUFlLEtBQUs7UUFDMUMsSUFBSSxDQUFDd1AsTUFBTSxHQUFHelAsMkVBQWFBLENBQUMsQ0FBQyxHQUFHd1AsMkJBQTJCRSxhQUFhO1FBRXhFLGVBQWU7UUFDZixJQUFJLENBQUMxSCxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDMkgsY0FBYyxHQUFHO1FBQ3RCLE1BQU1DLHVCQUF1QjVKLGNBQWNiLFlBQVksQ0FBQytDLGtCQUFrQjtRQUMxRSxJQUFJLENBQUMySCxpQkFBaUIsR0FBR0QscUJBQXFCdkssS0FBSztRQUNuRCxJQUFJLENBQUN5SyxVQUFVLEdBQUcsQ0FBQztRQUVuQiw0QkFBNEI7UUFFNUIsbUJBQW1CO1FBQ25CLElBQUksQ0FBQ0MsRUFBRSxDQUFDLFdBQVc7WUFDakIsSUFBSSxDQUFDTixNQUFNLENBQUNPLFdBQVcsR0FBRztRQUM1QjtRQUNBLE1BQU1DLHNCQUFzQjFDLENBQUFBO1lBQzFCLE1BQU0sRUFDSmhMLE1BQU0sRUFDTjJLLE1BQU0sRUFDUCxHQUFHSztZQUNKLElBQUloTCxXQUFXbEMsb0ZBQTJCQSxDQUFDNlAsYUFBYSxFQUFFO2dCQUN4RCxNQUFNLEVBQ0pDLFlBQVksRUFDWkMsR0FBRyxFQUNKLEdBQUdsRDtnQkFDSixJQUFJLENBQUNtRCxjQUFjLENBQUM7b0JBQ2xCQyxRQUFRSDtvQkFDUkMsS0FBS0E7Z0JBQ1A7WUFDQSx3RkFBd0Y7WUFDMUYsT0FBTyxJQUFJN04sV0FBVyxpQkFBaUI7Z0JBQ3JDLE1BQU0sRUFDSmdPLFFBQVEsRUFDUmpDLEdBQUcsRUFDSixHQUFHcEI7Z0JBQ0osSUFBSSxDQUFDc0Qsc0JBQXNCLENBQUNELFVBQVVqQztZQUN4QyxPQUFPLElBQUkvTCxXQUFXbEMsb0ZBQTJCQSxDQUFDb1EsWUFBWSxFQUFFO2dCQUM5RCxJQUFJLENBQUNDLGtCQUFrQixDQUFDeEQ7WUFDMUIsT0FBTyxJQUFJM0ssV0FBV2xDLG9GQUEyQkEsQ0FBQ3NRLGNBQWMsRUFBRTtnQkFDaEUsTUFBTSxFQUNKQyxvQkFBb0IsRUFDckIsR0FBRzFEO2dCQUNKLElBQUksQ0FBQ3VDLE1BQU0sQ0FBQ29CLFVBQVUsR0FBRztnQkFDekIsSUFBSSxDQUFDcEIsTUFBTSxDQUFDbUIsb0JBQW9CLEdBQUdBO1lBQ3JDLE9BQU8sSUFBSXJPLFdBQVdsQyxvRkFBMkJBLENBQUN5USxlQUFlLEVBQUU7Z0JBQ2pFLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQ29CLFVBQVUsR0FBRztnQkFDekIsSUFBSSxDQUFDcEIsTUFBTSxDQUFDbUIsb0JBQW9CLEdBQUc7Z0JBQ25DLElBQUksQ0FBQ1AsY0FBYztZQUNyQjtRQUNGO1FBQ0EsSUFBSSxDQUFDeEQsdUJBQXVCLENBQUNrRCxFQUFFLENBQUMsZ0JBQWdCRTtJQUNsRDtJQUNBLElBQUlZLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQ29CLFVBQVU7SUFDL0I7SUFDQSxJQUFJRSxxQkFBcUI7UUFDdkIsT0FBTyxJQUFJLENBQUN0QixNQUFNLENBQUNzQixrQkFBa0I7SUFDdkM7SUFFQTs7R0FFQyxHQUNEZixjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUNQLE1BQU0sQ0FBQ08sV0FBVztJQUNoQztJQUNBLE1BQU1oRSxpQkFBaUJrQixNQUFNLEVBQUU7UUFDN0IsSUFBSTtZQUNGLE1BQU0sRUFDSmxGLFFBQVEsRUFDUjJILGNBQWMsRUFDZHFCLG1CQUFtQixFQUNuQkMsV0FBVyxFQUNaLEdBQUcvRDtZQUNKLElBQUksQ0FBQ2xGLFFBQVEsR0FBR0E7WUFDaEIsSUFBSSxDQUFDMkgsY0FBYyxHQUFHQTtZQUN0QixJQUFJLENBQUNxQixtQkFBbUIsR0FBR0E7WUFDM0IsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1lBQ25CLElBQUksQ0FBQ0EsV0FBVyxDQUFDQyxnQkFBZ0IsQ0FBQyxRQUFRO2dCQUN4Qyw0Q0FBNEM7Z0JBQzVDLElBQUksQ0FBQyxJQUFJLENBQUN6QixNQUFNLENBQUNzQixrQkFBa0IsRUFBRSxJQUFJLENBQUNWLGNBQWM7WUFDMUQ7WUFDQSxNQUFNLEVBQ0pPLG9CQUFvQixFQUNwQkMsVUFBVSxFQUNYLEdBQUcsTUFBTSxJQUFJLENBQUM1RSxPQUFPLENBQUM7Z0JBQ3JCMUosUUFBUW5DLG1GQUEwQkEsQ0FBQytRLGtCQUFrQjtnQkFDckRqRSxRQUFRLEVBQUU7WUFDWjtZQUVBLHlEQUF5RDtZQUN6RCxJQUFJLENBQUN2QixjQUFjLENBQUNpRixzQkFBc0JDO1FBQzVDLEVBQUUsT0FBT2xLLE9BQU87WUFDZE4sSUFBSU0sS0FBSyxDQUFDLCtEQUErREE7UUFDM0UsU0FBVTtZQUNSTixJQUFJckQsSUFBSSxDQUFDO1lBQ1QsSUFBSSxDQUFDeU0sTUFBTSxDQUFDMkIsV0FBVyxHQUFHO1lBQzFCLElBQUksQ0FBQzVKLElBQUksQ0FBQztRQUNaO0lBQ0Y7SUFDQTZKLGNBQWNkLFFBQVEsRUFBRTtRQUN0QixJQUFJLEVBQ0ZqQyxHQUFHLEVBQ0hDLE1BQU0sRUFDTnBELFFBQVEsRUFDVCxHQUFHbUcsVUFBVTFILE1BQU0sR0FBRyxLQUFLMEgsU0FBUyxDQUFDLEVBQUUsS0FBS25ILFlBQVltSCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDekUsTUFBTUMsV0FBVyxJQUFJQyxJQUFJbEQsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDdEcsUUFBUSxDQUFDLG1CQUFtQixFQUFFdUksU0FBUyxDQUFDO1FBQ2hGLElBQUksSUFBSSxDQUFDWixjQUFjLEVBQUU7WUFDdkIsa0RBQWtEO1lBQ2xELElBQUk0QixTQUFTRSxJQUFJLEVBQUVGLFNBQVNFLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQzlCLGNBQWMsQ0FBQyxDQUFDO2lCQUFNNEIsU0FBU0UsSUFBSSxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDOUIsY0FBYyxDQUFDLENBQUM7UUFDNUk7UUFDQSxNQUFNK0IsZ0JBQWdCLElBQUlyRCxhQUFhO1lBQ3JDQyxLQUFLaUQ7WUFDTGhEO1lBQ0FwRDtRQUNGO1FBQ0F1RyxjQUFjekMsSUFBSTtRQUNsQixJQUFJLENBQUN5QyxjQUFjdEosTUFBTSxFQUFFO1lBQ3pCLElBQUksQ0FBQ29JLHNCQUFzQixDQUFDRCxVQUFVZ0IsU0FBU3JDLElBQUk7WUFDbkQ7UUFDRjtRQUNBLDZDQUE2QztRQUM3QyxJQUFJLENBQUNZLFVBQVUsQ0FBQ1MsU0FBUyxHQUFHbUI7UUFDNUIsa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ3pGLE9BQU8sQ0FBQztZQUNYMUosUUFBUTtZQUNSMkssUUFBUTtnQkFDTnFEO1lBQ0Y7UUFDRjtRQUNBbUIsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDMUIseUJBQXlCO1lBQ3pCLE9BQU8sSUFBSSxDQUFDN0IsVUFBVSxDQUFDUyxTQUFTO1lBQ2hDLElBQUksQ0FBQ3RFLE9BQU8sQ0FBQztnQkFDWDFKLFFBQVFuQyxtRkFBMEJBLENBQUN3UixhQUFhO2dCQUNoRDFFLFFBQVE7b0JBQ05xRDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBRixpQkFBaUI7UUFDZixJQUFJLEVBQ0ZDLFNBQVMsS0FBSyxFQUNkRixNQUFNLEVBQUUsRUFDVCxHQUFHa0IsVUFBVTFILE1BQU0sR0FBRyxLQUFLMEgsU0FBUyxDQUFDLEVBQUUsS0FBS25ILFlBQVltSCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDekUsTUFBTU8sUUFBUSxDQUFDO1FBQ2YsWUFBWTtRQUNaLElBQUksQ0FBQ3ZCLFFBQVE7WUFDWHVCLE1BQU1DLE9BQU8sR0FBRyxJQUFJLENBQUNyQyxNQUFNLENBQUNzQyxxQkFBcUIsR0FBRyxVQUFVO1lBQzlERixNQUFNL0ksTUFBTSxHQUFHO1lBQ2YrSSxNQUFNOUksS0FBSyxHQUFHO1lBQ2QsT0FBUSxJQUFJLENBQUMwRyxNQUFNLENBQUN1QyxjQUFjO2dCQUNoQyxLQUFLak8sZ0JBQWdCRSxRQUFRO29CQUMzQjROLE1BQU0zRyxHQUFHLEdBQUc7b0JBQ1oyRyxNQUFNN0csSUFBSSxHQUFHO29CQUNiNkcsTUFBTUksS0FBSyxHQUFHO29CQUNkSixNQUFNSyxNQUFNLEdBQUc7b0JBQ2Y7Z0JBQ0YsS0FBS25PLGdCQUFnQkksU0FBUztvQkFDNUIwTixNQUFNM0csR0FBRyxHQUFHO29CQUNaMkcsTUFBTUksS0FBSyxHQUFHO29CQUNkSixNQUFNN0csSUFBSSxHQUFHO29CQUNiNkcsTUFBTUssTUFBTSxHQUFHO29CQUNmO2dCQUNGLEtBQUtuTyxnQkFBZ0JHLFlBQVk7b0JBQy9CMk4sTUFBTUssTUFBTSxHQUFHO29CQUNmTCxNQUFNSSxLQUFLLEdBQUc7b0JBQ2RKLE1BQU0zRyxHQUFHLEdBQUc7b0JBQ1oyRyxNQUFNN0csSUFBSSxHQUFHO29CQUNiO2dCQUNGLEtBQUtqSCxnQkFBZ0JDLFdBQVc7Z0JBQ2hDO29CQUNFNk4sTUFBTUssTUFBTSxHQUFHO29CQUNmTCxNQUFNN0csSUFBSSxHQUFHO29CQUNiNkcsTUFBTTNHLEdBQUcsR0FBRztvQkFDWjJHLE1BQU1JLEtBQUssR0FBRztvQkFDZDtZQUNKO1FBQ0YsT0FBTztZQUNMSixNQUFNQyxPQUFPLEdBQUc7WUFDaEJELE1BQU05SSxLQUFLLEdBQUc7WUFDZDhJLE1BQU0vSSxNQUFNLEdBQUc7WUFDZitJLE1BQU0zRyxHQUFHLEdBQUc7WUFDWjJHLE1BQU1JLEtBQUssR0FBRztZQUNkSixNQUFNN0csSUFBSSxHQUFHO1lBQ2I2RyxNQUFNSyxNQUFNLEdBQUc7UUFDakI7UUFDQXpKLE9BQU8wSixNQUFNLENBQUMsSUFBSSxDQUFDbEIsV0FBVyxDQUFDWSxLQUFLLEVBQUVBO1FBQ3RDLElBQUksQ0FBQ3BDLE1BQU0sQ0FBQ3NCLGtCQUFrQixHQUFHVDtRQUNqQyxJQUFJLENBQUNyRSxPQUFPLENBQUM7WUFDWDFKLFFBQVFuQyxtRkFBMEJBLENBQUM4UCxhQUFhO1lBQ2hEaEQsUUFBUTtnQkFDTjZELG9CQUFvQlQ7Z0JBQ3BCRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBZ0Msa0JBQWtCO1FBQ2hCLElBQUksQ0FBQzNDLE1BQU0sQ0FBQ3NDLHFCQUFxQixHQUFHO1FBQ3BDLElBQUksQ0FBQzFCLGNBQWM7SUFDckI7SUFDQWdDLGtCQUFrQjtRQUNoQixJQUFJLENBQUM1QyxNQUFNLENBQUNzQyxxQkFBcUIsR0FBRztRQUNwQyxJQUFJLENBQUMxQixjQUFjO0lBQ3JCO0lBRUE7OztHQUdDLEdBQ0R0RSxZQUFZd0IsT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDN0IsTUFBTThFLEtBQUs5RTtRQUNYLE1BQU0rRSxXQUFXaEY7UUFDakIsSUFBSSxDQUFDUCxNQUFNQyxPQUFPLENBQUNzRixXQUFXO1lBQzVCLElBQUksQ0FBQ0EsU0FBU0MsT0FBTyxFQUFFO2dCQUNyQkQsU0FBU0MsT0FBTyxHQUFHO1lBQ3JCO1FBQ0Y7UUFDQSxJQUFJLENBQUNDLGVBQWUsQ0FBQ0YsVUFBVUQ7SUFDakM7SUFFQTs7Ozs7O0dBTUMsR0FDRDNHLGVBQWVpRixvQkFBb0IsRUFBRUMsVUFBVSxFQUFFO1FBQy9DLElBQUksQ0FBQyxJQUFJLENBQUNwQixNQUFNLENBQUNPLFdBQVcsRUFBRTtZQUM1QixJQUFJLENBQUNQLE1BQU0sQ0FBQ08sV0FBVyxHQUFHO1lBQzFCLElBQUksQ0FBQ3hJLElBQUksQ0FBQyxXQUFXO2dCQUNuQm9KO2dCQUNBQztZQUNGO1lBQ0F4SyxJQUFJcU0sS0FBSyxDQUFDeFEsU0FBU2MsSUFBSSxDQUFDQyxTQUFTLENBQUMyTjtRQUNwQztJQUNGO0lBRUE7Ozs7Ozs7Ozs7R0FVQyxHQUNEL0Usa0JBQWtCOEcsYUFBYSxFQUFFQyxZQUFZLEVBQUU7UUFDN0MsSUFBSSxJQUFJLENBQUNuRCxNQUFNLENBQUNPLFdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQ1AsTUFBTSxDQUFDb0QseUJBQXlCLElBQUksQ0FBQ0YsZUFBZTtZQUN2RixJQUFJLENBQUNsRCxNQUFNLENBQUNPLFdBQVcsR0FBRztZQUMxQixJQUFJcko7WUFDSixJQUFJZ00sZUFBZTtnQkFDakJoTSxRQUFRLElBQUkxRiw0REFBZ0JBLENBQUMsTUFDN0Isa0JBQWtCO2dCQUNsQjJSLGdCQUFnQjFRLFNBQVNDLE1BQU0sQ0FBQ0MsWUFBWTtnQkFDNUNpRSxJQUFJcU0sS0FBSyxDQUFDL0w7WUFDWixPQUFPO2dCQUNMQSxRQUFRLElBQUkxRiw0REFBZ0JBLENBQUMsTUFDN0IsaUJBQWlCO2dCQUNqQjJSLGdCQUFnQjFRLFNBQVNDLE1BQU0sQ0FBQ0UsdUJBQXVCO2dCQUN2RGdFLElBQUlNLEtBQUssQ0FBQ0E7Z0JBQ1YsSUFBSSxDQUFDOEksTUFBTSxDQUFDbUIsb0JBQW9CLEdBQUc7Z0JBQ25DLElBQUksQ0FBQ25CLE1BQU0sQ0FBQ29CLFVBQVUsR0FBRztnQkFDekIsSUFBSSxDQUFDcEIsTUFBTSxDQUFDc0MscUJBQXFCLEdBQUc7Z0JBQ3BDLElBQUksQ0FBQ3RDLE1BQU0sQ0FBQ3NCLGtCQUFrQixHQUFHO2dCQUNqQyxJQUFJLENBQUN0QixNQUFNLENBQUNvRCx5QkFBeUIsR0FBRztZQUMxQztZQUNBLElBQUksQ0FBQ3JMLElBQUksQ0FBQyxjQUFjYjtRQUMxQjtJQUNGO0lBRUEseUZBQXlGO0lBQ3pGK0osbUJBQW1CeEQsTUFBTSxFQUFFO1FBQ3pCLE1BQU0sRUFDSnFELFFBQVEsRUFDVCxHQUFHckQ7UUFDSixJQUFJLElBQUksQ0FBQzRDLFVBQVUsQ0FBQ1MsU0FBUyxFQUFFO1lBQzdCLElBQUksQ0FBQ1QsVUFBVSxDQUFDUyxTQUFTLENBQUNuQixLQUFLO1lBQy9CLE9BQU8sSUFBSSxDQUFDVSxVQUFVLENBQUNTLFNBQVM7UUFDbEM7SUFDRjtJQUNBLE1BQU1DLHVCQUF1QkQsUUFBUSxFQUFFakMsR0FBRyxFQUFFO1FBQzFDLE1BQU13RSxVQUFVLElBQUksQ0FBQ0MsVUFBVTtRQUMvQixNQUFNQyxhQUFhdEYsY0FBYyxrREFBa0QsQ0FBQyxxQ0FBcUMsRUFBRW9GLFFBQVEsVUFBVSxDQUFDLEdBQUcsVUFBVSxDQUFDLDJCQUEyQixFQUFFLElBQUksQ0FBQ2pELGlCQUFpQixDQUFDdEssY0FBYyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMseUJBQXlCLEVBQUUsSUFBSSxDQUFDc0ssaUJBQWlCLENBQUNySyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsV0FBVztRQUM1VCxNQUFNeU4sZUFBZXZGLGNBQWMsQ0FBQyw2QkFBNkIsRUFBRSxJQUFJLENBQUNtQyxpQkFBaUIsQ0FBQ3ZLLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFDOUcsTUFBTTROLGVBQWV4RixjQUFjO1FBQ25Dd0YsYUFBYUMsV0FBVyxDQUFDRjtRQUN6QkQsV0FBV0csV0FBVyxDQUFDRDtRQUN2QixNQUFNRSxhQUFhO1lBQ2pCSCxhQUFhL0IsZ0JBQWdCLENBQUMsU0FBUztnQkFDckMsSUFBSSxDQUFDRyxhQUFhLENBQUNkLFVBQVU7b0JBQzNCakM7b0JBQ0FDLFFBQVE7b0JBQ1JwRCxVQUFVdEIsaUJBQWlCWDtnQkFDN0I7Z0JBQ0E4SixXQUFXSyxNQUFNO2dCQUNqQixJQUFJLElBQUksQ0FBQ3JDLG1CQUFtQixDQUFDc0MsUUFBUSxDQUFDMUosTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDb0gsbUJBQW1CLENBQUNhLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO1lBQy9GO1FBQ0Y7UUFDQSxNQUFNeUIsZUFBZTtZQUNuQixJQUFJLENBQUN2QyxtQkFBbUIsQ0FBQ21DLFdBQVcsQ0FBQ0g7UUFDdkM7UUFDQU87UUFDQUg7UUFDQSxJQUFJLENBQUNwQyxtQkFBbUIsQ0FBQ2EsS0FBSyxDQUFDQyxPQUFPLEdBQUc7SUFDM0M7SUFDQWlCLGFBQWE7UUFDWCxNQUFNRCxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUM5SyxRQUFRLENBQUMsMkJBQTJCLENBQUM7UUFDN0QsT0FBTzhLO0lBQ1Q7QUFDRjtBQUNBN1MsNEVBQWVBLENBQUN1UCw0QkFBNEIsaUJBQWlCO0lBQzNEd0MsZ0JBQWdCO0lBQ2hCcEIsc0JBQXNCO0lBQ3RCRyxvQkFBb0I7SUFDcEJ5QyxzQkFBc0I7SUFDdEJ6Qix1QkFBdUI7SUFDdkJYLGFBQWE7SUFDYlAsWUFBWTtJQUNaZ0MsMkJBQTJCO0lBQzNCN0MsYUFBYTtBQUNmO0FBRUEsTUFBTXlELDRCQUE0QnJJO0lBQ2hDQyxZQUFZQyxnQkFBZ0IsRUFBRXhCLElBQUksQ0FBRTtRQUNsQyxJQUFJLEVBQ0ZwSCxvQkFBb0IsR0FBRyxFQUN2QjZJLG9CQUFvQixVQUFVLEVBQy9CLEdBQUd6QjtRQUNKLEtBQUssQ0FBQ3dCLGtCQUFrQjtZQUN0QjVJO1lBQ0E2STtRQUNGO1FBRUEsZ0JBQWdCO1FBQ2hCOzs7S0FHQyxHQUNEdEwsNEVBQWVBLENBQUMsSUFBSSxFQUFFLFdBQVcsS0FBSztRQUN0Qzs7OztLQUlDLEdBQ0RBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxtQkFBbUIsS0FBSztRQUM5Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLG1CQUFtQixLQUFLO1FBQzlDLElBQUksQ0FBQ3dQLE1BQU0sR0FBR3pQLDJFQUFhQSxDQUFDLENBQUMsR0FBR3lULG9CQUFvQi9ELGFBQWE7UUFFakUsZUFBZTtRQUNmLElBQUksQ0FBQ2dFLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUN4USxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUN5USxzQkFBc0IsR0FBRyxJQUFJLENBQUNBLHNCQUFzQixDQUFDL0gsSUFBSSxDQUFDLElBQUk7UUFDbkUsSUFBSSxDQUFDZ0ksbUJBQW1CLEdBQUcsSUFBSSxDQUFDQSxtQkFBbUIsQ0FBQ2hJLElBQUksQ0FBQyxJQUFJO1FBQzdELElBQUksQ0FBQ2lJLHlCQUF5QixHQUFHLElBQUksQ0FBQ0EseUJBQXlCLENBQUNqSSxJQUFJLENBQUMsSUFBSTtRQUV6RSw0QkFBNEI7UUFFNUIsbUJBQW1CO1FBQ25CLElBQUksQ0FBQ21FLEVBQUUsQ0FBQyxXQUFXO1lBQ2pCLElBQUksQ0FBQ04sTUFBTSxDQUFDTyxXQUFXLEdBQUc7UUFDNUI7UUFDQSxNQUFNOEQsNkJBQTZCdkcsQ0FBQUE7WUFDakMsTUFBTSxFQUNKaEwsTUFBTSxFQUNOMkssTUFBTSxFQUNQLEdBQUdLO1lBQ0osSUFBSWhMLFdBQVdoQywrRUFBc0JBLENBQUN3VCxnQkFBZ0IsRUFBRTtnQkFDdEQsSUFBSSxDQUFDSixzQkFBc0IsQ0FBQ3pHO1lBQzlCLE9BQU8sSUFBSTNLLFdBQVdoQywrRUFBc0JBLENBQUN5VCxvQkFBb0IsRUFBRTtnQkFDakUsSUFBSSxDQUFDSCx5QkFBeUIsQ0FBQzNHO1lBQ2pDLE9BQU8sSUFBSTNLLFdBQVdoQywrRUFBc0JBLENBQUMwVCxhQUFhLEVBQUU7Z0JBQzFELElBQUksQ0FBQ0wsbUJBQW1CLENBQUMxRztZQUMzQjtRQUNGO1FBRUEsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQ0wsdUJBQXVCLENBQUNrRCxFQUFFLENBQUMsZ0JBQWdCK0Q7SUFDbEQ7SUFFQTs7R0FFQyxHQUNEOUQsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDUCxNQUFNLENBQUNPLFdBQVc7SUFDaEM7SUFFQSxrQkFBa0I7SUFDbEIsdUJBQXVCO0lBQ3ZCOzs7O0dBSUMsR0FDRCxNQUFNaEUsbUJBQW1CO1FBQ3ZCLElBQUk7WUFDRixNQUFNLEVBQ0prSSxRQUFRLEVBQ1JoUixPQUFPLEVBQ1BpUixVQUFVLEVBQ1gsR0FBRyxNQUFNLElBQUksQ0FBQ2xJLE9BQU8sQ0FBQztnQkFDckIxSixRQUFRakMsOEVBQXFCQSxDQUFDNlEsa0JBQWtCO2dCQUNoRGpFLFFBQVEsRUFBRTtZQUNaO1lBRUEseURBQXlEO1lBQ3pELElBQUksQ0FBQzFGLElBQUksQ0FBQyxXQUFXO2dCQUNuQnRFO1lBQ0Y7WUFDQSxJQUFJLENBQUMwUSxtQkFBbUIsQ0FBQztnQkFDdkIxUTtZQUNGO1lBQ0EsSUFBSSxDQUFDMlEseUJBQXlCLENBQUM7Z0JBQzdCSztnQkFDQUM7WUFDRjtZQUNBLElBQUksQ0FBQ1Isc0JBQXNCLENBQUNPO1FBQzlCLEVBQUUsT0FBT3ZOLE9BQU87WUFDZE4sSUFBSU0sS0FBSyxDQUFDLCtEQUErREE7UUFDM0UsU0FBVTtZQUNSTixJQUFJckQsSUFBSSxDQUFDO1lBQ1QsSUFBSSxDQUFDeU0sTUFBTSxDQUFDMkIsV0FBVyxHQUFHO1lBQzFCLElBQUksQ0FBQzVKLElBQUksQ0FBQztRQUNaO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRHVFLFlBQVl3QixPQUFPLEVBQUVDLFFBQVEsRUFBRTtRQUM3QixJQUFJNEcsYUFBYTlDLFVBQVUxSCxNQUFNLEdBQUcsS0FBSzBILFNBQVMsQ0FBQyxFQUFFLEtBQUtuSCxZQUFZbUgsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUNyRixJQUFJZ0IsS0FBSzlFO1FBQ1QsTUFBTStFLFdBQVdoRjtRQUNqQixJQUFJLENBQUNQLE1BQU1DLE9BQU8sQ0FBQ3NGLFdBQVc7WUFDNUIsSUFBSSxDQUFDQSxTQUFTQyxPQUFPLEVBQUU7Z0JBQ3JCRCxTQUFTQyxPQUFPLEdBQUc7WUFDckI7WUFDQSxJQUFJRCxTQUFTaFEsTUFBTSxLQUFLLHFCQUFxQmdRLFNBQVNoUSxNQUFNLEtBQUssMEJBQTBCO2dCQUN6RiwyQkFBMkI7Z0JBQzNCK1AsS0FBSyxDQUFDK0IsS0FBSzVOO29CQUNULElBQUksQ0FBQ2tOLHNCQUFzQixDQUFDbE4sSUFBSTZOLE1BQU0sSUFBSSxFQUFFLEVBQUUvQixTQUFTaFEsTUFBTSxLQUFLLG1CQUFtQjZSO29CQUNyRjVHLFNBQVM2RyxLQUFLNU47Z0JBQ2hCO1lBQ0YsT0FBTyxJQUFJOEwsU0FBU2hRLE1BQU0sS0FBSywyQkFBMkI7Z0JBQ3hELElBQUksQ0FBQ3FLLFVBQVUsQ0FBQzJILE1BQU0sQ0FBQ2hILFNBQVMrRTtnQkFDaEM7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDRyxlQUFlLENBQUNGLFVBQVVEO0lBQ2pDO0lBRUE7Ozs7OztHQU1DLEdBQ0QzRyxlQUFlekksT0FBTyxFQUFFO1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUN1TSxNQUFNLENBQUNPLFdBQVcsRUFBRTtZQUM1QixJQUFJLENBQUNQLE1BQU0sQ0FBQ08sV0FBVyxHQUFHO1lBQzFCLElBQUksQ0FBQ3hJLElBQUksQ0FBQyxXQUFXO2dCQUNuQnRFO1lBQ0Y7WUFDQW1ELElBQUlxTSxLQUFLLENBQUN4USxTQUFTYyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0M7UUFDcEM7SUFDRjtJQUVBOzs7Ozs7Ozs7O0dBVUMsR0FDRDJJLGtCQUFrQjhHLGFBQWEsRUFBRUMsWUFBWSxFQUFFO1FBQzdDLElBQUksSUFBSSxDQUFDbkQsTUFBTSxDQUFDTyxXQUFXLElBQUksQ0FBQyxJQUFJLENBQUNQLE1BQU0sQ0FBQ29ELHlCQUF5QixJQUFJLENBQUNGLGVBQWU7WUFDdkYsSUFBSSxDQUFDbEQsTUFBTSxDQUFDTyxXQUFXLEdBQUc7WUFDMUIsSUFBSXJKO1lBQ0osSUFBSWdNLGVBQWU7Z0JBQ2pCaE0sUUFBUSxJQUFJMUYsNERBQWdCQSxDQUFDLE1BQzdCLGtCQUFrQjtnQkFDbEIyUixnQkFBZ0IxUSxTQUFTQyxNQUFNLENBQUNDLFlBQVk7Z0JBQzVDaUUsSUFBSXFNLEtBQUssQ0FBQy9MO1lBQ1osT0FBTztnQkFDTEEsUUFBUSxJQUFJMUYsNERBQWdCQSxDQUFDLE1BQzdCLGlCQUFpQjtnQkFDakIyUixnQkFBZ0IxUSxTQUFTQyxNQUFNLENBQUNFLHVCQUF1QjtnQkFDdkRnRSxJQUFJTSxLQUFLLENBQUNBO2dCQUNWLElBQUksQ0FBQ3pELE9BQU8sR0FBRztnQkFDZixJQUFJLENBQUN1TSxNQUFNLENBQUN5RSxRQUFRLEdBQUc7Z0JBQ3ZCLElBQUksQ0FBQ1IsZUFBZSxHQUFHO2dCQUN2QixJQUFJLENBQUNqRSxNQUFNLENBQUMwRSxVQUFVLEdBQUc7Z0JBQ3pCLElBQUksQ0FBQzFFLE1BQU0sQ0FBQ29ELHlCQUF5QixHQUFHO1lBQzFDO1lBQ0EsSUFBSSxDQUFDckwsSUFBSSxDQUFDLGNBQWNiO1FBQzFCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEZ04sdUJBQXVCTyxRQUFRLEVBQUU7UUFDL0IsSUFBSU0sZ0JBQWdCbEQsVUFBVTFILE1BQU0sR0FBRyxLQUFLMEgsU0FBUyxDQUFDLEVBQUUsS0FBS25ILFlBQVltSCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hGLElBQUk4QyxhQUFhOUMsVUFBVTFILE1BQU0sR0FBRyxLQUFLMEgsU0FBUyxDQUFDLEVBQUUsS0FBS25ILFlBQVltSCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3JGLHdCQUF3QjtRQUN4QixJQUFJbUQsZ0JBQWdCUDtRQUNwQixJQUFJLENBQUNsSCxNQUFNQyxPQUFPLENBQUN3SCxnQkFBZ0I7WUFDakNwTyxJQUFJTSxLQUFLLENBQUMseUVBQXlFOE47WUFDbkZBLGdCQUFnQixFQUFFO1FBQ3BCO1FBQ0EsS0FBSyxNQUFNQyxXQUFXUixTQUFVO1lBQzlCLElBQUksT0FBT1EsWUFBWSxVQUFVO2dCQUMvQnJPLElBQUlNLEtBQUssQ0FBQywrREFBK0R1TjtnQkFDekVPLGdCQUFnQixFQUFFO2dCQUNsQjtZQUNGO1FBQ0Y7UUFFQSx3RUFBd0U7UUFDeEUsSUFBSSxDQUFDclQsc0RBQU1BLENBQUMsSUFBSSxDQUFDcU8sTUFBTSxDQUFDeUUsUUFBUSxFQUFFTyxnQkFBZ0I7WUFDaEQseUVBQXlFO1lBQ3pFLG9EQUFvRDtZQUNwRCxJQUFJRCxpQkFBaUJ4SCxNQUFNQyxPQUFPLENBQUMsSUFBSSxDQUFDd0MsTUFBTSxDQUFDeUUsUUFBUSxLQUFLLElBQUksQ0FBQ3pFLE1BQU0sQ0FBQ3lFLFFBQVEsQ0FBQ3RLLE1BQU0sR0FBRyxLQUFLLENBQUN3SyxZQUFZO2dCQUMxRy9OLElBQUlNLEtBQUssQ0FBQyxtRkFBbUY4TjtZQUMvRjtZQUNBLElBQUksQ0FBQ2hGLE1BQU0sQ0FBQ3lFLFFBQVEsR0FBR087WUFDdkIsSUFBSSxDQUFDak4sSUFBSSxDQUFDLG1CQUFtQmlOO1FBQy9CO1FBRUEseUJBQXlCO1FBQ3pCLElBQUksSUFBSSxDQUFDZixlQUFlLEtBQUtlLGFBQWEsQ0FBQyxFQUFFLEVBQUU7WUFDN0MsSUFBSSxDQUFDZixlQUFlLEdBQUdlLGFBQWEsQ0FBQyxFQUFFLElBQUk7UUFDN0M7SUFDRjtJQUVBOzs7Ozs7OztHQVFDLEdBQ0RiLHNCQUFzQjtRQUNwQixJQUFJLEVBQ0YxUSxPQUFPLEVBQ1IsR0FBR29PLFVBQVUxSCxNQUFNLEdBQUcsS0FBSzBILFNBQVMsQ0FBQyxFQUFFLEtBQUtuSCxZQUFZbUgsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ3pFLElBQUksQ0FBQ3BPLFNBQVM7WUFDWm1ELElBQUlNLEtBQUssQ0FBQyx1RUFBdUU7Z0JBQy9FekQ7WUFDRjtZQUNBO1FBQ0Y7UUFDQSxJQUFJQSxZQUFZLFdBQVc7WUFDekIsSUFBSSxDQUFDMkksaUJBQWlCLENBQUM7UUFDekIsT0FBTztZQUNMLElBQUksQ0FBQ0YsY0FBYyxDQUFDekk7WUFDcEIsSUFBSUEsWUFBWSxJQUFJLENBQUNBLE9BQU8sRUFBRTtnQkFDNUIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO2dCQUNmLElBQUksSUFBSSxDQUFDdU0sTUFBTSxDQUFDMkIsV0FBVyxFQUFFO29CQUMzQixJQUFJLENBQUM1SixJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQ3RFLE9BQU87Z0JBQ3hDO1lBQ0Y7UUFDRjtJQUNGO0lBRUE7Ozs7Ozs7OztHQVNDLEdBQ0QyUSw0QkFBNEI7UUFDMUIsSUFBSSxFQUNGSyxRQUFRLEVBQ1JDLFVBQVUsRUFDWCxHQUFHN0MsVUFBVTFILE1BQU0sR0FBRyxLQUFLMEgsU0FBUyxDQUFDLEVBQUUsS0FBS25ILFlBQVltSCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDekUsSUFBSSxPQUFPNkMsZUFBZSxXQUFXO1lBQ25DOU4sSUFBSU0sS0FBSyxDQUFDLHlFQUF5RTtnQkFDakZ3TjtZQUNGO1lBQ0E7UUFDRjtRQUNBLElBQUlBLGVBQWUsSUFBSSxDQUFDMUUsTUFBTSxDQUFDMEUsVUFBVSxFQUFFO1lBQ3pDLElBQUksQ0FBQzFFLE1BQU0sQ0FBQzBFLFVBQVUsR0FBR0E7WUFDekIsSUFBSSxDQUFDUixzQkFBc0IsQ0FBQ08sWUFBWSxFQUFFO1FBQzVDO0lBQ0Y7QUFDRjtBQUNBalUsNEVBQWVBLENBQUN3VCxxQkFBcUIsaUJBQWlCO0lBQ3BEUyxVQUFVO0lBQ1ZsRSxhQUFhO0lBQ2JtRSxZQUFZO0lBQ1ovQyxhQUFhO0lBQ2J5QiwyQkFBMkI7SUFDM0JXLHNCQUFzQjtBQUN4QjtBQUVBOztDQUVDLEdBQ0QsU0FBU21CLFVBQVVyRyxHQUFHO0lBQ3BCLE9BQU8sSUFBSW5CLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDM0IsSUFBSTtZQUNGLE1BQU11SCxNQUFNbkssU0FBU29ELGFBQWEsQ0FBQztZQUNuQytHLElBQUlDLE1BQU0sR0FBRyxJQUFNekgsUUFBUTtZQUMzQndILElBQUlFLE9BQU8sR0FBRyxJQUFNMUgsUUFBUTtZQUM1QndILElBQUlHLEdBQUcsR0FBR3pHO1FBQ1osRUFBRSxPQUFPN0UsR0FBRztZQUNWNEQsT0FBTzVEO1FBQ1Q7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FDRCxNQUFNdUwsY0FBYzVNLENBQUFBO0lBQ2xCLE1BQU0sRUFDSnFDLFVBQUFBLFNBQVEsRUFDVCxHQUFHckM7SUFDSixNQUFNNk0sV0FBV3hLLFVBQVN5SyxhQUFhLENBQUM7SUFDeEMsSUFBSUQsVUFBVTtRQUNaLE9BQU9BLFNBQVNoSCxPQUFPO0lBQ3pCO0lBQ0EsTUFBTWtILFlBQVkxSyxVQUFTeUssYUFBYSxDQUFDO0lBQ3pDLElBQUlDLFdBQVc7UUFDYixPQUFPQSxVQUFVbEgsT0FBTztJQUMxQjtJQUNBLElBQUl4RCxVQUFTMkssS0FBSyxJQUFJM0ssVUFBUzJLLEtBQUssQ0FBQ3hMLE1BQU0sR0FBRyxHQUFHO1FBQy9DLE9BQU9hLFVBQVMySyxLQUFLO0lBQ3ZCO0lBQ0EsT0FBT2hOLFFBQU9zRSxRQUFRLENBQUMySSxRQUFRO0FBQ2pDO0FBRUE7O0NBRUMsR0FDRCxlQUFlQyxZQUFZbE4sT0FBTTtJQUMvQixJQUFJO1FBQ0YsTUFBTSxFQUNKcUMsVUFBQUEsU0FBUSxFQUNULEdBQUdyQztRQUVKLHNDQUFzQztRQUN0QyxJQUFJbU4sT0FBTzlLLFVBQVN5SyxhQUFhLENBQUM7UUFDbEMsSUFBSUssUUFBUyxNQUFNWixVQUFVWSxLQUFLckcsSUFBSSxHQUFJO1lBQ3hDLE9BQU9xRyxLQUFLckcsSUFBSTtRQUNsQjtRQUVBLHdEQUF3RDtRQUN4RHFHLE9BQU92SSxNQUFNd0ksSUFBSSxDQUFDL0ssVUFBU2dMLGdCQUFnQixDQUFDLDRCQUE0QkMsSUFBSSxDQUFDQyxDQUFBQSxRQUFTQyxRQUFRRCxNQUFNekcsSUFBSTtRQUN4RyxJQUFJcUcsUUFBUyxNQUFNWixVQUFVWSxLQUFLckcsSUFBSSxHQUFJO1lBQ3hDLE9BQU9xRyxLQUFLckcsSUFBSTtRQUNsQjtRQUNBLE9BQU87SUFDVCxFQUFFLE9BQU92SSxPQUFPO1FBQ2QsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNa1Asa0JBQWtCLFVBQWE7UUFDbkNsTSxNQUFNcUwsWUFBWTVNO1FBQ2xCbU4sTUFBTSxNQUFNRCxZQUFZbE47SUFDMUI7QUFFQSxNQUFNME4sMEJBQTBCO0lBQUM7SUFBb0I7SUFBb0I7SUFBeUI7SUFBZ0I7Q0FBVTtBQUM1SCxNQUFNQywrQkFBK0I7SUFBQzNWLG1GQUEwQkEsQ0FBQzRWLFlBQVk7Q0FBQztBQUM5RSxNQUFNQywwQkFBMEI5TSxpQkFBaUI7QUFFakQsK0ZBQStGO0FBQzlGLGdCQUFlK007SUFDZCxJQUFJO1FBQ0YsSUFBSSxPQUFPekwsYUFBYSxhQUFhO1FBQ3JDLE1BQU0wTCxrQkFBa0IxTCxTQUFTb0QsYUFBYSxDQUFDO1FBQy9DLE1BQU0sRUFDSjdGLFFBQVEsRUFDVCxHQUFHLE1BQU1GLFlBQVk7UUFDdEJxTyxnQkFBZ0JqSCxJQUFJLEdBQUcsQ0FBQyxFQUFFbEgsU0FBUyxNQUFNLENBQUM7UUFDMUNtTyxnQkFBZ0JDLFdBQVcsR0FBRztRQUM5QkQsZ0JBQWdCL00sSUFBSSxHQUFHO1FBQ3ZCK00sZ0JBQWdCRSxHQUFHLEdBQUc7UUFDdEIsSUFBSUYsZ0JBQWdCRyxPQUFPLElBQUlILGdCQUFnQkcsT0FBTyxDQUFDQyxRQUFRLEVBQUU7WUFDL0QsSUFBSUosZ0JBQWdCRyxPQUFPLENBQUNDLFFBQVEsQ0FBQyxhQUFhO2dCQUNoRDlMLFNBQVMrTCxJQUFJLENBQUNyRCxXQUFXLENBQUNnRDtZQUM1QjtRQUNGO0lBQ0YsRUFBRSxPQUFPeFAsT0FBTztRQUNkTixJQUFJaUIsSUFBSSxDQUFDWDtJQUNYO0FBQ0Y7QUFDQSxNQUFNOFA7SUFDSnBMLGFBQWM7UUFDWixJQUFJLEVBQ0ZxTCxjQUFjLEtBQUssRUFDcEIsR0FBR3BGLFVBQVUxSCxNQUFNLEdBQUcsS0FBSzBILFNBQVMsQ0FBQyxFQUFFLEtBQUtuSCxZQUFZbUgsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ3pFclIsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixLQUFLO1FBQzVDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsY0FBYyxLQUFLO1FBQ3pDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsZUFBZSxLQUFLO1FBQzFDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsZUFBZSxLQUFLO1FBQzFDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsMEJBQTBCLEtBQUs7UUFDckRBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxZQUFZLEtBQUs7UUFDdkNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSx5QkFBeUIsS0FBSztRQUNwREEsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGtCQUFrQixLQUFLO1FBQzdDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCO1FBQ3ZDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsdUJBQXVCLEtBQUs7UUFDbERBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxZQUFZLEtBQUs7UUFDdkNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxlQUFlLEtBQUs7UUFDMUNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxhQUFhLEtBQUs7UUFDeEMsSUFBSSxDQUFDK0gsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQzJPLGFBQWEsR0FBRyxPQUFPLFlBQVk7UUFDeEMsSUFBSSxDQUFDQyxzQkFBc0IsR0FBRztRQUM5QixJQUFJLENBQUNGLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDRyxXQUFXLEdBQUdILGNBQWM7UUFDakMsSUFBSSxDQUFDL0csY0FBYyxHQUFHO0lBQ3hCO0lBQ0EsSUFBSWtCLGFBQWE7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDaUcscUJBQXFCLEVBQUUsT0FBTztRQUN4QyxPQUFPLElBQUksQ0FBQ0EscUJBQXFCLENBQUNqRyxVQUFVO0lBQzlDO0lBQ0EsTUFBTWtHLE9BQU87UUFDWCxJQUFJLEVBQ0ZoUCxXQUFXcEUsZ0JBQWdCQyxVQUFVLEVBQ3JDb1QsZ0JBQWdCLEtBQUssRUFDckJDLE9BQU8sRUFDUDVFLGtCQUFrQixLQUFLLEVBQ3ZCNkUsa0JBQWtCLEtBQUssRUFDdkJsRixpQkFBaUJqTyxnQkFBZ0JDLFdBQVcsRUFDNUNtVCxTQUFTLGVBQWUsRUFDeEJDLGNBQWMsQ0FBQyxDQUFDLEVBQ2hCQyxVQUFVLEVBQ1gsR0FBRy9GLFVBQVUxSCxNQUFNLEdBQUcsS0FBSzBILFNBQVMsQ0FBQyxFQUFFLEtBQUtuSCxZQUFZbUgsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ3pFLElBQUksSUFBSSxDQUFDcUYsYUFBYSxFQUFFLE1BQU0sSUFBSW5MLE1BQU07UUFDeENoTCxrRUFBU0EsQ0FBQzJXO1FBQ1YsTUFBTSxFQUNKblAsUUFBUSxFQUNSQyxRQUFRLEVBQ1QsR0FBRyxNQUFNSCxZQUFZQztRQUN0QjFCLElBQUlpUixTQUFTO1FBQ2JqUixJQUFJckQsSUFBSSxDQUFDZ0YsVUFBVTtRQUNuQjNCLElBQUlyRCxJQUFJLENBQUMsQ0FBQyxzQkFBc0IsRUFBRTNCLFFBQVEsQ0FBQztRQUMzQyxJQUFJLENBQUMyRyxRQUFRLEdBQUdBO1FBQ2hCM0IsSUFBSWtSLGVBQWUsQ0FBQ3RQO1FBQ3BCLElBQUkrTyxlQUFlM1EsSUFBSWlSLFNBQVM7YUFBUWpSLElBQUltUixVQUFVO1FBQ3RELE1BQU03SCxpQkFBaUIsSUFBSSxDQUFDOEgsb0JBQW9CLENBQUNQO1FBQ2pELE1BQU1RLGlCQUFpQixJQUFJbEcsSUFBSXhKO1FBQy9CLElBQUkwUCxlQUFlQyxRQUFRLENBQUNDLFFBQVEsQ0FBQyxNQUFNRixlQUFlQyxRQUFRLElBQUk7YUFBYUQsZUFBZUMsUUFBUSxJQUFJO1FBQzlHLE1BQU1FLGFBQWEsSUFBSUM7UUFDdkIsSUFBSW5JLGdCQUFnQmtJLFdBQVdFLE1BQU0sQ0FBQyxrQkFBa0JwSTtRQUN4RGtJLFdBQVdFLE1BQU0sQ0FBQyxVQUFVM1AsT0FBT3NFLFFBQVEsQ0FBQ0QsTUFBTTtRQUNsRGlMLGVBQWVqRyxJQUFJLEdBQUdvRyxXQUFXalEsUUFBUTtRQUV6QyxjQUFjO1FBQ2QsSUFBSSxDQUFDcUosV0FBVyxHQUFHdkQsY0FBYyxDQUFDOzs7YUFHekIsRUFBRWdLLGVBQWV4SSxJQUFJLENBQUM7OytEQUU0QixFQUFFLElBQUksQ0FBQ3dILFdBQVcsQ0FBQzlPLFFBQVEsR0FBRztnQkFDN0UsQ0FBQztRQUNiLElBQUksQ0FBQ29KLG1CQUFtQixHQUFHdEQsY0FBYyxDQUFDLDREQUE0RCxFQUFFLElBQUksQ0FBQ21KLFdBQVcsQ0FBQ2pQLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDN0ksSUFBSSxDQUFDb1EsU0FBUyxHQUFHdEssY0FBYyxDQUFDLFlBQVksRUFBRTFGLFNBQVMsa0RBQWtELENBQUM7UUFDMUcsT0FBTyxJQUFJbUYsUUFBUSxDQUFDQyxTQUFTQztZQUMzQixJQUFJO2dCQUNGLElBQUksQ0FBQzRELFdBQVcsQ0FBQ0MsZ0JBQWdCLENBQUMsUUFBUTtvQkFDeEMsTUFBTStHLGVBQWUsTUFBTXBDO29CQUMzQix3QkFBd0I7b0JBQ3hCLElBQUksQ0FBQzVFLFdBQVcsQ0FBQ2lILGFBQWEsQ0FBQ0MsV0FBVyxDQUFDO3dCQUN6Q25HO3dCQUNBbUY7d0JBQ0FGO3dCQUNBZ0I7d0JBQ0FiO3dCQUNBQztvQkFDRixHQUFHSyxlQUFlakwsTUFBTTtvQkFDeEIsTUFBTSxJQUFJLENBQUMyTCxVQUFVLENBQUM7d0JBQ3BCcFE7b0JBQ0Y7b0JBQ0EsSUFBSXFLLGlCQUFpQixJQUFJLENBQUNBLGVBQWU7b0JBQ3pDLElBQUlnRixZQUFZZ0IsV0FBVyxJQUFJLENBQUNDLGFBQWEsR0FBR2pCLFdBQVdnQixTQUFTO3lCQUFNLElBQUksQ0FBQ2pHLGVBQWU7b0JBQzlGLElBQUksQ0FBQ3VFLGFBQWEsR0FBRztvQkFDckIsOERBQThEO29CQUM5RHZPLE9BQU9tUSxLQUFLLEdBQUcsSUFBSTtvQkFDbkJuTDtnQkFDRjtnQkFDQWhGLE9BQU9xQyxRQUFRLENBQUMrTCxJQUFJLENBQUNyRCxXQUFXLENBQUMsSUFBSSxDQUFDNkUsU0FBUztnQkFDL0M1UCxPQUFPcUMsUUFBUSxDQUFDK04sSUFBSSxDQUFDckYsV0FBVyxDQUFDLElBQUksQ0FBQ2xDLFdBQVc7Z0JBQ2pEN0ksT0FBT3FDLFFBQVEsQ0FBQytOLElBQUksQ0FBQ3JGLFdBQVcsQ0FBQyxJQUFJLENBQUNuQyxtQkFBbUI7WUFDM0QsRUFBRSxPQUFPckssT0FBTztnQkFDZDBHLE9BQU8xRztZQUNUO1FBQ0Y7SUFDRjtJQUNBLE1BQU04UixRQUFRO1FBQ1osSUFBSXZMLFNBQVNvRSxVQUFVMUgsTUFBTSxHQUFHLEtBQUswSCxTQUFTLENBQUMsRUFBRSxLQUFLbkgsWUFBWW1ILFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNsRixJQUFJLENBQUMsSUFBSSxDQUFDcUYsYUFBYSxFQUFFLE1BQU0sSUFBSW5MLE1BQU07UUFDekMsSUFBSTtZQUNGLElBQUksQ0FBQ29MLHNCQUFzQixHQUFHMUosT0FBT3dMLGFBQWEsSUFBSTtZQUN0RCxJQUFJLENBQUMsSUFBSSxDQUFDOUIsc0JBQXNCLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQ0UscUJBQXFCLENBQUN6RyxjQUFjLENBQUM7b0JBQ3hDQyxRQUFRO2dCQUNWO1lBQ0Y7WUFDQSxnRkFBZ0Y7WUFDaEYsTUFBTTdKLE1BQU0sTUFBTSxJQUFJMEcsUUFBUSxDQUFDQyxTQUFTQztnQkFDdEMsdUZBQXVGO2dCQUN2RixJQUFJLENBQUNzTCxRQUFRLENBQUM1TSxXQUFXLENBQUM7b0JBQ3hCeEosUUFBUTtvQkFDUjJLLFFBQVE7d0JBQUMsSUFBSSxDQUFDMEosc0JBQXNCO3dCQUFFMUosT0FBTzBMLFVBQVU7cUJBQUM7Z0JBQzFELEdBQUc5WCxnRkFBcUJBLENBQUNzTSxTQUFTQztZQUNwQztZQUNBLElBQUlMLE1BQU1DLE9BQU8sQ0FBQ3hHLFFBQVFBLElBQUltRCxNQUFNLEdBQUcsR0FBRztnQkFDeEMsT0FBT25EO1lBQ1Q7WUFDQSw0Q0FBNEM7WUFDNUMsTUFBTSxJQUFJK0UsTUFBTTtRQUNsQixFQUFFLE9BQU83RSxPQUFPO1lBQ2ROLElBQUlNLEtBQUssQ0FBQyxnQkFBZ0JBO1lBQzFCLE1BQU1BO1FBQ1IsU0FBVTtZQUNSLElBQUksSUFBSSxDQUFDbVEscUJBQXFCLENBQUMvRixrQkFBa0IsRUFBRSxJQUFJLENBQUMrRixxQkFBcUIsQ0FBQ3pHLGNBQWM7UUFDOUY7SUFDRjtJQUNBLE1BQU13SSxvQkFBb0JDLFdBQVcsRUFBRTtRQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDbkMsYUFBYSxFQUFFLE1BQU0sSUFBSW5MLE1BQU07UUFDekMsTUFBTSxFQUNKdU4sVUFBVSxFQUNWQyxRQUFRLEVBQ1QsR0FBR0Y7UUFDSixNQUFNLEVBQ0pHLE9BQU8sRUFDUixHQUFHLE1BQU0sSUFBSSxDQUFDbkMscUJBQXFCLENBQUM3SyxPQUFPLENBQUM7WUFDM0MxSixRQUFRO1lBQ1IySyxRQUFRO2dCQUNONkw7Z0JBQ0FDO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ0MsU0FBUyxNQUFNLElBQUl6TixNQUFNO0lBQ2hDO0lBQ0EsTUFBTTBOLFNBQVM7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDcEMscUJBQXFCLENBQUNqRyxVQUFVLEVBQUUsTUFBTSxJQUFJckYsTUFBTTtRQUM1RCxNQUFNLElBQUksQ0FBQ3NMLHFCQUFxQixDQUFDN0ssT0FBTyxDQUFDO1lBQ3ZDMUosUUFBUW5DLG1GQUEwQkEsQ0FBQytZLE1BQU07WUFDekNqTSxRQUFRLEVBQUU7UUFDWjtRQUNBLElBQUksQ0FBQzBKLHNCQUFzQixHQUFHO0lBQ2hDO0lBQ0EsTUFBTXdDLFVBQVU7UUFDZCxJQUFJLElBQUksQ0FBQ3RDLHFCQUFxQixDQUFDakcsVUFBVSxFQUFFO1lBQ3pDLE1BQU0sSUFBSSxDQUFDcUksTUFBTTtRQUNuQjtRQUNBLElBQUksQ0FBQ0csU0FBUztJQUNoQjtJQUNBQSxZQUFZO1FBQ1YsU0FBU0MsVUFBVUMsT0FBTztZQUN4QixPQUFPQSxtQkFBbUJDLFdBQVdELG1CQUFtQkU7UUFDMUQ7UUFDQSxJQUFJSCxVQUFVLElBQUksQ0FBQ3RCLFNBQVMsS0FBSzVQLE9BQU9xQyxRQUFRLENBQUMrTixJQUFJLENBQUNrQixRQUFRLENBQUMsSUFBSSxDQUFDMUIsU0FBUyxHQUFHO1lBQzlFLElBQUksQ0FBQ0EsU0FBUyxDQUFDM0UsTUFBTTtZQUNyQixJQUFJLENBQUMyRSxTQUFTLEdBQUc3TjtRQUNuQjtRQUNBLElBQUltUCxVQUFVLElBQUksQ0FBQ3JJLFdBQVcsS0FBSzdJLE9BQU9xQyxRQUFRLENBQUMrTixJQUFJLENBQUNrQixRQUFRLENBQUMsSUFBSSxDQUFDekksV0FBVyxHQUFHO1lBQ2xGLElBQUksQ0FBQ0EsV0FBVyxDQUFDb0MsTUFBTTtZQUN2QixJQUFJLENBQUNwQyxXQUFXLEdBQUc5RztRQUNyQjtRQUNBLElBQUltUCxVQUFVLElBQUksQ0FBQ3RJLG1CQUFtQixLQUFLNUksT0FBT3FDLFFBQVEsQ0FBQytOLElBQUksQ0FBQ2tCLFFBQVEsQ0FBQyxJQUFJLENBQUMxSSxtQkFBbUIsR0FBRztZQUNsRyxJQUFJLENBQUNnQyxVQUFVLEdBQUc3STtZQUNsQixJQUFJLENBQUM2RyxtQkFBbUIsQ0FBQ3FDLE1BQU07WUFDL0IsSUFBSSxDQUFDckMsbUJBQW1CLEdBQUc3RztRQUM3QjtRQUNBLElBQUksQ0FBQ3dNLGFBQWEsR0FBRztJQUN2QjtJQUNBdkUsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQzBFLHFCQUFxQixDQUFDMUUsZUFBZTtJQUM1QztJQUNBQyxrQkFBa0I7UUFDaEIsSUFBSSxDQUFDeUUscUJBQXFCLENBQUN6RSxlQUFlO0lBQzVDO0lBQ0EsTUFBTXNILFlBQVl6TSxNQUFNLEVBQUU7UUFDeEIsTUFBTSxJQUFJLENBQUM0SixxQkFBcUIsQ0FBQzdLLE9BQU8sQ0FBQztZQUN2QzFKLFFBQVFuQyxtRkFBMEJBLENBQUM0VixZQUFZO1lBQy9DOUksUUFBUWxOLDJFQUFhQSxDQUFDLENBQUMsR0FBR2tOO1FBQzVCO0lBQ0Y7SUFDQSxNQUFNME0sV0FBV0MsSUFBSSxFQUFFO1FBQ3JCLElBQUkzTSxTQUFTb0UsVUFBVTFILE1BQU0sR0FBRyxLQUFLMEgsU0FBUyxDQUFDLEVBQUUsS0FBS25ILFlBQVltSCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbEYsTUFBTXdJLGFBQWEsTUFBTSxJQUFJLENBQUNoRCxxQkFBcUIsQ0FBQzdLLE9BQU8sQ0FBQztZQUMxRDFKLFFBQVFuQyxtRkFBMEJBLENBQUMyWixrQkFBa0I7WUFDckQ3TSxRQUFRLEVBQUU7UUFDWjtRQUNBLE1BQU04TSxZQUFZSCxPQUFPLENBQUMsQ0FBQyxFQUFFQSxLQUFLLENBQUMsR0FBRztRQUN0QyxNQUFNdEksV0FBVyxJQUFJQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUN4SixRQUFRLENBQUMsT0FBTyxFQUFFZ1MsVUFBVSxDQUFDO1FBQzlELGlGQUFpRjtRQUNqRnpJLFNBQVMwSSxZQUFZLENBQUNsQyxNQUFNLENBQUMsY0FBYytCO1FBQzNDclIsT0FBT3lSLElBQUksQ0FBQ2hOLFFBQVFpTixPQUFPLENBQUM3USxDQUFBQTtZQUMxQmlJLFNBQVMwSSxZQUFZLENBQUNsQyxNQUFNLENBQUN6TyxHQUFHNEQsTUFBTSxDQUFDNUQsRUFBRTtRQUMzQztRQUNBLElBQUksSUFBSSxDQUFDcUcsY0FBYyxFQUFFO1lBQ3ZCNEIsU0FBU0UsSUFBSSxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDOUIsY0FBYyxDQUFDLENBQUM7UUFDMUQ7UUFDQSxvRUFBb0U7UUFDcEUsTUFBTXlLLGVBQWUsSUFBSS9MLGFBQWE7WUFDcENDLEtBQUtpRDtZQUNMcEcsVUFBVXRCLGlCQUFpQmI7UUFDN0I7UUFDQW9SLGFBQWFuTCxJQUFJO0lBQ25CO0lBQ0EsTUFBTW9MLGNBQWM7UUFDbEIsTUFBTUMsbUJBQW1CLE1BQU0sSUFBSSxDQUFDeEQscUJBQXFCLENBQUM3SyxPQUFPLENBQUM7WUFDaEUxSixRQUFRbkMsbUZBQTBCQSxDQUFDbWEsU0FBUztZQUM1Q3JOLFFBQVEsRUFBRTtRQUNaO1FBQ0EsT0FBT29OO0lBQ1Q7SUFDQSxNQUFNRSxjQUFjN0IsUUFBUSxFQUFFekwsTUFBTSxFQUFFO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUN5SixhQUFhLEVBQUUsTUFBTSxJQUFJbkwsTUFBTTtRQUN6QyxNQUFNK0UsV0FBVzlJO1FBQ2pCLElBQUksQ0FBQ3FQLHFCQUFxQixDQUFDekYsYUFBYSxDQUFDZDtRQUN6QyxNQUFNa0ssZ0JBQWdCLE1BQU0sSUFBSSxDQUFDM0QscUJBQXFCLENBQUM3SyxPQUFPLENBQUM7WUFDN0QxSixRQUFRbkMsbUZBQTBCQSxDQUFDc2EsS0FBSztZQUN4Q3hOLFFBQVE7Z0JBQ055TDtnQkFDQXpMO2dCQUNBcUQ7WUFDRjtRQUNGO1FBQ0EsT0FBT2tLO0lBQ1Q7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTUUsY0FBYztRQUNsQixNQUFNQyxXQUFXLE1BQU0sSUFBSSxDQUFDakMsUUFBUSxDQUFDMU0sT0FBTyxDQUFDO1lBQzNDMUosUUFBUTtZQUNSMkssUUFBUSxFQUFFO1FBQ1o7UUFDQSxPQUFPME47SUFDVDtJQUNBLE1BQU1DLGdCQUFnQnpNLFdBQVcsRUFBRTtRQUNqQyxNQUFNME0sc0JBQXNCM00sNEJBQTRCQztRQUN4RCxNQUFNdEgsVUFBVWdVLHNCQUFzQjFNLFlBQVkyTSxTQUFTLENBQUM7WUFDMURDLHNCQUFzQjtRQUN4QixHQUFHcFQsUUFBUSxDQUFDLFNBQVNxVCxPQUFPekYsSUFBSSxDQUFDcEgsWUFBWTJNLFNBQVMsSUFBSW5ULFFBQVEsQ0FBQztRQUNuRSxNQUFNZ1QsV0FBVyxNQUFNLElBQUksQ0FBQ2pDLFFBQVEsQ0FBQzFNLE9BQU8sQ0FBQztZQUMzQzFKLFFBQVE7WUFDUjJLLFFBQVE7Z0JBQ05wRztnQkFDQWdVO1lBQ0Y7UUFDRjtRQUNBLE9BQU9GO0lBQ1Q7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTU0sdUJBQXVCOU0sV0FBVyxFQUFFK00sT0FBTyxFQUFFO1FBQ2pELE1BQU1MLHNCQUFzQjNNLDRCQUE0QkM7UUFDeEQsTUFBTXRILFVBQVVnVSxzQkFBc0IxTSxZQUFZMk0sU0FBUyxDQUFDO1lBQzFEQyxzQkFBc0I7UUFDeEIsR0FBR3BULFFBQVEsQ0FBQyxTQUFTcVQsT0FBT3pGLElBQUksQ0FBQ3BILFlBQVkyTSxTQUFTLElBQUluVCxRQUFRLENBQUM7UUFDbkUsTUFBTWdULFdBQVcsTUFBTSxJQUFJLENBQUNqQyxRQUFRLENBQUMxTSxPQUFPLENBQUM7WUFDM0MxSixRQUFRO1lBQ1IySyxRQUFRO2dCQUNOcEc7Z0JBQ0FxVTtnQkFDQUw7WUFDRjtRQUNGO1FBQ0EsT0FBTztZQUNMTSxXQUFXUjtRQUNiO0lBQ0Y7SUFDQSxNQUFNUyxnQkFBZ0JqTixXQUFXLEVBQUU7UUFDakMsTUFBTTBNLHNCQUFzQjNNLDRCQUE0QkM7UUFDeEQsTUFBTXRILFVBQVVnVSxzQkFBc0IxTSxZQUFZa04sZ0JBQWdCLEdBQUcxVCxRQUFRLENBQUMsU0FBU3FULE9BQU96RixJQUFJLENBQUNwSCxZQUFZdEgsT0FBTyxDQUFDaVUsU0FBUyxJQUFJblQsUUFBUSxDQUFDO1FBQzdJLE1BQU1nVCxXQUFXLE1BQU0sSUFBSSxDQUFDakMsUUFBUSxDQUFDMU0sT0FBTyxDQUFDO1lBQzNDMUosUUFBUTtZQUNSMkssUUFBUTtnQkFDTnBHO2dCQUNBeVUsYUFBYTtnQkFDYlQ7WUFDRjtRQUNGO1FBRUEsNkJBQTZCO1FBQzdCLE1BQU1VLFNBQVNDLEtBQUtDLEtBQUssQ0FBQ2Q7UUFDMUIsTUFBTVEsWUFBWTtZQUNoQk8sV0FBVyxJQUFJemIsc0RBQVNBLENBQUNzYixPQUFPRyxTQUFTO1lBQ3pDUCxXQUFXSCxPQUFPekYsSUFBSSxDQUFDZ0csT0FBT0osU0FBUyxFQUFFO1FBQzNDO1FBQ0FoTixZQUFZd04sWUFBWSxDQUFDUixVQUFVTyxTQUFTLEVBQUVQLFVBQVVBLFNBQVM7UUFDakUsT0FBT2hOO0lBQ1Q7SUFDQSxNQUFNeU4sb0JBQW9CQyxZQUFZLEVBQUU7UUFDdEMsSUFBSWhCO1FBQ0osTUFBTWlCLGlCQUFpQkQsYUFBYUUsR0FBRyxDQUFDQyxDQUFBQTtZQUN0Q25CLHNCQUFzQjNNLDRCQUE0QjhOO1lBQ2xELE9BQU9uQixzQkFBc0JtQixHQUFHWCxnQkFBZ0IsR0FBRzFULFFBQVEsQ0FBQyxTQUFTcVQsT0FBT3pGLElBQUksQ0FBQ3lHLEdBQUduVixPQUFPLENBQUNpVSxTQUFTLElBQUluVCxRQUFRLENBQUM7UUFDcEg7UUFDQSxNQUFNc1UsWUFBWSxNQUFNLElBQUksQ0FBQ3ZELFFBQVEsQ0FBQzFNLE9BQU8sQ0FBQztZQUM1QzFKLFFBQVE7WUFDUjJLLFFBQVE7Z0JBQ05wRyxTQUFTaVY7Z0JBQ1RSLGFBQWE7Z0JBQ2JUO1lBQ0Y7UUFDRjtRQUVBLDhCQUE4QjtRQUM5QixNQUFNcUIsYUFBYUQsVUFBVUYsR0FBRyxDQUFDSSxDQUFBQTtZQUMvQixNQUFNWixTQUFTQyxLQUFLQyxLQUFLLENBQUNVO1lBQzFCLE9BQU87Z0JBQ0xULFdBQVcsSUFBSXpiLHNEQUFTQSxDQUFDc2IsT0FBT0csU0FBUztnQkFDekNQLFdBQVdILE9BQU96RixJQUFJLENBQUNnRyxPQUFPSixTQUFTLEVBQUU7WUFDM0M7UUFDRjtRQUNBVSxhQUFhM0IsT0FBTyxDQUFDLENBQUM4QixJQUFJSTtZQUN4QkosR0FBR0wsWUFBWSxDQUFDTyxVQUFVLENBQUNFLElBQUksQ0FBQ1YsU0FBUyxFQUFFUSxVQUFVLENBQUNFLElBQUksQ0FBQ2pCLFNBQVM7WUFDcEUsT0FBT2E7UUFDVDtRQUNBLE9BQU9IO0lBQ1Q7SUFDQSxNQUFNUSxZQUFZdlYsSUFBSSxFQUFFO1FBQ3RCLE1BQU02VCxXQUFXLE1BQU0sSUFBSSxDQUFDakMsUUFBUSxDQUFDMU0sT0FBTyxDQUFDO1lBQzNDMUosUUFBUTtZQUNSMkssUUFBUTtnQkFDTm5HO1lBQ0Y7UUFDRjtRQUNBLE9BQU82VDtJQUNUO0lBQ0EsTUFBTTJCLHNCQUFzQjtRQUMxQixNQUFNM0IsV0FBVyxNQUFNLElBQUksQ0FBQ2pDLFFBQVEsQ0FBQzFNLE9BQU8sQ0FBQztZQUMzQzFKLFFBQVE7WUFDUjJLLFFBQVEsRUFBRTtRQUNaO1FBQ0EsT0FBTzBOO0lBQ1Q7SUFFQSxzQ0FBc0M7SUFDdEMsb0RBQW9EO0lBQ3BELHlCQUF5QjtJQUN6QixrQkFBa0I7SUFDbEIsb0JBQW9CO0lBQ3BCLHFCQUFxQjtJQUNyQixJQUFJO0lBRUpuRCxxQkFBcUJQLGVBQWUsRUFBRTtRQUNwQyxNQUFNc0Ysa0JBQWtCLENBQUMsRUFBRXhXLGNBQWNJLHFCQUFxQixDQUFDLEVBQUVnQyxPQUFPc0UsUUFBUSxDQUFDMkksUUFBUSxDQUFDLENBQUM7UUFDM0YsSUFBSTFGLGlCQUFpQjtRQUNyQixJQUFJc0csMkJBQTJCaUIsaUJBQWlCO1lBQzlDLE1BQU11RixZQUFZclUsT0FBT3NVLFlBQVksQ0FBQ0MsT0FBTyxDQUFDSDtZQUM5QyxJQUFJQyxXQUFXOU0saUJBQWlCOE07aUJBQWU7Z0JBQzdDLE1BQU1HLGVBQWUsQ0FBQyxVQUFVLEVBQUVuVixjQUFjLENBQUM7Z0JBQ2pEVyxPQUFPc1UsWUFBWSxDQUFDblQsT0FBTyxDQUFDaVQsaUJBQWlCSTtnQkFDN0NqTixpQkFBaUJpTjtZQUNuQjtRQUNGO1FBQ0EsSUFBSSxDQUFDak4sY0FBYyxHQUFHQTtRQUN0QixPQUFPQTtJQUNUO0lBQ0EsTUFBTXlJLFdBQVd5RSxjQUFjLEVBQUU7UUFDL0J4VyxJQUFJckQsSUFBSSxDQUFDO1FBQ1QsOEJBQThCO1FBQzlCLE1BQU04WixpQkFBaUIsSUFBSS9iLDRFQUFxQkEsQ0FBQztZQUMvQzRJLE1BQU07WUFDTjRFLFFBQVE7WUFDUndPLGNBQWMsSUFBSSxDQUFDOUwsV0FBVyxDQUFDaUgsYUFBYTtRQUM5QztRQUVBLHNGQUFzRjtRQUN0RixNQUFNOEUsc0JBQXNCLElBQUlqYyw0RUFBcUJBLENBQUM7WUFDcEQ0SSxNQUFNO1lBQ040RSxRQUFRO1lBQ1J3TyxjQUFjLElBQUksQ0FBQzlMLFdBQVcsQ0FBQ2lILGFBQWE7UUFDOUM7UUFFQSw4QkFBOEI7UUFDOUIsTUFBTStFLGlCQUFpQixJQUFJeEosb0JBQW9CcUosZ0JBQWdCLENBQUM7UUFDaEUsTUFBTWhHLHdCQUF3QixJQUFJdEgsMkJBQTJCd04scUJBQXFCLENBQUM7UUFDbkZDLGVBQWV4SyxlQUFlLEdBQUcsQ0FBQ2xGLFNBQVMrRTtZQUN6QyxNQUFNQyxXQUFXaEY7WUFDakIsSUFBSSxDQUFDUCxNQUFNQyxPQUFPLENBQUNzRixhQUFhdUQsd0JBQXdCb0gsUUFBUSxDQUFDM0ssU0FBU2hRLE1BQU0sR0FBRztnQkFDakYsSUFBSSxDQUFDLElBQUksQ0FBQ3VVLHFCQUFxQixDQUFDakcsVUFBVSxFQUFFLE1BQU0sSUFBSXJGLE1BQU07Z0JBQzVELE1BQU0rRSxXQUFXOUk7Z0JBQ2pCcVAsc0JBQXNCekYsYUFBYSxDQUFDZCxVQUFVO29CQUM1Q2hDLFFBQVE7b0JBQ1JwRCxVQUFVdEIsaUJBQWlCWDtnQkFDN0I7Z0JBQ0EsMkVBQTJFO2dCQUMzRSxpQ0FBaUM7Z0JBQ2pDcUosU0FBU2hDLFFBQVEsR0FBR0E7WUFDdEI7WUFDQTBNLGVBQWVyUSxVQUFVLENBQUMySCxNQUFNLENBQUNoQyxVQUFVRDtRQUM3QztRQUNBd0Usc0JBQXNCckUsZUFBZSxHQUFHLENBQUNsRixTQUFTK0U7WUFDaEQsTUFBTUMsV0FBV2hGO1lBQ2pCLElBQUksQ0FBQ1AsTUFBTUMsT0FBTyxDQUFDc0YsYUFBYXdELDZCQUE2Qm1ILFFBQVEsQ0FBQzNLLFNBQVNoUSxNQUFNLEdBQUc7Z0JBQ3RGLE1BQU1nTyxXQUFXOUk7Z0JBQ2pCcVAsc0JBQXNCekYsYUFBYSxDQUFDZCxVQUFVO29CQUM1Q2hDLFFBQVE7b0JBQ1JwRCxVQUFVdEIsaUJBQWlCaEIsaUNBQWlDLDJDQUEyQztnQkFDekc7Z0JBQ0EsaUVBQWlFO2dCQUNqRTBKLFNBQVNyRixNQUFNLENBQUNxRCxRQUFRLEdBQUdBO1lBQzdCO1lBQ0F1RyxzQkFBc0JsSyxVQUFVLENBQUMySCxNQUFNLENBQUNoQyxVQUFVRDtRQUNwRDtRQUVBLDJEQUEyRDtRQUMzRCxNQUFNNkssd0NBQXdDQyxDQUFBQTtZQUM1QyxNQUFNQyxpQkFBaUJKLGNBQWMsQ0FBQ0csRUFBRTtZQUN4Qyw0REFBNEQ7WUFDNUQsTUFBTUUsT0FBTyxJQUFJO1lBQ2pCTCxjQUFjLENBQUNHLEVBQUUsR0FBRyxTQUFTRyxhQUFhdFIsT0FBTyxFQUFFcUcsRUFBRTtnQkFDbkQsTUFBTSxFQUNKL1AsTUFBTSxFQUNOMkssU0FBUyxFQUFFLEVBQ1osR0FBR2pCO2dCQUNKLElBQUkxSixXQUFXLDBCQUEwQjtvQkFDdkMsSUFBSSxDQUFDK1AsSUFBSSxPQUFPZ0wsS0FBSzdFLEtBQUssQ0FBQzt3QkFDekJDLGVBQWV4TCxNQUFNLENBQUMsRUFBRTtvQkFDMUI7b0JBQ0FvUSxLQUFLN0UsS0FBSyxDQUFDO3dCQUNUQyxlQUFleEwsTUFBTSxDQUFDLEVBQUU7b0JBQzFCLEVBQ0EsMERBQTBEO3FCQUN6RHNRLElBQUksQ0FBQy9XLENBQUFBLE1BQU82TCxHQUFHLE1BQU03TCxLQUN0QiwwREFBMEQ7cUJBQ3pEZ1gsS0FBSyxDQUFDcEosQ0FBQUEsTUFBTy9CLEdBQUcrQjtnQkFDbkI7Z0JBQ0EsNkRBQTZEO2dCQUM3RCxhQUFhO2dCQUNiLE9BQU9nSixlQUFlSyxLQUFLLENBQUMsSUFBSSxFQUFFO29CQUFDelI7b0JBQVNxRztpQkFBRztZQUMvQyw4REFBOEQ7WUFDaEU7UUFDRjtRQUVBLG9GQUFvRjtRQUNwRjZLLHNDQUFzQztRQUN0Q0Esc0NBQXNDO1FBQ3RDQSxzQ0FBc0M7UUFDdEMsTUFBTVEsd0JBQXdCLElBQUlDLE1BQU1YLGdCQUFnQjtZQUN0RCxrRUFBa0U7WUFDbEUsZ0NBQWdDO1lBQ2hDWSxnQkFBZ0IsSUFBTTtRQUN4QjtRQUNBLE1BQU1DLCtCQUErQixJQUFJRixNQUFNOUcsdUJBQXVCO1lBQ3BFLGtFQUFrRTtZQUNsRSxnQ0FBZ0M7WUFDaEMrRyxnQkFBZ0IsSUFBTTtRQUN4QjtRQUNBLElBQUksQ0FBQ2xGLFFBQVEsR0FBR2dGO1FBQ2hCLElBQUksQ0FBQzdHLHFCQUFxQixHQUFHZ0g7UUFDN0IsTUFBTTNRLFFBQVE0USxHQUFHLENBQUM7WUFBQ2QsZUFBZWpSLGdCQUFnQjtZQUFJOEssc0JBQXNCOUssZ0JBQWdCLENBQUNoTSwyRUFBYUEsQ0FBQ0EsMkVBQWFBLENBQUMsQ0FBQyxHQUFHNmMsaUJBQWlCLENBQUMsR0FBRztnQkFDaEpsTixnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO2dCQUNuQ3FCLHFCQUFxQixJQUFJLENBQUNBLG1CQUFtQjtnQkFDN0NDLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQy9CO1NBQUk7UUFDSjVLLElBQUlxTSxLQUFLLENBQUM7SUFDWjtBQUNGO0FBRXFIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29senp0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvc29sYW5hLWVtYmVkL2Rpc3Qvc29sYW5hRW1iZWQuZXNtLmpzPzAwOGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSwgQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMsIENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUywgUFJPVklERVJfSlJQQ19NRVRIT0RTLCBQUk9WSURFUl9OT1RJRklDQVRJT05TIH0gZnJvbSAnQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzJztcbmltcG9ydCB7IHNldEFQSUtleSB9IGZyb20gJ0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzJztcbmltcG9ydCB7IFNhZmVFdmVudEVtaXR0ZXIsIE9iamVjdE11bHRpcGxleCwgY3JlYXRlU3RyZWFtTWlkZGxld2FyZSwgSlJQQ0VuZ2luZSwgY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUsIGdldFJwY1Byb21pc2VDYWxsYmFjaywgQmFzZVBvc3RNZXNzYWdlU3RyZWFtIH0gZnJvbSAnQHRvcnVzbGFicy9vcGVubG9naW4tanJwYyc7XG5pbXBvcnQgeyBldGhFcnJvcnMsIEV0aGVyZXVtUnBjRXJyb3IgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgcHVtcCBmcm9tICdwdW1wJztcbmltcG9ydCBsb2dsZXZlbCBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgZGVxdWFsIGZyb20gJ2Zhc3QtZGVlcC1lcXVhbCc7XG5cbnZhciB2ZXJzaW9uID0gXCIyLjEuMFwiO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5mdW5jdGlvbiBpc1N0cmVhbShzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbSAhPT0gbnVsbCAmJiB0eXBlb2Ygc3RyZWFtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzdHJlYW0ucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNXcml0YWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgcmV0dXJuIGlzU3RyZWFtKHN0cmVhbSkgJiYgc3RyZWFtLndyaXRhYmxlICE9PSBmYWxzZSAmJiB0eXBlb2Ygc3RyZWFtLl93cml0ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICByZXR1cm4gaXNTdHJlYW0oc3RyZWFtKSAmJiBzdHJlYW0ucmVhZGFibGUgIT09IGZhbHNlICYmIHR5cGVvZiBzdHJlYW0uX3JlYWQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc3RyZWFtLl9yZWFkYWJsZVN0YXRlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gaXNEdXBsZXhTdHJlYW0oc3RyZWFtKSB7XG4gIHJldHVybiBpc1dyaXRhYmxlU3RyZWFtKHN0cmVhbSkgJiYgaXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xufVxuXG52YXIgbWVzc2FnZXMgPSB7XG4gIGVycm9yczoge1xuICAgIGRpc2Nvbm5lY3RlZDogKCkgPT4gXCJUb3J1czogTG9zdCBjb25uZWN0aW9uIHRvIFRvcnVzLlwiLFxuICAgIHBlcm1hbmVudGx5RGlzY29ubmVjdGVkOiAoKSA9PiBcIlRvcnVzOiBEaXNjb25uZWN0ZWQgZnJvbSBpZnJhbWUuIFBhZ2UgcmVsb2FkIHJlcXVpcmVkLlwiLFxuICAgIHVuc3VwcG9ydGVkU3luYzogbWV0aG9kID0+IGBUb3J1czogVGhlIFRvcnVzIEV0aGVyZXVtIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgc3luY2hyb25vdXMgbWV0aG9kcyBsaWtlICR7bWV0aG9kfSB3aXRob3V0IGEgY2FsbGJhY2sgcGFyYW1ldGVyLmAsXG4gICAgaW52YWxpZER1cGxleFN0cmVhbTogKCkgPT4gXCJNdXN0IHByb3ZpZGUgYSBOb2RlLmpzLXN0eWxlIGR1cGxleCBzdHJlYW0uXCIsXG4gICAgaW52YWxpZE9wdGlvbnM6IG1heEV2ZW50TGlzdGVuZXJzID0+IGBJbnZhbGlkIG9wdGlvbnMuIFJlY2VpdmVkOiB7IG1heEV2ZW50TGlzdGVuZXJzOiAke21heEV2ZW50TGlzdGVuZXJzfX1gLFxuICAgIGludmFsaWRSZXF1ZXN0QXJnczogKCkgPT4gYEV4cGVjdGVkIGEgc2luZ2xlLCBub24tYXJyYXksIG9iamVjdCBhcmd1bWVudC5gLFxuICAgIGludmFsaWRSZXF1ZXN0TWV0aG9kOiAoKSA9PiBgJ2FyZ3MubWV0aG9kJyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5gLFxuICAgIGludmFsaWRSZXF1ZXN0UGFyYW1zOiAoKSA9PiBgJ2FyZ3MucGFyYW1zJyBtdXN0IGJlIGFuIG9iamVjdCBvciBhcnJheSBpZiBwcm92aWRlZC5gLFxuICAgIGludmFsaWRMb2dnZXJPYmplY3Q6ICgpID0+IGAnYXJncy5sb2dnZXInIG11c3QgYmUgYW4gb2JqZWN0IGlmIHByb3ZpZGVkLmAsXG4gICAgaW52YWxpZExvZ2dlck1ldGhvZDogbWV0aG9kID0+IGAnYXJncy5sb2dnZXInIG11c3QgaW5jbHVkZSByZXF1aXJlZCBtZXRob2QgJyR7bWV0aG9kfScuYFxuICB9LFxuICBpbmZvOiB7XG4gICAgY29ubmVjdGVkOiBjaGFpbklkID0+IGBUb3J1czogQ29ubmVjdGVkIHRvIGNoYWluIHdpdGggSUQgXCIke2NoYWluSWR9XCIuYFxuICB9LFxuICB3YXJuaW5nczoge31cbn07XG5cbmNvbnN0IFBBWU1FTlRfUFJPVklERVIgPSB7XG4gIE1PT05QQVk6IFwibW9vbnBheVwiLFxuICBXWVJFOiBcInd5cmVcIixcbiAgUkFNUE5FVFdPUks6IFwicmFtcG5ldHdvcmtcIixcbiAgWEFOUE9PTDogXCJ4YW5wb29sXCIsXG4gIE1FUkNVUllPOiBcIm1lcmN1cnlvXCIsXG4gIFRSQU5TQUs6IFwidHJhbnNha1wiXG59O1xuY29uc3QgVE9SVVNfQlVJTERfRU5WID0ge1xuICBQUk9EVUNUSU9OOiBcInByb2R1Y3Rpb25cIixcbiAgREVWRUxPUE1FTlQ6IFwiZGV2ZWxvcG1lbnRcIixcbiAgVEVTVElORzogXCJ0ZXN0aW5nXCJcbn07XG5jb25zdCBCVVRUT05fUE9TSVRJT04gPSB7XG4gIEJPVFRPTV9MRUZUOiBcImJvdHRvbS1sZWZ0XCIsXG4gIFRPUF9MRUZUOiBcInRvcC1sZWZ0XCIsXG4gIEJPVFRPTV9SSUdIVDogXCJib3R0b20tcmlnaHRcIixcbiAgVE9QX1JJR0hUOiBcInRvcC1yaWdodFwiXG59O1xuY29uc3QgTE9HSU5fUFJPVklERVIgPSB7XG4gIEdPT0dMRTogXCJnb29nbGVcIixcbiAgRkFDRUJPT0s6IFwiZmFjZWJvb2tcIixcbiAgUkVERElUOiBcInJlZGRpdFwiLFxuICBESVNDT1JEOiBcImRpc2NvcmRcIixcbiAgVFdJVENIOiBcInR3aXRjaFwiLFxuICBBUFBMRTogXCJhcHBsZVwiLFxuICBMSU5FOiBcImxpbmVcIixcbiAgR0lUSFVCOiBcImdpdGh1YlwiLFxuICBLQUtBTzogXCJrYWthb1wiLFxuICBMSU5LRURJTjogXCJsaW5rZWRpblwiLFxuICBUV0lUVEVSOiBcInR3aXR0ZXJcIixcbiAgV0VJQk86IFwid2VpYm9cIixcbiAgV0VDSEFUOiBcIndlY2hhdFwiLFxuICBFTUFJTF9QQVNTV09SRExFU1M6IFwiZW1haWxfcGFzc3dvcmRsZXNzXCJcbn07XG5cbmNvbnN0IHRyYW5zbGF0aW9ucyA9IHtcbiAgZW46IHtcbiAgICBlbWJlZDoge1xuICAgICAgY29udGludWU6IFwiQ29udGludWVcIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIkF1dGhvcml6YXRpb24gcmVxdWlyZWRcIixcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwiQ2xpY2sgY29udGludWUgdG8gcHJvY2VlZCB3aXRoIHlvdXIgcmVxdWVzdCBpbiBhIHBvcHVwXCIsXG4gICAgICBjb29raWVzUmVxdWlyZWQ6IFwiQ29va2llcyBSZXF1aXJlZFwiLFxuICAgICAgZW5hYmxlQ29va2llczogXCJQbGVhc2UgZW5hYmxlIGNvb2tpZXMgaW4geW91ciBicm93c2VyIHByZWZlcmVuY2VzIHRvIGFjY2VzcyBUb3J1c1wiLFxuICAgICAgY2xpY2tIZXJlOiBcIk1vcmUgSW5mb1wiXG4gICAgfVxuICB9LFxuICBkZToge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCJGb3J0c2V0emVuXCIsXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCJBdXRvcmlzaWVydW5nIGVyZm9yZGVybGljaFwiLFxuICAgICAgcGVuZGluZ0FjdGlvbjogXCJLbGlja2VuIFNpZSBpbiBlaW5lbSBQb3B1cCBhdWYgV2VpdGVyLCB1bSBtaXQgSWhyZXIgQW5mcmFnZSBmb3J0enVmYWhyZW5cIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCJDb29raWVzIGJlbsO2dGlndFwiLFxuICAgICAgZW5hYmxlQ29va2llczogXCJCaXR0ZSBha3RpdmllcmVuIFNpZSBDb29raWVzIGluIElocmVuIEJyb3dzZXJlaW5zdGVsbHVuZ2VuLCB1bSBhdWYgVG9ydXMgenV6dWdyZWlmZW5cIixcbiAgICAgIGNsaWNrSGVyZTogXCJNZWhyIEluZm9cIlxuICAgIH1cbiAgfSxcbiAgamE6IHtcbiAgICBlbWJlZDoge1xuICAgICAgY29udGludWU6IFwi57aZ57aa44GZ44KLXCIsXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCLoqo3oqLzjgYzlv4XopoHjgafjgZlcIixcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwi57aa6KGM44KS44Kv44Oq44OD44Kv44GX44Gm44CB44Od44OD44OX44Ki44OD44OX44Gn44Oq44Kv44Ko44K544OI44KS57aa6KGM44GX44G+44GZXCIsXG4gICAgICBjb29raWVzUmVxdWlyZWQ6IFwi5b+F6KaB44Gq44Kv44OD44Kt44O8XCIsXG4gICAgICBlbmFibGVDb29raWVzOiBcIlRvcnVz44Gr44Ki44Kv44K744K544GZ44KL44Gr44Gv44CB44OW44Op44Km44K244Gu6Kit5a6a44GnQ29va2ll44KS5pyJ5Yq544Gr44GX44Gm44GP44Gg44GV44GE44CCXCIsXG4gICAgICBjbGlja0hlcmU6IFwi6Kmz44GX44GP44GvXCJcbiAgICB9XG4gIH0sXG4gIGtvOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIuqzhOyGje2VmOuLpFwiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwi7Iq57J24IO2VhOyalFwiLFxuICAgICAgcGVuZGluZ0FjdGlvbjogXCLtjJ3sl4Xsl5DshJwg7JqU7LKt7J2EIOynhO2Wie2VmOugpOuptCDqs4Tsho3snYQg7YG066at7ZWY7Iut7Iuc7JikLlwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIuy/oO2CpCDtlYTsmpRcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwi67iM65287Jqw7KCAIO2ZmOqyvSDshKTsoJXsl5DshJwg7L+g7YKk66W8IO2ZnOyEse2ZlO2VmOyXrCBUb3J1c+yXkCDslaHshLjsiqTtlZjsi63si5zsmKQuXCIsXG4gICAgICBjbGlja0hlcmU6IFwi642UIOunjuydgCDsoJXrs7RcIlxuICAgIH1cbiAgfSxcbiAgemg6IHtcbiAgICBlbWJlZDoge1xuICAgICAgY29udGludWU6IFwi57un57utXCIsXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCLpnIDopoHmjojmnYNcIixcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwi5Y2V5Ye757un57ut5Lul5Zyo5by55Ye656qX5Y+j5Lit57un57ut5oKo55qE6K+35rGCXCIsXG4gICAgICBjb29raWVzUmVxdWlyZWQ6IFwi5b+F5aGrQ29va2llXCIsXG4gICAgICBlbmFibGVDb29raWVzOiBcIuivt+WcqOaCqOeahOa1j+iniOWZqOmmlumAiemhueS4reWQr+eUqGNvb2tpZeS7peiuv+mXrlRvcnVz44CCXCIsXG4gICAgICBjbGlja0hlcmU6IFwi5pu05aSa5L+h5oGvXCJcbiAgICB9XG4gIH1cbn07XG52YXIgY29uZmlndXJhdGlvbiA9IHtcbiAgc3VwcG9ydGVkVmVyaWZpZXJMaXN0OiBbTE9HSU5fUFJPVklERVIuR09PR0xFLCBMT0dJTl9QUk9WSURFUi5SRURESVQsIExPR0lOX1BST1ZJREVSLkRJU0NPUkRdLFxuICBhcGk6IFwiaHR0cHM6Ly9hcGkudG9yLnVzXCIsXG4gIHRyYW5zbGF0aW9ucyxcbiAgcHJvZFRvcnVzVXJsOiBcIlwiLFxuICBsb2NhbFN0b3JhZ2VLZXlQcmVmaXg6IGB0b3J1cy1gXG59O1xuXG52YXIgbG9nID0gbG9nbGV2ZWwuZ2V0TG9nZ2VyKFwic29sYW5hLWVtYmVkXCIpO1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vKipcbiAqIGpzb24tcnBjLWVuZ2luZSBtaWRkbGV3YXJlIHRoYXQgbG9ncyBSUEMgZXJyb3JzIGFuZCBhbmQgdmFsaWRhdGVzIHJlcS5tZXRob2QuXG4gKlxuICogQHBhcmFtIGxvZyAtIFRoZSBsb2dnaW5nIEFQSSB0byB1c2UuXG4gKiBAcmV0dXJucyAganNvbi1ycGMtZW5naW5lIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JNaWRkbGV3YXJlKCkge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgLy8ganNvbi1ycGMtZW5naW5lIHdpbGwgdGVybWluYXRlIHRoZSByZXF1ZXN0IHdoZW4gaXQgbm90aWNlcyB0aGlzIGVycm9yXG4gICAgaWYgKHR5cGVvZiByZXEubWV0aG9kICE9PSBcInN0cmluZ1wiIHx8ICFyZXEubWV0aG9kKSB7XG4gICAgICByZXMuZXJyb3IgPSBldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZTogYFRoZSByZXF1ZXN0ICdtZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLmAsXG4gICAgICAgIGRhdGE6IHJlcVxuICAgICAgfSk7XG4gICAgfVxuICAgIG5leHQoZG9uZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVycm9yXG4gICAgICB9ID0gcmVzO1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgICAgbG9nLmVycm9yKGBUb3J1cyAtIFJQQyBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogTG9ncyBhIHN0cmVhbSBkaXNjb25uZWN0aW9uIGVycm9yLiBFbWl0cyBhbiAnZXJyb3InIGlmIGdpdmVuIGFuXG4gKiBFdmVudEVtaXR0ZXIgdGhhdCBoYXMgbGlzdGVuZXJzIGZvciB0aGUgJ2Vycm9yJyBldmVudC5cbiAqXG4gKiBAcGFyYW0gbG9nIC0gVGhlIGxvZ2dpbmcgQVBJIHRvIHVzZS5cbiAqIEBwYXJhbSByZW1vdGVMYWJlbCAtIFRoZSBsYWJlbCBvZiB0aGUgZGlzY29ubmVjdGVkIHN0cmVhbS5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBhc3NvY2lhdGVkIGVycm9yIHRvIGxvZy5cbiAqIEBwYXJhbSBlbWl0dGVyIC0gVGhlIGxvZ2dpbmcgQVBJIHRvIHVzZS5cbiAqL1xuZnVuY3Rpb24gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcocmVtb3RlTGFiZWwsIGVycm9yLCBlbWl0dGVyKSB7XG4gIGxldCB3YXJuaW5nTXNnID0gYFRvcnVzOiBMb3N0IGNvbm5lY3Rpb24gdG8gXCIke3JlbW90ZUxhYmVsfVwiLmA7XG4gIGlmIChlcnJvcj8uc3RhY2spIHtcbiAgICB3YXJuaW5nTXNnICs9IGBcXG4ke2Vycm9yLnN0YWNrfWA7XG4gIH1cbiAgbG9nLndhcm4od2FybmluZ01zZyk7XG4gIGlmIChlbWl0dGVyICYmIGVtaXR0ZXIubGlzdGVuZXJDb3VudChcImVycm9yXCIpID4gMCkge1xuICAgIGVtaXR0ZXIuZW1pdChcImVycm9yXCIsIHdhcm5pbmdNc2cpO1xuICB9XG59XG5jb25zdCBnZXRXaW5kb3dJZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuY29uc3QgZ2V0VG9ydXNVcmwgPSBhc3luYyBidWlsZEVudiA9PiB7XG4gIGxldCB0b3J1c1VybDtcbiAgbGV0IGxvZ0xldmVsO1xuICAvLyBjb25zdCB2ZXJzaW9uVXNlZCA9IHZlcnNpb247XG4gIC8vIGxvZy5pbmZvKFwic29sYW5hIGVtYmVkIHZlcnNpb24gdXNlZDogXCIsIHZlcnNpb25Vc2VkKTtcbiAgc3dpdGNoIChidWlsZEVudikge1xuICAgIGNhc2UgXCJ0ZXN0aW5nXCI6XG4gICAgICB0b3J1c1VybCA9IFwiaHR0cHM6Ly9zb2xhbmEtdGVzdGluZy50b3IudXNcIjtcbiAgICAgIGxvZ0xldmVsID0gXCJkZWJ1Z1wiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRldmVsb3BtZW50XCI6XG4gICAgICB0b3J1c1VybCA9IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgwXCI7XG4gICAgICBsb2dMZXZlbCA9IFwiZGVidWdcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0b3J1c1VybCA9IGBodHRwczovL3NvbGFuYS50b3IudXNgO1xuICAgICAgbG9nTGV2ZWwgPSBcImVycm9yXCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcnVzVXJsLFxuICAgIGxvZ0xldmVsXG4gIH07XG59O1xuY29uc3QgZ2V0VXNlckxhbmd1YWdlID0gKCkgPT4ge1xuICBsZXQgdXNlckxhbmd1YWdlID0gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSB8fCBcImVuLVVTXCI7XG4gIGNvbnN0IHVzZXJMYW5ndWFnZXMgPSB1c2VyTGFuZ3VhZ2Uuc3BsaXQoXCItXCIpO1xuICB1c2VyTGFuZ3VhZ2UgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlndXJhdGlvbi50cmFuc2xhdGlvbnMsIHVzZXJMYW5ndWFnZXNbMF0pID8gdXNlckxhbmd1YWdlc1swXSA6IFwiZW5cIjtcbiAgcmV0dXJuIHVzZXJMYW5ndWFnZTtcbn07XG5jb25zdCBGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XID0ge1xuICBoZWlnaHQ6IDY2MCxcbiAgd2lkdGg6IDM3NVxufTtcbmNvbnN0IEZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA3NDAsXG4gIHdpZHRoOiAxMzE1XG59O1xuY29uc3QgRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1cgPSB7XG4gIGhlaWdodDogNzAwLFxuICB3aWR0aDogMTIwMFxufTtcbmNvbnN0IEZFQVRVUkVTX0NPTkZJUk1fV0lORE9XID0ge1xuICBoZWlnaHQ6IDYwMCxcbiAgd2lkdGg6IDQwMFxufTtcbmZ1bmN0aW9uIHN0b3JhZ2VBdmFpbGFibGUodHlwZSkge1xuICBsZXQgc3RvcmFnZTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gd2luZG93W3R5cGVdO1xuICAgIGNvbnN0IHggPSBcIl9fc3RvcmFnZV90ZXN0X19cIjtcbiAgICBzdG9yYWdlLnNldEl0ZW0oeCwgeCk7XG4gICAgc3RvcmFnZS5yZW1vdmVJdGVtKHgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGUgPSBlcnJvcjtcbiAgICByZXR1cm4gZSAmJiAoXG4gICAgLy8gZXZlcnl0aGluZyBleGNlcHQgRmlyZWZveFxuICAgIGUuY29kZSA9PT0gMjIgfHxcbiAgICAvLyBGaXJlZm94XG4gICAgZS5jb2RlID09PSAxMDE0IHx8XG4gICAgLy8gdGVzdCBuYW1lIGZpZWxkIHRvbywgYmVjYXVzZSBjb2RlIG1pZ2h0IG5vdCBiZSBwcmVzZW50XG4gICAgLy8gZXZlcnl0aGluZyBleGNlcHQgRmlyZWZveFxuICAgIGUubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8fFxuICAgIC8vIEZpcmVmb3hcbiAgICBlLm5hbWUgPT09IFwiTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRURcIikgJiZcbiAgICAvLyBhY2tub3dsZWRnZSBRdW90YUV4Y2VlZGVkRXJyb3Igb25seSBpZiB0aGVyZSdzIHNvbWV0aGluZyBhbHJlYWR5IHN0b3JlZFxuICAgIHN0b3JhZ2UgJiYgc3RvcmFnZS5sZW5ndGggIT09IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBwb3B1cCBoYW5kbGVyIHV0aWxzXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHVwRmVhdHVyZXMoX3JlZikge1xuICBsZXQge1xuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaFxuICB9ID0gX3JlZjtcbiAgLy8gRml4ZXMgZHVhbC1zY3JlZW4gcG9zaXRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vc3QgYnJvd3NlcnMgICAgICBGaXJlZm94XG4gIGNvbnN0IGR1YWxTY3JlZW5MZWZ0ID0gd2luZG93LnNjcmVlbkxlZnQgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogd2luZG93LnNjcmVlblg7XG4gIGNvbnN0IGR1YWxTY3JlZW5Ub3AgPSB3aW5kb3cuc2NyZWVuVG9wICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuVG9wIDogd2luZG93LnNjcmVlblk7XG4gIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPyB3aW5kb3cuaW5uZXJXaWR0aCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA6IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IDogd2luZG93LnNjcmVlbi5oZWlnaHQ7XG4gIGNvbnN0IHN5c3RlbVpvb20gPSAxOyAvLyBObyByZWxpYWJsZSBlc3RpbWF0ZVxuXG4gIGNvbnN0IGxlZnQgPSBNYXRoLmFicygod2lkdGggLSB3KSAvIDIgLyBzeXN0ZW1ab29tICsgZHVhbFNjcmVlbkxlZnQpO1xuICBjb25zdCB0b3AgPSBNYXRoLmFicygoaGVpZ2h0IC0gaCkgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5Ub3ApO1xuICBjb25zdCBmZWF0dXJlcyA9IGB0aXRsZWJhcj0wLHRvb2xiYXI9MCxzdGF0dXM9MCxsb2NhdGlvbj0wLG1lbnViYXI9MCxoZWlnaHQ9JHtoIC8gc3lzdGVtWm9vbX0sd2lkdGg9JHt3IC8gc3lzdGVtWm9vbX0sdG9wPSR7dG9wfSxsZWZ0PSR7bGVmdH1gO1xuICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmNsYXNzIEJhc2VQcm92aWRlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RyZWFtLCBfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzID0gMTAwLFxuICAgICAganNvblJwY1N0cmVhbU5hbWUgPSBcInByb3ZpZGVyXCJcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRpbmcgdGhhdCB0aGlzIHByb3ZpZGVyIGlzIGEgVG9ydXMgcHJvdmlkZXIuXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUb3J1c1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ycGNFbmdpbmVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJqc29uUnBjQ29ubmVjdGlvbkV2ZW50c1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdGF0ZVwiLCB2b2lkIDApO1xuICAgIGlmICghaXNEdXBsZXhTdHJlYW0oY29ubmVjdGlvblN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5lcnJvcnMuaW52YWxpZER1cGxleFN0cmVhbSgpKTtcbiAgICB9XG4gICAgdGhpcy5pc1RvcnVzID0gdHJ1ZTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycyhtYXhFdmVudExpc3RlbmVycyk7XG4gICAgdGhpcy5faGFuZGxlQ29ubmVjdCA9IHRoaXMuX2hhbmRsZUNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0ID0gdGhpcy5faGFuZGxlRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QgPSB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IHRoaXMuX3JwY1JlcXVlc3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9pbml0aWFsaXplU3RhdGUgPSB0aGlzLl9pbml0aWFsaXplU3RhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNlbmRBc3luYyA9IHRoaXMuc2VuZEFzeW5jLmJpbmQodGhpcyk7XG4gICAgLy8gdGhpcy5lbmFibGUgPSB0aGlzLmVuYWJsZS5iaW5kKHRoaXMpO1xuXG4gICAgLy8gc2V0dXAgY29ubmVjdGlvblN0cmVhbSBtdWx0aXBsZXhpbmdcbiAgICBjb25zdCBtdXggPSBuZXcgT2JqZWN0TXVsdGlwbGV4KCk7XG4gICAgcHVtcChjb25uZWN0aW9uU3RyZWFtLCBtdXgsIGNvbm5lY3Rpb25TdHJlYW0sIHRoaXMuX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QuYmluZCh0aGlzLCBcIlRvcnVzXCIpKTtcblxuICAgIC8vIGlnbm9yZSBwaGlzaGluZyB3YXJuaW5nIG1lc3NhZ2UgKGhhbmRsZWQgZWxzZXdoZXJlKVxuICAgIG11eC5pZ25vcmVTdHJlYW0oXCJwaGlzaGluZ1wiKTtcblxuICAgIC8vIHNldHVwIG93biBldmVudCBsaXN0ZW5lcnNcbiAgICAvLyBjb25uZWN0IHRvIGFzeW5jIHByb3ZpZGVyXG5cbiAgICBjb25zdCBqc29uUnBjQ29ubmVjdGlvbiA9IGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUoKTtcbiAgICBwdW1wKGpzb25ScGNDb25uZWN0aW9uLnN0cmVhbSwgbXV4LmNyZWF0ZVN0cmVhbShqc29uUnBjU3RyZWFtTmFtZSksIGpzb25ScGNDb25uZWN0aW9uLnN0cmVhbSwgdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdC5iaW5kKHRoaXMsIFwiVG9ydXMgUnBjUHJvdmlkZXJcIikpO1xuXG4gICAgLy8gaGFuZGxlIFJQQyByZXF1ZXN0cyB2aWEgZGFwcC1zaWRlIHJwYyBlbmdpbmVcbiAgICBjb25zdCBycGNFbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xuICAgIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkpO1xuICAgIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUVycm9yTWlkZGxld2FyZSgpKTtcbiAgICBycGNFbmdpbmUucHVzaChjcmVhdGVMb2dnZXJNaWRkbGV3YXJlKHtcbiAgICAgIG9yaWdpbjogbG9jYXRpb24ub3JpZ2luXG4gICAgfSkpO1xuICAgIHJwY0VuZ2luZS5wdXNoKGpzb25ScGNDb25uZWN0aW9uLm1pZGRsZXdhcmUpO1xuICAgIHRoaXMuX3JwY0VuZ2luZSA9IHJwY0VuZ2luZTtcbiAgICB0aGlzLmpzb25ScGNDb25uZWN0aW9uRXZlbnRzID0ganNvblJwY0Nvbm5lY3Rpb24uZXZlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdHMgYW4gUlBDIHJlcXVlc3QgZm9yIHRoZSBnaXZlbiBtZXRob2QsIHdpdGggdGhlIGdpdmVuIHBhcmFtcy5cbiAgICogUmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBtZXRob2QgY2FsbCwgb3IgcmVqZWN0cyBvbiBlcnJvci5cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICAgIGlmICghYXJncyB8fCB0eXBlb2YgYXJncyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZXMuZXJyb3JzLmludmFsaWRSZXF1ZXN0QXJncygpLFxuICAgICAgICBkYXRhOiBhcmdzXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbWV0aG9kLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwic3RyaW5nXCIgfHwgbWV0aG9kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkUmVxdWVzdE1ldGhvZCgpLFxuICAgICAgICBkYXRhOiBhcmdzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KHBhcmFtcykgJiYgKHR5cGVvZiBwYXJhbXMgIT09IFwib2JqZWN0XCIgfHwgcGFyYW1zID09PSBudWxsKSkge1xuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkUmVxdWVzdFBhcmFtcygpLFxuICAgICAgICBkYXRhOiBhcmdzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3JwY1JlcXVlc3Qoe1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJtaXRzIGFuIFJQQyByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICBzZW5kKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcnBjUmVxdWVzdChwYXlsb2FkLCBjYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFN1Ym1pdHMgYW4gUlBDIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBKU09OLVJQQyByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHNlbmRBc3luYyhwYXlsb2FkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3JwY1JlcXVlc3QocGF5bG9hZCwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgbG9zdCB0byBjcml0aWNhbCBzdHJlYW1zLlxuICAgKlxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Rpc2Nvbm5lY3RcbiAgICovXG4gIF9oYW5kbGVTdHJlYW1EaXNjb25uZWN0KHN0cmVhbU5hbWUsIGVycm9yKSB7XG4gICAgbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoc3RyZWFtTmFtZSwgZXJyb3IsIHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZURpc2Nvbm5lY3QoZmFsc2UsIGVycm9yID8gZXJyb3IubWVzc2FnZSA6IHVuZGVmaW5lZCk7XG4gIH1cblxuICAvLyBQcml2YXRlIE1ldGhvZHNcbiAgLy89ID09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGhlbHBlci5cbiAgICogUG9wdWxhdGVzIGluaXRpYWwgc3RhdGUgYnkgY2FsbGluZyAnd2FsbGV0X2dldFByb3ZpZGVyU3RhdGUnIGFuZCBlbWl0c1xuICAgKiBuZWNlc3NhcnkgZXZlbnRzLlxuICAgKi9cblxuICAvKipcbiAgICogSW50ZXJuYWwgUlBDIG1ldGhvZC4gRm9yd2FyZHMgcmVxdWVzdHMgdG8gYmFja2dyb3VuZCB2aWEgdGhlIFJQQyBlbmdpbmUuXG4gICAqIEFsc28gcmVtYXAgaWRzIGluYm91bmQgYW5kIG91dGJvdW5kXG4gICAqL1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGNvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBJRCBvZiB0aGUgbmV3bHkgY29ubmVjdGVkIGNoYWluLlxuICAgKiBlbWl0cyBUb3J1c0luUGFnZVByb3ZpZGVyI2Nvbm5lY3RcbiAgICovXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgZGlzY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQgd2l0aCByZXNwZWN0IHRvIHRoZSBpc1JlY292ZXJhYmxlIHBhcmFtZXRlci5cbiAgICpcbiAgICogRXJyb3IgY29kZXMgcGVyIHRoZSBDbG9zZUV2ZW50IHN0YXR1cyBjb2RlcyBhcyByZXF1aXJlZCBieSBFSVAtMTE5MzpcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXG4gICAqXG4gICAqIEBwYXJhbSBpc1JlY292ZXJhYmxlIC0gV2hldGhlciB0aGUgZGlzY29ubmVjdGlvbiBpcyByZWNvdmVyYWJsZS5cbiAgICogQHBhcmFtIGVycm9yTWVzc2FnZSAtIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjZGlzY29ubmVjdFxuICAgKi9cbn1cblxuY29uc3QgaHRtbFRvRWxlbWVudCA9IGh0bWwgPT4ge1xuICBjb25zdCB0ZW1wbGF0ZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gIGNvbnN0IHRyaW1tZWRIdG1sID0gaHRtbC50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdHJpbW1lZEh0bWw7XG4gIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG59O1xuZnVuY3Rpb24gaXNMZWdhY3lUcmFuc2FjdGlvbkluc3RhbmNlKHRyYW5zYWN0aW9uKSB7XG4gIHJldHVybiB0cmFuc2FjdGlvbi52ZXJzaW9uID09PSB1bmRlZmluZWQ7XG59XG5cbmNsYXNzIFBvcHVwSGFuZGxlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIHVybCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgdGltZW91dCA9IDMwMDAwXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cmxcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YXJnZXRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZWF0dXJlc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpbmRvd1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpbmRvd1RpbWVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaUNsb3NlZFdpbmRvd1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpbWVvdXRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCBcIl9ibGFua1wiO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcyB8fCBnZXRQb3B1cEZlYXR1cmVzKEZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XKTtcbiAgICB0aGlzLndpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpbmRvd1RpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IGZhbHNlO1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgdGhpcy5fc2V0dXBUaW1lcigpO1xuICB9XG4gIF9zZXR1cFRpbWVyKCkge1xuICAgIHRoaXMud2luZG93VGltZXIgPSBOdW1iZXIoc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud2luZG93ICYmIHRoaXMud2luZG93LmNsb3NlZCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMud2luZG93VGltZXIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuaUNsb3NlZFdpbmRvdykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMud2luZG93ID0gdW5kZWZpbmVkO1xuICAgICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMud2luZG93ID09PSB1bmRlZmluZWQpIGNsZWFySW50ZXJ2YWwodGhpcy53aW5kb3dUaW1lcik7XG4gICAgfSwgNTAwKSk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdy5vcGVuKHRoaXMudXJsLmhyZWYsIHRoaXMudGFyZ2V0LCB0aGlzLmZlYXR1cmVzKTtcbiAgICBpZiAodGhpcy53aW5kb3c/LmZvY3VzKSB0aGlzLndpbmRvdy5mb2N1cygpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmlDbG9zZWRXaW5kb3cgPSB0cnVlO1xuICAgIGlmICh0aGlzLndpbmRvdykgdGhpcy53aW5kb3cuY2xvc2UoKTtcbiAgfVxuICByZWRpcmVjdChsb2NhdGlvblJlcGxhY2VPblJlZGlyZWN0KSB7XG4gICAgaWYgKGxvY2F0aW9uUmVwbGFjZU9uUmVkaXJlY3QpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMudXJsLmhyZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRoaXMudXJsLmhyZWY7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFRvcnVzQ29tbXVuaWNhdGlvblByb3ZpZGVyIGV4dGVuZHMgQmFzZVByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvblN0cmVhbSwgX3JlZikge1xuICAgIGxldCB7XG4gICAgICBtYXhFdmVudExpc3RlbmVycyA9IDEwMCxcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lID0gXCJwcm92aWRlclwiXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoY29ubmVjdGlvblN0cmVhbSwge1xuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMsXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZVxuICAgIH0pO1xuXG4gICAgLy8gcHJpdmF0ZSBzdGF0ZVxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVtYmVkVHJhbnNsYXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNVcmxcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXBwU3RvcmFnZUtleVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpbmRvd1JlZnNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cnlXaW5kb3dIYW5kbGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c0FsZXJ0Q29udGFpbmVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNJZnJhbWVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl9zdGF0ZSA9IF9vYmplY3RTcHJlYWQoe30sIFRvcnVzQ29tbXVuaWNhdGlvblByb3ZpZGVyLl9kZWZhdWx0U3RhdGUpO1xuXG4gICAgLy8gcHVibGljIHN0YXRlXG4gICAgdGhpcy50b3J1c1VybCA9IFwiXCI7XG4gICAgdGhpcy5kYXBwU3RvcmFnZUtleSA9IFwiXCI7XG4gICAgY29uc3QgbGFuZ3VhZ2VUcmFuc2xhdGlvbnMgPSBjb25maWd1cmF0aW9uLnRyYW5zbGF0aW9uc1tnZXRVc2VyTGFuZ3VhZ2UoKV07XG4gICAgdGhpcy5lbWJlZFRyYW5zbGF0aW9ucyA9IGxhbmd1YWdlVHJhbnNsYXRpb25zLmVtYmVkO1xuICAgIHRoaXMud2luZG93UmVmcyA9IHt9O1xuXG4gICAgLy8gc2V0dXAgb3duIGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgLy8gRUlQLTExOTMgY29ubmVjdFxuICAgIHRoaXMub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb25zdCBub3RpZmljYXRpb25IYW5kbGVyID0gcGF5bG9hZCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGFyYW1zXG4gICAgICB9ID0gcGF5bG9hZDtcbiAgICAgIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUy5JRlJBTUVfU1RBVFVTKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpc0Z1bGxTY3JlZW4sXG4gICAgICAgICAgcmlkXG4gICAgICAgIH0gPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlJZnJhbWUoe1xuICAgICAgICAgIGlzRnVsbDogaXNGdWxsU2NyZWVuLFxuICAgICAgICAgIHJpZDogcmlkXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBtZXRob2Qgd2hlbiB3YWxsZXQgYWRkcyB2ZXJzaW9uaW5nIGFuZCBzdG9wcyBzdXBwb3J0aW5nIHRoaXMgbWV0aG9kXG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJjcmVhdGVfd2luZG93XCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICAgIHVybFxuICAgICAgICB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cEJsb2NrQWxlcnQod2luZG93SWQsIHVybCk7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLkNMT1NFX1dJTkRPVykge1xuICAgICAgICB0aGlzLl9oYW5kbGVDbG9zZVdpbmRvdyhwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUy5VU0VSX0xPR0dFRF9JTikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY3VycmVudExvZ2luUHJvdmlkZXJcbiAgICAgICAgfSA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNMb2dnZWRJbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3N0YXRlLmN1cnJlbnRMb2dpblByb3ZpZGVyID0gY3VycmVudExvZ2luUHJvdmlkZXI7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLlVTRVJfTE9HR0VEX09VVCkge1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc0xvZ2dlZEluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlLmN1cnJlbnRMb2dpblByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5qc29uUnBjQ29ubmVjdGlvbkV2ZW50cy5vbihcIm5vdGlmaWNhdGlvblwiLCBub3RpZmljYXRpb25IYW5kbGVyKTtcbiAgfVxuICBnZXQgaXNMb2dnZWRJbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXNMb2dnZWRJbjtcbiAgfVxuICBnZXQgaXNJRnJhbWVGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pc0lGcmFtZUZ1bGxTY3JlZW47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpblBhZ2UgcHJvdmlkZXIgaXMgY29ubmVjdGVkIHRvIFRvcnVzLlxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkO1xuICB9XG4gIGFzeW5jIF9pbml0aWFsaXplU3RhdGUocGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9ydXNVcmwsXG4gICAgICAgIGRhcHBTdG9yYWdlS2V5LFxuICAgICAgICB0b3J1c0FsZXJ0Q29udGFpbmVyLFxuICAgICAgICB0b3J1c0lmcmFtZVxuICAgICAgfSA9IHBhcmFtcztcbiAgICAgIHRoaXMudG9ydXNVcmwgPSB0b3J1c1VybDtcbiAgICAgIHRoaXMuZGFwcFN0b3JhZ2VLZXkgPSBkYXBwU3RvcmFnZUtleTtcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lciA9IHRvcnVzQWxlcnRDb250YWluZXI7XG4gICAgICB0aGlzLnRvcnVzSWZyYW1lID0gdG9ydXNJZnJhbWU7XG4gICAgICB0aGlzLnRvcnVzSWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgLy8gb25seSBkbyB0aGlzIGlmIGlmcmFtZSBpcyBub3QgZnVsbCBzY3JlZW5cbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0lGcmFtZUZ1bGxTY3JlZW4pIHRoaXMuX2Rpc3BsYXlJZnJhbWUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50TG9naW5Qcm92aWRlcixcbiAgICAgICAgaXNMb2dnZWRJblxuICAgICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuR0VUX1BST1ZJREVSX1NUQVRFLFxuICAgICAgICBwYXJhbXM6IFtdXG4gICAgICB9KTtcblxuICAgICAgLy8gaW5kaWNhdGUgdGhhdCB3ZSd2ZSBjb25uZWN0ZWQsIGZvciBFSVAtMTE5MyBjb21wbGlhbmNlXG4gICAgICB0aGlzLl9oYW5kbGVDb25uZWN0KGN1cnJlbnRMb2dpblByb3ZpZGVyLCBpc0xvZ2dlZEluKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IEZhaWxlZCB0byBnZXQgaW5pdGlhbCBzdGF0ZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsb2cuaW5mbyhcImluaXRpYWxpemVkIGNvbW11bmljYXRpb24gc3RhdGVcIik7XG4gICAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoXCJfaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVXaW5kb3cod2luZG93SWQpIHtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgdGFyZ2V0LFxuICAgICAgZmVhdHVyZXNcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsIHx8IGAke3RoaXMudG9ydXNVcmx9L3JlZGlyZWN0P3dpbmRvd0lkPSR7d2luZG93SWR9YCk7XG4gICAgaWYgKHRoaXMuZGFwcFN0b3JhZ2VLZXkpIHtcbiAgICAgIC8vIElmIG11bHRpcGxlIGluc3RhbmNlcywgaXQgcmV0dXJucyB0aGUgZmlyc3Qgb25lXG4gICAgICBpZiAoZmluYWxVcmwuaGFzaCkgZmluYWxVcmwuaGFzaCArPSBgJmRhcHBTdG9yYWdlS2V5PSR7dGhpcy5kYXBwU3RvcmFnZUtleX1gO2Vsc2UgZmluYWxVcmwuaGFzaCA9IGAjZGFwcFN0b3JhZ2VLZXk9JHt0aGlzLmRhcHBTdG9yYWdlS2V5fWA7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZWRXaW5kb3cgPSBuZXcgUG9wdXBIYW5kbGVyKHtcbiAgICAgIHVybDogZmluYWxVcmwsXG4gICAgICB0YXJnZXQsXG4gICAgICBmZWF0dXJlc1xuICAgIH0pO1xuICAgIGhhbmRsZWRXaW5kb3cub3BlbigpO1xuICAgIGlmICghaGFuZGxlZFdpbmRvdy53aW5kb3cpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwQmxvY2tBbGVydCh3aW5kb3dJZCwgZmluYWxVcmwuaHJlZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFkZCB0byBjb2xsZWN0aW9uIG9ubHkgaWYgd2luZG93IGlzIG9wZW5lZFxuICAgIHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF0gPSBoYW5kbGVkV2luZG93O1xuICAgIC8vIFdlIHRlbGwgdGhlIGlmcmFtZSB0aGF0IHRoZSB3aW5kb3cgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IG9wZW5lZFxuICAgIHRoaXMucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwib3BlbmVkX3dpbmRvd1wiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHdpbmRvd0lkXG4gICAgICB9XG4gICAgfSk7XG4gICAgaGFuZGxlZFdpbmRvdy5vbmNlKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgLy8gdXNlciBjbG9zZWQgdGhlIHdpbmRvd1xuICAgICAgZGVsZXRlIHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF07XG4gICAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkNMT1NFRF9XSU5ET1csXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9kaXNwbGF5SWZyYW1lKCkge1xuICAgIGxldCB7XG4gICAgICBpc0Z1bGwgPSBmYWxzZSxcbiAgICAgIHJpZCA9IFwiXCJcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuICAgIC8vIHNldCBwaGFzZVxuICAgIGlmICghaXNGdWxsKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gdGhpcy5fc3RhdGUudG9ydXNXaWRnZXRWaXNpYmlsaXR5ID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBcIjcwcHhcIjtcbiAgICAgIHN0eWxlLndpZHRoID0gXCI3MHB4XCI7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlLmJ1dHRvblBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgQlVUVE9OX1BPU0lUSU9OLlRPUF9MRUZUOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICBzdHlsZS5ib3R0b20gPSBcImF1dG9cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uVE9QX1JJR0hUOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICBzdHlsZS5ib3R0b20gPSBcImF1dG9cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uQk9UVE9NX1JJR0hUOlxuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uQk9UVE9NX0xFRlQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS50b3AgPSBcImF1dG9cIjtcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgIHN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgIHN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnRvcnVzSWZyYW1lLnN0eWxlLCBzdHlsZSk7XG4gICAgdGhpcy5fc3RhdGUuaXNJRnJhbWVGdWxsU2NyZWVuID0gaXNGdWxsO1xuICAgIHRoaXMucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLklGUkFNRV9TVEFUVVMsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgaXNJRnJhbWVGdWxsU2NyZWVuOiBpc0Z1bGwsXG4gICAgICAgIHJpZFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhpZGVUb3J1c0J1dHRvbigpIHtcbiAgICB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPSBmYWxzZTtcbiAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XG4gIH1cbiAgc2hvd1RvcnVzQnV0dG9uKCkge1xuICAgIHRoaXMuX3N0YXRlLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA9IHRydWU7XG4gICAgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIFJQQyBtZXRob2QuIEZvcndhcmRzIHJlcXVlc3RzIHRvIGJhY2tncm91bmQgdmlhIHRoZSBSUEMgZW5naW5lLlxuICAgKiBBbHNvIHJlbWFwIGlkcyBpbmJvdW5kIGFuZCBvdXRib3VuZFxuICAgKi9cbiAgX3JwY1JlcXVlc3QocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xuICAgIGNvbnN0IF9wYXlsb2FkID0gcGF5bG9hZDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoX3BheWxvYWQpKSB7XG4gICAgICBpZiAoIV9wYXlsb2FkLmpzb25ycGMpIHtcbiAgICAgICAgX3BheWxvYWQuanNvbnJwYyA9IFwiMi4wXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJ5V2luZG93SGFuZGxlKF9wYXlsb2FkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIGN1cnJlbnRMb2dpblByb3ZpZGVyIC0gVGhlIGxvZ2luIFByb3ZpZGVyXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjY29ubmVjdFxuICAgKi9cbiAgX2hhbmRsZUNvbm5lY3QoY3VycmVudExvZ2luUHJvdmlkZXIsIGlzTG9nZ2VkSW4pIHtcbiAgICBpZiAoIXRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcbiAgICAgICAgY3VycmVudExvZ2luUHJvdmlkZXIsXG4gICAgICAgIGlzTG9nZ2VkSW5cbiAgICAgIH0pO1xuICAgICAgbG9nLmRlYnVnKG1lc3NhZ2VzLmluZm8uY29ubmVjdGVkKGN1cnJlbnRMb2dpblByb3ZpZGVyKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgZGlzY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQgd2l0aCByZXNwZWN0IHRvIHRoZSBpc1JlY292ZXJhYmxlIHBhcmFtZXRlci5cbiAgICpcbiAgICogRXJyb3IgY29kZXMgcGVyIHRoZSBDbG9zZUV2ZW50IHN0YXR1cyBjb2RlcyBhcyByZXF1aXJlZCBieSBFSVAtMTE5MzpcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXG4gICAqXG4gICAqIEBwYXJhbSBpc1JlY292ZXJhYmxlIC0gV2hldGhlciB0aGUgZGlzY29ubmVjdGlvbiBpcyByZWNvdmVyYWJsZS5cbiAgICogQHBhcmFtIGVycm9yTWVzc2FnZSAtIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjZGlzY29ubmVjdFxuICAgKi9cbiAgX2hhbmRsZURpc2Nvbm5lY3QoaXNSZWNvdmVyYWJsZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkIHx8ICF0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkICYmICFpc1JlY292ZXJhYmxlKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKGlzUmVjb3ZlcmFibGUpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXRoZXJldW1ScGNFcnJvcigxMDEzLFxuICAgICAgICAvLyBUcnkgYWdhaW4gbGF0ZXJcbiAgICAgICAgZXJyb3JNZXNzYWdlIHx8IG1lc3NhZ2VzLmVycm9ycy5kaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IG5ldyBFdGhlcmV1bVJwY0Vycm9yKDEwMTEsXG4gICAgICAgIC8vIEludGVybmFsIGVycm9yXG4gICAgICAgIGVycm9yTWVzc2FnZSB8fCBtZXNzYWdlcy5lcnJvcnMucGVybWFuZW50bHlEaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuX3N0YXRlLmN1cnJlbnRMb2dpblByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNMb2dnZWRJbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNJRnJhbWVGdWxsU2NyZWVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGlmIHRoZSBpZnJhbWUgd2FudHMgdG8gY2xvc2UgdGhlIHdpbmRvdyBjYXVzZSBpdCBpcyBkb25lIHByb2Nlc3NpbmcgdGhlIHJlcXVlc3RcbiAgX2hhbmRsZUNsb3NlV2luZG93KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpbmRvd0lkXG4gICAgfSA9IHBhcmFtcztcbiAgICBpZiAodGhpcy53aW5kb3dSZWZzW3dpbmRvd0lkXSkge1xuICAgICAgdGhpcy53aW5kb3dSZWZzW3dpbmRvd0lkXS5jbG9zZSgpO1xuICAgICAgZGVsZXRlIHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF07XG4gICAgfVxuICB9XG4gIGFzeW5jIF9jcmVhdGVQb3B1cEJsb2NrQWxlcnQod2luZG93SWQsIHVybCkge1xuICAgIGNvbnN0IGxvZ29VcmwgPSB0aGlzLmdldExvZ29VcmwoKTtcbiAgICBjb25zdCB0b3J1c0FsZXJ0ID0gaHRtbFRvRWxlbWVudCgnPGRpdiBpZD1cInRvcnVzQWxlcnRcIiBjbGFzcz1cInRvcnVzLWFsZXJ0LS12MlwiPicgKyBgPGRpdiBpZD1cInRvcnVzQWxlcnRfX2xvZ29cIj48aW1nIHNyYz1cIiR7bG9nb1VybH1cIiAvPjwvZGl2PmAgKyBcIjxkaXY+XCIgKyBgPGgxIGlkPVwidG9ydXNBbGVydF9fdGl0bGVcIj4ke3RoaXMuZW1iZWRUcmFuc2xhdGlvbnMuYWN0aW9uUmVxdWlyZWR9PC9oMT5gICsgYDxwIGlkPVwidG9ydXNBbGVydF9fZGVzY1wiPiR7dGhpcy5lbWJlZFRyYW5zbGF0aW9ucy5wZW5kaW5nQWN0aW9ufTwvcD5gICsgXCI8L2Rpdj5cIiArIFwiPC9kaXY+XCIpO1xuICAgIGNvbnN0IHN1Y2Nlc3NBbGVydCA9IGh0bWxUb0VsZW1lbnQoYDxkaXY+PGEgaWQ9XCJ0b3J1c0FsZXJ0X19idG5cIj4ke3RoaXMuZW1iZWRUcmFuc2xhdGlvbnMuY29udGludWV9PC9hPjwvZGl2PmApO1xuICAgIGNvbnN0IGJ0bkNvbnRhaW5lciA9IGh0bWxUb0VsZW1lbnQoJzxkaXYgaWQ9XCJ0b3J1c0FsZXJ0X19idG4tY29udGFpbmVyXCI+PC9kaXY+Jyk7XG4gICAgYnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKHN1Y2Nlc3NBbGVydCk7XG4gICAgdG9ydXNBbGVydC5hcHBlbmRDaGlsZChidG5Db250YWluZXIpO1xuICAgIGNvbnN0IGJpbmRPbkxvYWQgPSAoKSA9PiB7XG4gICAgICBzdWNjZXNzQWxlcnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5faGFuZGxlV2luZG93KHdpbmRvd0lkLCB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19DT05GSVJNX1dJTkRPVylcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcnVzQWxlcnQucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLnRvcnVzQWxlcnRDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhdHRhY2hPbkxvYWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIuYXBwZW5kQ2hpbGQodG9ydXNBbGVydCk7XG4gICAgfTtcbiAgICBhdHRhY2hPbkxvYWQoKTtcbiAgICBiaW5kT25Mb2FkKCk7XG4gICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIH1cbiAgZ2V0TG9nb1VybCgpIHtcbiAgICBjb25zdCBsb2dvVXJsID0gYCR7dGhpcy50b3J1c1VybH0vaW1hZ2VzL3RvcnVzX2ljb24tYmx1ZS5zdmdgO1xuICAgIHJldHVybiBsb2dvVXJsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoVG9ydXNDb21tdW5pY2F0aW9uUHJvdmlkZXIsIFwiX2RlZmF1bHRTdGF0ZVwiLCB7XG4gIGJ1dHRvblBvc2l0aW9uOiBcImJvdHRvbS1sZWZ0XCIsXG4gIGN1cnJlbnRMb2dpblByb3ZpZGVyOiBudWxsLFxuICBpc0lGcmFtZUZ1bGxTY3JlZW46IGZhbHNlLFxuICBoYXNFbWl0dGVkQ29ubmVjdGlvbjogZmFsc2UsXG4gIHRvcnVzV2lkZ2V0VmlzaWJpbGl0eTogZmFsc2UsXG4gIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgaXNMb2dnZWRJbjogZmFsc2UsXG4gIGlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQ6IGZhbHNlLFxuICBpc0Nvbm5lY3RlZDogZmFsc2Vcbn0pO1xuXG5jbGFzcyBUb3J1c0luUGFnZVByb3ZpZGVyIGV4dGVuZHMgQmFzZVByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvblN0cmVhbSwgX3JlZikge1xuICAgIGxldCB7XG4gICAgICBtYXhFdmVudExpc3RlbmVycyA9IDEwMCxcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lID0gXCJwcm92aWRlclwiXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoY29ubmVjdGlvblN0cmVhbSwge1xuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMsXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZVxuICAgIH0pO1xuXG4gICAgLy8gcHJpdmF0ZSBzdGF0ZVxuICAgIC8qKlxuICAgICAqIFRoZSBjaGFpbiBJRCBvZiB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBTb2xhbmEgY2hhaW4uXG4gICAgICogU2VlIFtjaGFpbklkLm5ldHdvcmtde0BsaW5rIGh0dHBzOi8vY2hhaW5pZC5uZXR3b3JrfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFpbklkXCIsIHZvaWQgMCk7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXIncyBjdXJyZW50bHkgc2VsZWN0ZWQgU29sYW5hIGFkZHJlc3MuXG4gICAgICogSWYgbnVsbCwgVG9ydXMgaXMgZWl0aGVyIGxvY2tlZCBvciB0aGUgdXNlciBoYXMgbm90IHBlcm1pdHRlZCBhbnlcbiAgICAgKiBhZGRyZXNzZXMgdG8gYmUgdmlld2VkLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlbGVjdGVkQWRkcmVzc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyeVdpbmRvd0hhbmRsZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3N0YXRlID0gX29iamVjdFNwcmVhZCh7fSwgVG9ydXNJblBhZ2VQcm92aWRlci5fZGVmYXVsdFN0YXRlKTtcblxuICAgIC8vIHB1YmxpYyBzdGF0ZVxuICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gbnVsbDtcbiAgICB0aGlzLmNoYWluSWQgPSBudWxsO1xuICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZCA9IHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZCA9IHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCA9IHRoaXMuX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZC5iaW5kKHRoaXMpO1xuXG4gICAgLy8gc2V0dXAgb3duIGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgLy8gRUlQLTExOTMgY29ubmVjdFxuICAgIHRoaXMub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb25zdCBqc29uUnBjTm90aWZpY2F0aW9uSGFuZGxlciA9IHBheWxvYWQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfSA9IHBheWxvYWQ7XG4gICAgICBpZiAobWV0aG9kID09PSBQUk9WSURFUl9OT1RJRklDQVRJT05TLkFDQ09VTlRTX0NIQU5HRUQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkKHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gUFJPVklERVJfTk9USUZJQ0FUSU9OUy5VTkxPQ0tfU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBQUk9WSURFUl9OT1RJRklDQVRJT05TLkNIQUlOX0NIQU5HRUQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkKHBhcmFtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGpzb24gcnBjIG5vdGlmaWNhdGlvbiBsaXN0ZW5lclxuICAgIHRoaXMuanNvblJwY0Nvbm5lY3Rpb25FdmVudHMub24oXCJub3RpZmljYXRpb25cIiwganNvblJwY05vdGlmaWNhdGlvbkhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgaW5wYWdlIHByb3ZpZGVyIGlzIGNvbm5lY3RlZCB0byBUb3J1cy5cbiAgICovXG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZDtcbiAgfVxuXG4gIC8vIFByaXZhdGUgTWV0aG9kc1xuICAvLz0gPT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogQ29uc3RydWN0b3IgaGVscGVyLlxuICAgKiBQb3B1bGF0ZXMgaW5pdGlhbCBzdGF0ZSBieSBjYWxsaW5nICd3YWxsZXRfZ2V0UHJvdmlkZXJTdGF0ZScgYW5kIGVtaXRzXG4gICAqIG5lY2Vzc2FyeSBldmVudHMuXG4gICAqL1xuICBhc3luYyBfaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICBpc1VubG9ja2VkXG4gICAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBQUk9WSURFUl9KUlBDX01FVEhPRFMuR0VUX1BST1ZJREVSX1NUQVRFLFxuICAgICAgICBwYXJhbXM6IFtdXG4gICAgICB9KTtcblxuICAgICAgLy8gaW5kaWNhdGUgdGhhdCB3ZSd2ZSBjb25uZWN0ZWQsIGZvciBFSVAtMTE5MyBjb21wbGlhbmNlXG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9oYW5kbGVDaGFpbkNoYW5nZWQoe1xuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCh7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBpc1VubG9ja2VkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBGYWlsZWQgdG8gZ2V0IGluaXRpYWwgc3RhdGUuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbG9nLmluZm8oXCJpbml0aWFsaXplZCBwcm92aWRlciBzdGF0ZVwiKTtcbiAgICAgIHRoaXMuX3N0YXRlLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcIl9pbml0aWFsaXplZFwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgUlBDIG1ldGhvZC4gRm9yd2FyZHMgcmVxdWVzdHMgdG8gYmFja2dyb3VuZCB2aWEgdGhlIFJQQyBlbmdpbmUuXG4gICAqIEFsc28gcmVtYXAgaWRzIGluYm91bmQgYW5kIG91dGJvdW5kXG4gICAqL1xuICBfcnBjUmVxdWVzdChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGxldCBpc0ludGVybmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICBsZXQgY2IgPSBjYWxsYmFjaztcbiAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KF9wYXlsb2FkKSkge1xuICAgICAgaWYgKCFfcGF5bG9hZC5qc29ucnBjKSB7XG4gICAgICAgIF9wYXlsb2FkLmpzb25ycGMgPSBcIjIuMFwiO1xuICAgICAgfVxuICAgICAgaWYgKF9wYXlsb2FkLm1ldGhvZCA9PT0gXCJzb2xhbmFfYWNjb3VudHNcIiB8fCBfcGF5bG9hZC5tZXRob2QgPT09IFwic29sYW5hX3JlcXVlc3RBY2NvdW50c1wiKSB7XG4gICAgICAgIC8vIGhhbmRsZSBhY2NvdW50cyBjaGFuZ2luZ1xuICAgICAgICBjYiA9IChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChyZXMucmVzdWx0IHx8IFtdLCBfcGF5bG9hZC5tZXRob2QgPT09IFwic29sYW5hX2FjY291bnRzXCIsIGlzSW50ZXJuYWwpO1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoX3BheWxvYWQubWV0aG9kID09PSBcIndhbGxldF9nZXRQcm92aWRlclN0YXRlXCIpIHtcbiAgICAgICAgdGhpcy5fcnBjRW5naW5lLmhhbmRsZShwYXlsb2FkLCBjYik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50cnlXaW5kb3dIYW5kbGUoX3BheWxvYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGNvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBJRCBvZiB0aGUgbmV3bHkgY29ubmVjdGVkIGNoYWluLlxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Nvbm5lY3RcbiAgICovXG4gIF9oYW5kbGVDb25uZWN0KGNoYWluSWQpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSk7XG4gICAgICBsb2cuZGVidWcobWVzc2FnZXMuaW5mby5jb25uZWN0ZWQoY2hhaW5JZCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGRpc2Nvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50IHdpdGggcmVzcGVjdCB0byB0aGUgaXNSZWNvdmVyYWJsZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEVycm9yIGNvZGVzIHBlciB0aGUgQ2xvc2VFdmVudCBzdGF0dXMgY29kZXMgYXMgcmVxdWlyZWQgYnkgRUlQLTExOTM6XG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgKlxuICAgKiBAcGFyYW0gaXNSZWNvdmVyYWJsZSAtIFdoZXRoZXIgdGhlIGRpc2Nvbm5lY3Rpb24gaXMgcmVjb3ZlcmFibGUuXG4gICAqIEBwYXJhbSBlcnJvck1lc3NhZ2UgLSBBIGN1c3RvbSBlcnJvciBtZXNzYWdlLlxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Rpc2Nvbm5lY3RcbiAgICovXG4gIF9oYW5kbGVEaXNjb25uZWN0KGlzUmVjb3ZlcmFibGUsIGVycm9yTWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCB8fCAhdGhpcy5fc3RhdGUuaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCAmJiAhaXNSZWNvdmVyYWJsZSkge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIGlmIChpc1JlY292ZXJhYmxlKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEV0aGVyZXVtUnBjRXJyb3IoMTAxMyxcbiAgICAgICAgLy8gVHJ5IGFnYWluIGxhdGVyXG4gICAgICAgIGVycm9yTWVzc2FnZSB8fCBtZXNzYWdlcy5lcnJvcnMuZGlzY29ubmVjdGVkKCkpO1xuICAgICAgICBsb2cuZGVidWcoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXRoZXJldW1ScGNFcnJvcigxMDExLFxuICAgICAgICAvLyBJbnRlcm5hbCBlcnJvclxuICAgICAgICBlcnJvck1lc3NhZ2UgfHwgbWVzc2FnZXMuZXJyb3JzLnBlcm1hbmVudGx5RGlzY29ubmVjdGVkKCkpO1xuICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGF0ZS5hY2NvdW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNVbmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhY2NvdW50cyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgKi9cbiAgX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cykge1xuICAgIGxldCBpc0V0aEFjY291bnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBsZXQgaXNJbnRlcm5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgLy8gZGVmZW5zaXZlIHByb2dyYW1taW5nXG4gICAgbGV0IGZpbmFsQWNjb3VudHMgPSBhY2NvdW50cztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmluYWxBY2NvdW50cykpIHtcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBSZWNlaXZlZCBub24tYXJyYXkgYWNjb3VudHMgcGFyYW1ldGVyLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBmaW5hbEFjY291bnRzKTtcbiAgICAgIGZpbmFsQWNjb3VudHMgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XG4gICAgICBpZiAodHlwZW9mIGFjY291bnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IFJlY2VpdmVkIG5vbi1zdHJpbmcgYWNjb3VudC4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwgYWNjb3VudHMpO1xuICAgICAgICBmaW5hbEFjY291bnRzID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVtaXQgYWNjb3VudHNDaGFuZ2VkIGlmIGFueXRoaW5nIGFib3V0IHRoZSBhY2NvdW50cyBhcnJheSBoYXMgY2hhbmdlZFxuICAgIGlmICghZGVxdWFsKHRoaXMuX3N0YXRlLmFjY291bnRzLCBmaW5hbEFjY291bnRzKSkge1xuICAgICAgLy8gd2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHRoZSBjb3JyZWN0IGFjY291bnRzIGV2ZW4gYmVmb3JlIHNvbGFuYV9hY2NvdW50c1xuICAgICAgLy8gcmV0dXJucywgZXhjZXB0IGluIGNhc2VzIHdoZXJlIGlzSW50ZXJuYWwgaXMgdHJ1ZVxuICAgICAgaWYgKGlzRXRoQWNjb3VudHMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLl9zdGF0ZS5hY2NvdW50cykgJiYgdGhpcy5fc3RhdGUuYWNjb3VudHMubGVuZ3RoID4gMCAmJiAhaXNJbnRlcm5hbCkge1xuICAgICAgICBsb2cuZXJyb3IoJ1RvcnVzOiBcInNvbGFuYV9hY2NvdW50c1wiIHVuZXhwZWN0ZWRseSB1cGRhdGVkIGFjY291bnRzLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLicsIGZpbmFsQWNjb3VudHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdGUuYWNjb3VudHMgPSBmaW5hbEFjY291bnRzO1xuICAgICAgdGhpcy5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIGZpbmFsQWNjb3VudHMpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBzZWxlY3RlZEFkZHJlc3NcbiAgICBpZiAodGhpcy5zZWxlY3RlZEFkZHJlc3MgIT09IGZpbmFsQWNjb3VudHNbMF0pIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gZmluYWxBY2NvdW50c1swXSB8fCBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcG9uIHJlY2VpcHQgb2YgYSBuZXcgY2hhaW5JZCBhbmQgbmV0d29ya1ZlcnNpb24sIGVtaXRzIGNvcnJlc3BvbmRpbmdcbiAgICogZXZlbnRzIGFuZCBzZXRzIHJlbGV2YW50IHB1YmxpYyBzdGF0ZS5cbiAgICogRG9lcyBub3RoaW5nIGlmIG5laXRoZXIgdGhlIGNoYWluSWQgbm9yIHRoZSBuZXR3b3JrVmVyc2lvbiBhcmUgZGlmZmVyZW50XG4gICAqIGZyb20gZXhpc3RpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2NoYWluQ2hhbmdlZFxuICAgKiBAcGFyYW0gbmV0d29ya0luZm8gLSBBbiBvYmplY3Qgd2l0aCBuZXR3b3JrIGluZm8uXG4gICAqL1xuICBfaGFuZGxlQ2hhaW5DaGFuZ2VkKCkge1xuICAgIGxldCB7XG4gICAgICBjaGFpbklkXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogUmVjZWl2ZWQgaW52YWxpZCBuZXR3b3JrIHBhcmFtZXRlcnMuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIHtcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGFpbklkID09PSBcImxvYWRpbmdcIikge1xuICAgICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdChjaGFpbklkKTtcbiAgICAgIGlmIChjaGFpbklkICE9PSB0aGlzLmNoYWluSWQpIHtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiY2hhaW5DaGFuZ2VkXCIsIHRoaXMuY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBvbiByZWNlaXB0IG9mIGEgbmV3IGlzVW5sb2NrZWQgc3RhdGUsIHNldHMgcmVsZXZhbnQgcHVibGljIHN0YXRlLlxuICAgKiBDYWxscyB0aGUgYWNjb3VudHMgY2hhbmdlZCBoYW5kbGVyIHdpdGggdGhlIHJlY2VpdmVkIGFjY291bnRzLCBvciBhbiBlbXB0eVxuICAgKiBhcnJheS5cbiAgICpcbiAgICogRG9lcyBub3RoaW5nIGlmIHRoZSByZWNlaXZlZCB2YWx1ZSBpcyBlcXVhbCB0byB0aGUgZXhpc3RpbmcgdmFsdWUuXG4gICAqIFRoZXJlIGFyZSBubyBsb2NrL3VubG9jayBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAqL1xuICBfaGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkKCkge1xuICAgIGxldCB7XG4gICAgICBhY2NvdW50cyxcbiAgICAgIGlzVW5sb2NrZWRcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAodHlwZW9mIGlzVW5sb2NrZWQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogUmVjZWl2ZWQgaW52YWxpZCBpc1VubG9ja2VkIHBhcmFtZXRlci4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwge1xuICAgICAgICBpc1VubG9ja2VkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzVW5sb2NrZWQgIT09IHRoaXMuX3N0YXRlLmlzVW5sb2NrZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzVW5sb2NrZWQgPSBpc1VubG9ja2VkO1xuICAgICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzIHx8IFtdKTtcbiAgICB9XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShUb3J1c0luUGFnZVByb3ZpZGVyLCBcIl9kZWZhdWx0U3RhdGVcIiwge1xuICBhY2NvdW50czogbnVsbCxcbiAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxuICBpc1VubG9ja2VkOiBmYWxzZSxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBpc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkOiBmYWxzZSxcbiAgaGFzRW1pdHRlZENvbm5lY3Rpb246IGZhbHNlXG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGltYWdlIFVSTCBleGlzdHNcbiAqL1xuZnVuY3Rpb24gaW1nRXhpc3RzKHVybCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUodHJ1ZSk7XG4gICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlc29sdmUoZmFsc2UpO1xuICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBhIG5hbWUgZm9yIHRoZSBzaXRlIGZyb20gdGhlIERPTVxuICovXG5jb25zdCBnZXRTaXRlTmFtZSA9IHdpbmRvdyA9PiB7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudFxuICB9ID0gd2luZG93O1xuICBjb25zdCBzaXRlTmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQgPiBtZXRhW3Byb3BlcnR5PVwib2c6c2l0ZV9uYW1lXCJdJyk7XG4gIGlmIChzaXRlTmFtZSkge1xuICAgIHJldHVybiBzaXRlTmFtZS5jb250ZW50O1xuICB9XG4gIGNvbnN0IG1ldGFUaXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQgPiBtZXRhW25hbWU9XCJ0aXRsZVwiXScpO1xuICBpZiAobWV0YVRpdGxlKSB7XG4gICAgcmV0dXJuIG1ldGFUaXRsZS5jb250ZW50O1xuICB9XG4gIGlmIChkb2N1bWVudC50aXRsZSAmJiBkb2N1bWVudC50aXRsZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnRpdGxlO1xuICB9XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG59O1xuXG4vKipcbiAqIEV4dHJhY3RzIGFuIGljb24gZm9yIHRoZSBzaXRlIGZyb20gdGhlIERPTVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTaXRlSWNvbih3aW5kb3cpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB3aW5kb3c7XG5cbiAgICAvLyBVc2UgdGhlIHNpdGUncyBmYXZpY29uIGlmIGl0IGV4aXN0c1xuICAgIGxldCBpY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IGxpbmtbcmVsPVwic2hvcnRjdXQgaWNvblwiXScpO1xuICAgIGlmIChpY29uICYmIChhd2FpdCBpbWdFeGlzdHMoaWNvbi5ocmVmKSkpIHtcbiAgICAgIHJldHVybiBpY29uLmhyZWY7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIHRocm91Z2ggYXZhaWxhYmxlIGljb25zIGluIG5vIHBhcnRpY3VsYXIgb3JkZXJcbiAgICBpY29uID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdoZWFkID4gbGlua1tyZWw9XCJpY29uXCJdJykpLmZpbmQoX2ljb24gPT4gQm9vbGVhbihfaWNvbi5ocmVmKSk7XG4gICAgaWYgKGljb24gJiYgKGF3YWl0IGltZ0V4aXN0cyhpY29uLmhyZWYpKSkge1xuICAgICAgcmV0dXJuIGljb24uaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHNpdGUgbWV0YWRhdGEgYW5kIHJldHVybnMgaXRcbiAqXG4gKi9cbmNvbnN0IGdldFNpdGVNZXRhZGF0YSA9IGFzeW5jICgpID0+ICh7XG4gIG5hbWU6IGdldFNpdGVOYW1lKHdpbmRvdyksXG4gIGljb246IGF3YWl0IGdldFNpdGVJY29uKHdpbmRvdylcbn0pO1xuXG5jb25zdCBQUk9WSURFUl9VTlNBRkVfTUVUSE9EUyA9IFtcInNlbmRfdHJhbnNhY3Rpb25cIiwgXCJzaWduX3RyYW5zYWN0aW9uXCIsIFwic2lnbl9hbGxfdHJhbnNhY3Rpb25zXCIsIFwic2lnbl9tZXNzYWdlXCIsIFwiY29ubmVjdFwiXTtcbmNvbnN0IENPTU1VTklDQVRJT05fVU5TQUZFX01FVEhPRFMgPSBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuU0VUX1BST1ZJREVSXTtcbmNvbnN0IGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlID0gc3RvcmFnZUF2YWlsYWJsZShcImxvY2FsU3RvcmFnZVwiKTtcblxuLy8gcHJlbG9hZCBmb3IgaWZyYW1lIGRvZXNuJ3Qgd29yayBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01OTMyNjdcbihhc3luYyBmdW5jdGlvbiBwcmVMb2FkSWZyYW1lKCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICBjb25zdCB0b3J1c0lmcmFtZUh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBjb25zdCB7XG4gICAgICB0b3J1c1VybFxuICAgIH0gPSBhd2FpdCBnZXRUb3J1c1VybChcInByb2R1Y3Rpb25cIik7XG4gICAgdG9ydXNJZnJhbWVIdG1sLmhyZWYgPSBgJHt0b3J1c1VybH0vZnJhbWVgO1xuICAgIHRvcnVzSWZyYW1lSHRtbC5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgdG9ydXNJZnJhbWVIdG1sLnR5cGUgPSBcInRleHQvaHRtbFwiO1xuICAgIHRvcnVzSWZyYW1lSHRtbC5yZWwgPSBcInByZWZldGNoXCI7XG4gICAgaWYgKHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0ICYmIHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0LnN1cHBvcnRzKSB7XG4gICAgICBpZiAodG9ydXNJZnJhbWVIdG1sLnJlbExpc3Quc3VwcG9ydHMoXCJwcmVmZXRjaFwiKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRvcnVzSWZyYW1lSHRtbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy53YXJuKGVycm9yKTtcbiAgfVxufSkoKTtcbmNsYXNzIFRvcnVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHtcbiAgICAgIG1vZGFsWkluZGV4ID0gOTk5OTlcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc0luaXRpYWxpemVkXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNBbGVydFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGFsWkluZGV4XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxlcnRaSW5kZXhcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXF1ZXN0ZWRMb2dpblByb3ZpZGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvdmlkZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb21tdW5pY2F0aW9uUHJvdmlkZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXBwU3RvcmFnZUtleVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVG9wdXBIaWRkZW5cIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzQWxlcnRDb250YWluZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c1VybFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzSWZyYW1lXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3R5bGVMaW5rXCIsIHZvaWQgMCk7XG4gICAgdGhpcy50b3J1c1VybCA9IFwiXCI7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7IC8vIGluaXQgZG9uZVxuICAgIHRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciA9IG51bGw7XG4gICAgdGhpcy5tb2RhbFpJbmRleCA9IG1vZGFsWkluZGV4O1xuICAgIHRoaXMuYWxlcnRaSW5kZXggPSBtb2RhbFpJbmRleCArIDEwMDA7XG4gICAgdGhpcy5kYXBwU3RvcmFnZUtleSA9IFwiXCI7XG4gIH1cbiAgZ2V0IGlzTG9nZ2VkSW4oKSB7XG4gICAgaWYgKCF0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlcikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0xvZ2dlZEluO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgbGV0IHtcbiAgICAgIGJ1aWxkRW52ID0gVE9SVVNfQlVJTERfRU5WLlBST0RVQ1RJT04sXG4gICAgICBlbmFibGVMb2dnaW5nID0gZmFsc2UsXG4gICAgICBuZXR3b3JrLFxuICAgICAgc2hvd1RvcnVzQnV0dG9uID0gZmFsc2UsXG4gICAgICB1c2VMb2NhbFN0b3JhZ2UgPSBmYWxzZSxcbiAgICAgIGJ1dHRvblBvc2l0aW9uID0gQlVUVE9OX1BPU0lUSU9OLkJPVFRPTV9MRUZULFxuICAgICAgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCIsXG4gICAgICBleHRyYVBhcmFtcyA9IHt9LFxuICAgICAgd2hpdGVMYWJlbFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgaW5pdGlhbGl6ZWRcIik7XG4gICAgc2V0QVBJS2V5KGFwaUtleSk7XG4gICAgY29uc3Qge1xuICAgICAgdG9ydXNVcmwsXG4gICAgICBsb2dMZXZlbFxuICAgIH0gPSBhd2FpdCBnZXRUb3J1c1VybChidWlsZEVudik7XG4gICAgbG9nLmVuYWJsZUFsbCgpO1xuICAgIGxvZy5pbmZvKHRvcnVzVXJsLCBcInVybCBsb2FkZWRcIik7XG4gICAgbG9nLmluZm8oYFNvbGFuYSBFbWJlZCBWZXJzaW9uIDoke3ZlcnNpb259YCk7XG4gICAgdGhpcy50b3J1c1VybCA9IHRvcnVzVXJsO1xuICAgIGxvZy5zZXREZWZhdWx0TGV2ZWwobG9nTGV2ZWwpO1xuICAgIGlmIChlbmFibGVMb2dnaW5nKSBsb2cuZW5hYmxlQWxsKCk7ZWxzZSBsb2cuZGlzYWJsZUFsbCgpO1xuICAgIGNvbnN0IGRhcHBTdG9yYWdlS2V5ID0gdGhpcy5oYW5kbGVEYXBwU3RvcmFnZUtleSh1c2VMb2NhbFN0b3JhZ2UpO1xuICAgIGNvbnN0IHRvcnVzSWZyYW1lVXJsID0gbmV3IFVSTCh0b3J1c1VybCk7XG4gICAgaWYgKHRvcnVzSWZyYW1lVXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSkgdG9ydXNJZnJhbWVVcmwucGF0aG5hbWUgKz0gXCJmcmFtZVwiO2Vsc2UgdG9ydXNJZnJhbWVVcmwucGF0aG5hbWUgKz0gXCIvZnJhbWVcIjtcbiAgICBjb25zdCBoYXNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChkYXBwU3RvcmFnZUtleSkgaGFzaFBhcmFtcy5hcHBlbmQoXCJkYXBwU3RvcmFnZUtleVwiLCBkYXBwU3RvcmFnZUtleSk7XG4gICAgaGFzaFBhcmFtcy5hcHBlbmQoXCJvcmlnaW5cIiwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgdG9ydXNJZnJhbWVVcmwuaGFzaCA9IGhhc2hQYXJhbXMudG9TdHJpbmcoKTtcblxuICAgIC8vIElmcmFtZSBjb2RlXG4gICAgdGhpcy50b3J1c0lmcmFtZSA9IGh0bWxUb0VsZW1lbnQoYDxpZnJhbWVcbiAgICAgICAgaWQ9XCJ0b3J1c0lmcmFtZVwiXG4gICAgICAgIGNsYXNzPVwidG9ydXNJZnJhbWVcIlxuICAgICAgICBzcmM9XCIke3RvcnVzSWZyYW1lVXJsLmhyZWZ9XCJcbiAgICAgICAgc3R5bGU9XCJkaXNwbGF5OiBub25lOyBwb3NpdGlvbjogZml4ZWQ7IHRvcDogMDsgcmlnaHQ6IDA7IHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7IGJvcmRlcjogbm9uZTsgYm9yZGVyLXJhZGl1czogMDsgei1pbmRleDogJHt0aGlzLm1vZGFsWkluZGV4LnRvU3RyaW5nKCl9XCJcbiAgICAgID48L2lmcmFtZT5gKTtcbiAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIgPSBodG1sVG9FbGVtZW50KGA8ZGl2IGlkPVwidG9ydXNBbGVydENvbnRhaW5lclwiIHN0eWxlPVwiZGlzcGxheTpub25lOyB6LWluZGV4OiAke3RoaXMuYWxlcnRaSW5kZXgudG9TdHJpbmcoKX1cIj48L2Rpdj5gKTtcbiAgICB0aGlzLnN0eWxlTGluayA9IGh0bWxUb0VsZW1lbnQoYDxsaW5rIGhyZWY9XCIke3RvcnVzVXJsfS9jc3Mvd2lkZ2V0LmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIiB0eXBlPVwidGV4dC9jc3NcIj5gKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy50b3J1c0lmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGFwcE1ldGFkYXRhID0gYXdhaXQgZ2V0U2l0ZU1ldGFkYXRhKCk7XG4gICAgICAgICAgLy8gc2VuZCBpbml0IHBhcmFtcyBoZXJlXG4gICAgICAgICAgdGhpcy50b3J1c0lmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGJ1dHRvblBvc2l0aW9uLFxuICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgbmV0d29yayxcbiAgICAgICAgICAgIGRhcHBNZXRhZGF0YSxcbiAgICAgICAgICAgIGV4dHJhUGFyYW1zLFxuICAgICAgICAgICAgd2hpdGVMYWJlbFxuICAgICAgICAgIH0sIHRvcnVzSWZyYW1lVXJsLm9yaWdpbik7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBXZWIzKHtcbiAgICAgICAgICAgIHRvcnVzVXJsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHNob3dUb3J1c0J1dHRvbikgdGhpcy5zaG93VG9ydXNCdXR0b24oKTtcbiAgICAgICAgICBpZiAod2hpdGVMYWJlbD8udG9wdXBIaWRlKSB0aGlzLmlzVG9wdXBIaWRkZW4gPSB3aGl0ZUxhYmVsLnRvcHVwSGlkZTtlbHNlIHRoaXMuaGlkZVRvcnVzQnV0dG9uKCk7XG4gICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIHdpbmRvdy50b3J1cyA9IHRoaXM7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZUxpbmspO1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvcnVzSWZyYW1lKTtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbG9naW4oKSB7XG4gICAgbGV0IHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGwgaW5pdCgpIGZpcnN0XCIpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlcXVlc3RlZExvZ2luUHJvdmlkZXIgPSBwYXJhbXMubG9naW5Qcm92aWRlciB8fCBudWxsO1xuICAgICAgaWYgKCF0aGlzLnJlcXVlc3RlZExvZ2luUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuX2Rpc3BsYXlJZnJhbWUoe1xuICAgICAgICAgIGlzRnVsbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVzZXIgaXMgYWxyZWFkeSBsb2dnZWQgaW4sIHdlIGFzc3VtZSB0aGV5IGhhdmUgZ2l2ZW4gYWNjZXNzIHRvIHRoZSB3ZWJzaXRlXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIG1ldGhvZCBiZWNhdXNlIHdlIHdhbnQgdG8gdXBkYXRlIGluUGFnZSBwcm92aWRlciBzdGF0ZSB3aXRoIGFjY291bnQgaW5mb1xuICAgICAgICB0aGlzLnByb3ZpZGVyLl9ycGNSZXF1ZXN0KHtcbiAgICAgICAgICBtZXRob2Q6IFwic29sYW5hX3JlcXVlc3RBY2NvdW50c1wiLFxuICAgICAgICAgIHBhcmFtczogW3RoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciwgcGFyYW1zLmxvZ2luX2hpbnRdXG4gICAgICAgIH0sIGdldFJwY1Byb21pc2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3b3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBqdXN0IGluIGNhc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2luIGZhaWxlZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwibG9naW4gZmFpbGVkXCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaXNJRnJhbWVGdWxsU2NyZWVuKSB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5fZGlzcGxheUlmcmFtZSgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBsb2dpbldpdGhQcml2YXRlS2V5KGxvZ2luUGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGwgaW5pdCgpIGZpcnN0XCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICB1c2VySW5mb1xuICAgIH0gPSBsb2dpblBhcmFtcztcbiAgICBjb25zdCB7XG4gICAgICBzdWNjZXNzXG4gICAgfSA9IGF3YWl0IHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcImxvZ2luX3dpdGhfcHJpdmF0ZV9rZXlcIixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICB1c2VySW5mb1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghc3VjY2VzcykgdGhyb3cgbmV3IEVycm9yKFwiTG9naW4gRmFpbGVkXCIpO1xuICB9XG4gIGFzeW5jIGxvZ291dCgpIHtcbiAgICBpZiAoIXRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmlzTG9nZ2VkSW4pIHRocm93IG5ldyBFcnJvcihcIk5vdCBsb2dnZWQgaW5cIik7XG4gICAgYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkxPR09VVCxcbiAgICAgIHBhcmFtczogW11cbiAgICB9KTtcbiAgICB0aGlzLnJlcXVlc3RlZExvZ2luUHJvdmlkZXIgPSBudWxsO1xuICB9XG4gIGFzeW5jIGNsZWFuVXAoKSB7XG4gICAgaWYgKHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmlzTG9nZ2VkSW4pIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nb3V0KCk7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJJbml0KCk7XG4gIH1cbiAgY2xlYXJJbml0KCkge1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIERvY3VtZW50O1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KHRoaXMuc3R5bGVMaW5rKSAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnN0eWxlTGluaykpIHtcbiAgICAgIHRoaXMuc3R5bGVMaW5rLnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdHlsZUxpbmsgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQodGhpcy50b3J1c0lmcmFtZSkgJiYgd2luZG93LmRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy50b3J1c0lmcmFtZSkpIHtcbiAgICAgIHRoaXMudG9ydXNJZnJhbWUucmVtb3ZlKCk7XG4gICAgICB0aGlzLnRvcnVzSWZyYW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KHRoaXMudG9ydXNBbGVydENvbnRhaW5lcikgJiYgd2luZG93LmRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyKSkge1xuICAgICAgdGhpcy50b3J1c0FsZXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuICBoaWRlVG9ydXNCdXR0b24oKSB7XG4gICAgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaGlkZVRvcnVzQnV0dG9uKCk7XG4gIH1cbiAgc2hvd1RvcnVzQnV0dG9uKCkge1xuICAgIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLnNob3dUb3J1c0J1dHRvbigpO1xuICB9XG4gIGFzeW5jIHNldFByb3ZpZGVyKHBhcmFtcykge1xuICAgIGF3YWl0IHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5TRVRfUFJPVklERVIsXG4gICAgICBwYXJhbXM6IF9vYmplY3RTcHJlYWQoe30sIHBhcmFtcylcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzaG93V2FsbGV0KHBhdGgpIHtcbiAgICBsZXQgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBpbnN0YW5jZUlkID0gYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLldBTExFVF9JTlNUQU5DRV9JRCxcbiAgICAgIHBhcmFtczogW11cbiAgICB9KTtcbiAgICBjb25zdCBmaW5hbFBhdGggPSBwYXRoID8gYC8ke3BhdGh9YCA6IFwiXCI7XG4gICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKGAke3RoaXMudG9ydXNVcmx9L3dhbGxldCR7ZmluYWxQYXRofWApO1xuICAgIC8vIFVzaW5nIFVSTCBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGpzIGluamVjdGlvbiBhbmQgYWxsb3cgcGFyYW1ldGVyIHZhbGlkYXRpb24uIVxuICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbnN0YW5jZUlkXCIsIGluc3RhbmNlSWQpO1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCh4ID0+IHtcbiAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoeCwgcGFyYW1zW3hdKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5kYXBwU3RvcmFnZUtleSkge1xuICAgICAgZmluYWxVcmwuaGFzaCA9IGAjZGFwcFN0b3JhZ2VLZXk9JHt0aGlzLmRhcHBTdG9yYWdlS2V5fWA7XG4gICAgfVxuICAgIC8vIE5vIG5lZWQgdG8gdHJhY2sgdGhpcyB3aW5kb3cgc3RhdGUuIEhlbmNlLCBubyBfaGFuZGxlV2luZG93IGNhbGwuXG4gICAgY29uc3Qgd2FsbGV0V2luZG93ID0gbmV3IFBvcHVwSGFuZGxlcih7XG4gICAgICB1cmw6IGZpbmFsVXJsLFxuICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XKVxuICAgIH0pO1xuICAgIHdhbGxldFdpbmRvdy5vcGVuKCk7XG4gIH1cbiAgYXN5bmMgZ2V0VXNlckluZm8oKSB7XG4gICAgY29uc3QgdXNlckluZm9SZXNwb25zZSA9IGF3YWl0IHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5VU0VSX0lORk8sXG4gICAgICBwYXJhbXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHVzZXJJbmZvUmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgaW5pdGlhdGVUb3B1cChwcm92aWRlciwgcGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHRocm93IG5ldyBFcnJvcihcIlRvcnVzIGlzIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICBjb25zdCB3aW5kb3dJZCA9IGdldFdpbmRvd0lkKCk7XG4gICAgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCk7XG4gICAgY29uc3QgdG9wdXBSZXNwb25zZSA9IGF3YWl0IHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5UT1BVUCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB3aW5kb3dJZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0b3B1cFJlc3BvbnNlO1xuICB9XG5cbiAgLy8gU29sYW5hIHNwZWNpZmljIEFQSVxuICBhc3luYyBnZXRBY2NvdW50cygpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiZ2V0QWNjb3VudHNcIixcbiAgICAgIHBhcmFtczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgaXNMZWdhY3lUcmFuc2FjdGlvbiA9IGlzTGVnYWN5VHJhbnNhY3Rpb25JbnN0YW5jZSh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgbWVzc2FnZSA9IGlzTGVnYWN5VHJhbnNhY3Rpb24gPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoe1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlXG4gICAgfSkudG9TdHJpbmcoXCJoZXhcIikgOiBCdWZmZXIuZnJvbSh0cmFuc2FjdGlvbi5zZXJpYWxpemUoKSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcInNlbmRfdHJhbnNhY3Rpb25cIixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBpc0xlZ2FjeVRyYW5zYWN0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLy8gc3VwcG9ydCBzZW5kT3B0aW9uc1xuICBhc3luYyBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaXNMZWdhY3lUcmFuc2FjdGlvbiA9IGlzTGVnYWN5VHJhbnNhY3Rpb25JbnN0YW5jZSh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgbWVzc2FnZSA9IGlzTGVnYWN5VHJhbnNhY3Rpb24gPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoe1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlXG4gICAgfSkudG9TdHJpbmcoXCJoZXhcIikgOiBCdWZmZXIuZnJvbSh0cmFuc2FjdGlvbi5zZXJpYWxpemUoKSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcInNlbmRfdHJhbnNhY3Rpb25cIixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpc0xlZ2FjeVRyYW5zYWN0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25hdHVyZTogcmVzcG9uc2VcbiAgICB9O1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IGlzTGVnYWN5VHJhbnNhY3Rpb24gPSBpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0xlZ2FjeVRyYW5zYWN0aW9uID8gdHJhbnNhY3Rpb24uc2VyaWFsaXplTWVzc2FnZSgpLnRvU3RyaW5nKFwiaGV4XCIpIDogQnVmZmVyLmZyb20odHJhbnNhY3Rpb24ubWVzc2FnZS5zZXJpYWxpemUoKSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcInNpZ25fdHJhbnNhY3Rpb25cIixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBtZXNzYWdlT25seTogdHJ1ZSxcbiAgICAgICAgaXNMZWdhY3lUcmFuc2FjdGlvblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVjb25zdHJ1Y3Qgc2lnbmF0dXJlIHBhaXJcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSB7XG4gICAgICBwdWJsaWNLZXk6IG5ldyBQdWJsaWNLZXkocGFyc2VkLnB1YmxpY0tleSksXG4gICAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHBhcnNlZC5zaWduYXR1cmUsIFwiaGV4XCIpXG4gICAgfTtcbiAgICB0cmFuc2FjdGlvbi5hZGRTaWduYXR1cmUoc2lnbmF0dXJlLnB1YmxpY0tleSwgc2lnbmF0dXJlLnNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG4gIGFzeW5jIHNpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgbGV0IGlzTGVnYWN5VHJhbnNhY3Rpb247XG4gICAgY29uc3QgZW5jb2RlZE1lc3NhZ2UgPSB0cmFuc2FjdGlvbnMubWFwKHR4ID0+IHtcbiAgICAgIGlzTGVnYWN5VHJhbnNhY3Rpb24gPSBpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UodHgpO1xuICAgICAgcmV0dXJuIGlzTGVnYWN5VHJhbnNhY3Rpb24gPyB0eC5zZXJpYWxpemVNZXNzYWdlKCkudG9TdHJpbmcoXCJoZXhcIikgOiBCdWZmZXIuZnJvbSh0eC5tZXNzYWdlLnNlcmlhbGl6ZSgpKS50b1N0cmluZyhcImhleFwiKTtcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcInNpZ25fYWxsX3RyYW5zYWN0aW9uc1wiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1lc3NhZ2U6IGVuY29kZWRNZXNzYWdlLFxuICAgICAgICBtZXNzYWdlT25seTogdHJ1ZSxcbiAgICAgICAgaXNMZWdhY3lUcmFuc2FjdGlvblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVjb25zdHJ1Y3Qgc2lnbmF0dXJlIHBhaXJzXG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IHJlc3BvbnNlcy5tYXAoaXRlbSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGl0ZW0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHVibGljS2V5OiBuZXcgUHVibGljS2V5KHBhcnNlZC5wdWJsaWNLZXkpLFxuICAgICAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHBhcnNlZC5zaWduYXR1cmUsIFwiaGV4XCIpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0eCwgaWR4KSA9PiB7XG4gICAgICB0eC5hZGRTaWduYXR1cmUoc2lnbmF0dXJlc1tpZHhdLnB1YmxpY0tleSwgc2lnbmF0dXJlc1tpZHhdLnNpZ25hdHVyZSk7XG4gICAgICByZXR1cm4gdHg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9ucztcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcInNpZ25fbWVzc2FnZVwiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgZ2V0R2FzbGVzc1B1YmxpY0tleSgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiZ2V0X2dhc2xlc3NfcHVibGljX2tleVwiLFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIC8vIGFzeW5jIGNvbm5lY3QoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIC8vICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgLy8gICAgIG1ldGhvZDogXCJjb25uZWN0XCIsXG4gIC8vICAgICBwYXJhbXM6IHt9LFxuICAvLyAgIH0pKSBhcyBib29sZWFuO1xuICAvLyAgIHJldHVybiByZXNwb25zZTtcbiAgLy8gfVxuXG4gIGhhbmRsZURhcHBTdG9yYWdlS2V5KHVzZUxvY2FsU3RvcmFnZSkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmFnZUtleSA9IGAke2NvbmZpZ3VyYXRpb24ubG9jYWxTdG9yYWdlS2V5UHJlZml4fSR7d2luZG93LmxvY2F0aW9uLmhvc3RuYW1lfWA7XG4gICAgbGV0IGRhcHBTdG9yYWdlS2V5ID0gXCJcIjtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUgJiYgdXNlTG9jYWxTdG9yYWdlKSB7XG4gICAgICBjb25zdCBzdG9yZWRLZXkgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTdG9yYWdlS2V5KTtcbiAgICAgIGlmIChzdG9yZWRLZXkpIGRhcHBTdG9yYWdlS2V5ID0gc3RvcmVkS2V5O2Vsc2Uge1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRLZXkgPSBgdG9ydXMtYXBwLSR7Z2V0V2luZG93SWQoKX1gO1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0obG9jYWxTdG9yYWdlS2V5LCBnZW5lcmF0ZWRLZXkpO1xuICAgICAgICBkYXBwU3RvcmFnZUtleSA9IGdlbmVyYXRlZEtleTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kYXBwU3RvcmFnZUtleSA9IGRhcHBTdG9yYWdlS2V5O1xuICAgIHJldHVybiBkYXBwU3RvcmFnZUtleTtcbiAgfVxuICBhc3luYyBfc2V0dXBXZWIzKHByb3ZpZGVyUGFyYW1zKSB7XG4gICAgbG9nLmluZm8oXCJzZXR1cFdlYjMgcnVubmluZ1wiKTtcbiAgICAvLyBzZXR1cCBiYWNrZ3JvdW5kIGNvbm5lY3Rpb25cbiAgICBjb25zdCBwcm92aWRlclN0cmVhbSA9IG5ldyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0oe1xuICAgICAgbmFtZTogXCJlbWJlZF90b3J1c1wiLFxuICAgICAgdGFyZ2V0OiBcImlmcmFtZV90b3J1c1wiLFxuICAgICAgdGFyZ2V0V2luZG93OiB0aGlzLnRvcnVzSWZyYW1lLmNvbnRlbnRXaW5kb3dcbiAgICB9KTtcblxuICAgIC8vIFdlIGNyZWF0ZSBhbm90aGVyIExvY2FsTWVzc2FnZUR1cGxleFN0cmVhbSBmb3IgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGRhcHAgPD4gaWZyYW1lXG4gICAgY29uc3QgY29tbXVuaWNhdGlvblN0cmVhbSA9IG5ldyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0oe1xuICAgICAgbmFtZTogXCJlbWJlZF9jb21tdW5pY2F0aW9uXCIsXG4gICAgICB0YXJnZXQ6IFwiaWZyYW1lX2NvbW11bmljYXRpb25cIixcbiAgICAgIHRhcmdldFdpbmRvdzogdGhpcy50b3J1c0lmcmFtZS5jb250ZW50V2luZG93XG4gICAgfSk7XG5cbiAgICAvLyBjb21wb3NlIHRoZSBpblBhZ2UgcHJvdmlkZXJcbiAgICBjb25zdCBpblBhZ2VQcm92aWRlciA9IG5ldyBUb3J1c0luUGFnZVByb3ZpZGVyKHByb3ZpZGVyU3RyZWFtLCB7fSk7XG4gICAgY29uc3QgY29tbXVuaWNhdGlvblByb3ZpZGVyID0gbmV3IFRvcnVzQ29tbXVuaWNhdGlvblByb3ZpZGVyKGNvbW11bmljYXRpb25TdHJlYW0sIHt9KTtcbiAgICBpblBhZ2VQcm92aWRlci50cnlXaW5kb3dIYW5kbGUgPSAocGF5bG9hZCwgY2IpID0+IHtcbiAgICAgIGNvbnN0IF9wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShfcGF5bG9hZCkgJiYgUFJPVklERVJfVU5TQUZFX01FVEhPRFMuaW5jbHVkZXMoX3BheWxvYWQubWV0aG9kKSkge1xuICAgICAgICBpZiAoIXRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmlzTG9nZ2VkSW4pIHRocm93IG5ldyBFcnJvcihcIlVzZXIgTm90IExvZ2dlZCBJblwiKTtcbiAgICAgICAgY29uc3Qgd2luZG93SWQgPSBnZXRXaW5kb3dJZCgpO1xuICAgICAgICBjb21tdW5pY2F0aW9uUHJvdmlkZXIuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCwge1xuICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19DT05GSVJNX1dJTkRPVylcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZvciBpblBhZ2VQcm92aWRlciBtZXRob2RzIHNlbmRpbmcgd2luZG93SWQgaW4gcmVxdWVzdCBpbnN0ZWFkIG9mIHBhcmFtc1xuICAgICAgICAvLyBhcyBwYXJhbXMgbWlnaHQgYmUgcG9zaXRpb25hbC5cbiAgICAgICAgX3BheWxvYWQud2luZG93SWQgPSB3aW5kb3dJZDtcbiAgICAgIH1cbiAgICAgIGluUGFnZVByb3ZpZGVyLl9ycGNFbmdpbmUuaGFuZGxlKF9wYXlsb2FkLCBjYik7XG4gICAgfTtcbiAgICBjb21tdW5pY2F0aW9uUHJvdmlkZXIudHJ5V2luZG93SGFuZGxlID0gKHBheWxvYWQsIGNiKSA9PiB7XG4gICAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoX3BheWxvYWQpICYmIENPTU1VTklDQVRJT05fVU5TQUZFX01FVEhPRFMuaW5jbHVkZXMoX3BheWxvYWQubWV0aG9kKSkge1xuICAgICAgICBjb25zdCB3aW5kb3dJZCA9IGdldFdpbmRvd0lkKCk7XG4gICAgICAgIGNvbW11bmljYXRpb25Qcm92aWRlci5faGFuZGxlV2luZG93KHdpbmRvd0lkLCB7XG4gICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgIGZlYXR1cmVzOiBnZXRQb3B1cEZlYXR1cmVzKEZFQVRVUkVTX1BST1ZJREVSX0NIQU5HRV9XSU5ET1cpIC8vIHRvZG86IGFyZSB0aGVzZSBmZWF0dXJlcyBnZW5lcmljIGZvciBhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZvciBjb21tdW5pY2F0aW9uIG1ldGhvZHMgc2VuZGluZyB3aW5kb3cgaWQgaW4ganJwYyByZXEgcGFyYW1zXG4gICAgICAgIF9wYXlsb2FkLnBhcmFtcy53aW5kb3dJZCA9IHdpbmRvd0lkO1xuICAgICAgfVxuICAgICAgY29tbXVuaWNhdGlvblByb3ZpZGVyLl9ycGNFbmdpbmUuaGFuZGxlKF9wYXlsb2FkLCBjYik7XG4gICAgfTtcblxuICAgIC8vIGRldGVjdCBzb2xhbmFfcmVxdWVzdEFjY291bnRzIGFuZCBwaXBlIHRvIGVuYWJsZSBmb3Igbm93XG4gICAgY29uc3QgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllciA9IG0gPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBpblBhZ2VQcm92aWRlclttXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpblBhZ2VQcm92aWRlclttXSA9IGZ1bmN0aW9uIHByb3ZpZGVyRnVuYyhyZXF1ZXN0LCBjYikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIHBhcmFtcyA9IFtdXG4gICAgICAgIH0gPSByZXF1ZXN0O1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInNvbGFuYV9yZXF1ZXN0QWNjb3VudHNcIikge1xuICAgICAgICAgIGlmICghY2IpIHJldHVybiBzZWxmLmxvZ2luKHtcbiAgICAgICAgICAgIGxvZ2luUHJvdmlkZXI6IHBhcmFtc1swXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYubG9naW4oe1xuICAgICAgICAgICAgbG9naW5Qcm92aWRlcjogcGFyYW1zWzBdXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9uby1jYWxsYmFjay1pbi1wcm9taXNlXG4gICAgICAgICAgLnRoZW4ocmVzID0+IGNiKG51bGwsIHJlcykpXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2Uvbm8tY2FsbGJhY2staW4tcHJvbWlzZVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4gY2IoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBbcmVxdWVzdCwgY2JdKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIERldGVjdHMgY2FsbCB0byBzb2xhbmFfcmVxdWVzdEFjY291bnRzIGluIHJlcXVlc3QgJiBzZW5kQXN5bmMgYW5kIHBhc3NlcyB0byBsb2dpblxuICAgIGRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIoXCJyZXF1ZXN0XCIpO1xuICAgIGRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIoXCJzZW5kQXN5bmNcIik7XG4gICAgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllcihcInNlbmRcIik7XG4gICAgY29uc3QgcHJveGllZEluUGFnZVByb3ZpZGVyID0gbmV3IFByb3h5KGluUGFnZVByb3ZpZGVyLCB7XG4gICAgICAvLyBzdHJhaWdodCB1cCBsaWUgdGhhdCB3ZSBkZWxldGVkIHRoZSBwcm9wZXJ0eSBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGluIHN0cmljdCBtb2RlXG4gICAgICBkZWxldGVQcm9wZXJ0eTogKCkgPT4gdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHByb3hpZWRDb21tdW5pY2F0aW9uUHJvdmlkZXIgPSBuZXcgUHJveHkoY29tbXVuaWNhdGlvblByb3ZpZGVyLCB7XG4gICAgICAvLyBzdHJhaWdodCB1cCBsaWUgdGhhdCB3ZSBkZWxldGVkIHRoZSBwcm9wZXJ0eSBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGluIHN0cmljdCBtb2RlXG4gICAgICBkZWxldGVQcm9wZXJ0eTogKCkgPT4gdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm94aWVkSW5QYWdlUHJvdmlkZXI7XG4gICAgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIgPSBwcm94aWVkQ29tbXVuaWNhdGlvblByb3ZpZGVyO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtpblBhZ2VQcm92aWRlci5faW5pdGlhbGl6ZVN0YXRlKCksIGNvbW11bmljYXRpb25Qcm92aWRlci5faW5pdGlhbGl6ZVN0YXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvdmlkZXJQYXJhbXMpLCB7fSwge1xuICAgICAgZGFwcFN0b3JhZ2VLZXk6IHRoaXMuZGFwcFN0b3JhZ2VLZXksXG4gICAgICB0b3J1c0FsZXJ0Q29udGFpbmVyOiB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIsXG4gICAgICB0b3J1c0lmcmFtZTogdGhpcy50b3J1c0lmcmFtZVxuICAgIH0pKV0pO1xuICAgIGxvZy5kZWJ1ZyhcIlRvcnVzIC0gaW5qZWN0ZWQgcHJvdmlkZXJcIik7XG4gIH1cbn1cblxuZXhwb3J0IHsgQlVUVE9OX1BPU0lUSU9OLCBMT0dJTl9QUk9WSURFUiwgUEFZTUVOVF9QUk9WSURFUiwgVE9SVVNfQlVJTERfRU5WLCBUb3J1c0luUGFnZVByb3ZpZGVyLCBUb3J1cyBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiX29iamVjdFNwcmVhZCIsIl9kZWZpbmVQcm9wZXJ0eSIsIlB1YmxpY0tleSIsImNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUiLCJDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUyIsIkNPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUyIsIlBST1ZJREVSX0pSUENfTUVUSE9EUyIsIlBST1ZJREVSX05PVElGSUNBVElPTlMiLCJzZXRBUElLZXkiLCJTYWZlRXZlbnRFbWl0dGVyIiwiT2JqZWN0TXVsdGlwbGV4IiwiY3JlYXRlU3RyZWFtTWlkZGxld2FyZSIsIkpSUENFbmdpbmUiLCJjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSIsImdldFJwY1Byb21pc2VDYWxsYmFjayIsIkJhc2VQb3N0TWVzc2FnZVN0cmVhbSIsImV0aEVycm9ycyIsIkV0aGVyZXVtUnBjRXJyb3IiLCJwdW1wIiwibG9nbGV2ZWwiLCJkZXF1YWwiLCJ2ZXJzaW9uIiwiaXNTdHJlYW0iLCJzdHJlYW0iLCJwaXBlIiwiaXNXcml0YWJsZVN0cmVhbSIsIndyaXRhYmxlIiwiX3dyaXRlIiwiX3dyaXRhYmxlU3RhdGUiLCJpc1JlYWRhYmxlU3RyZWFtIiwicmVhZGFibGUiLCJfcmVhZCIsIl9yZWFkYWJsZVN0YXRlIiwiaXNEdXBsZXhTdHJlYW0iLCJtZXNzYWdlcyIsImVycm9ycyIsImRpc2Nvbm5lY3RlZCIsInBlcm1hbmVudGx5RGlzY29ubmVjdGVkIiwidW5zdXBwb3J0ZWRTeW5jIiwibWV0aG9kIiwiaW52YWxpZER1cGxleFN0cmVhbSIsImludmFsaWRPcHRpb25zIiwibWF4RXZlbnRMaXN0ZW5lcnMiLCJpbnZhbGlkUmVxdWVzdEFyZ3MiLCJpbnZhbGlkUmVxdWVzdE1ldGhvZCIsImludmFsaWRSZXF1ZXN0UGFyYW1zIiwiaW52YWxpZExvZ2dlck9iamVjdCIsImludmFsaWRMb2dnZXJNZXRob2QiLCJpbmZvIiwiY29ubmVjdGVkIiwiY2hhaW5JZCIsIndhcm5pbmdzIiwiUEFZTUVOVF9QUk9WSURFUiIsIk1PT05QQVkiLCJXWVJFIiwiUkFNUE5FVFdPUksiLCJYQU5QT09MIiwiTUVSQ1VSWU8iLCJUUkFOU0FLIiwiVE9SVVNfQlVJTERfRU5WIiwiUFJPRFVDVElPTiIsIkRFVkVMT1BNRU5UIiwiVEVTVElORyIsIkJVVFRPTl9QT1NJVElPTiIsIkJPVFRPTV9MRUZUIiwiVE9QX0xFRlQiLCJCT1RUT01fUklHSFQiLCJUT1BfUklHSFQiLCJMT0dJTl9QUk9WSURFUiIsIkdPT0dMRSIsIkZBQ0VCT09LIiwiUkVERElUIiwiRElTQ09SRCIsIlRXSVRDSCIsIkFQUExFIiwiTElORSIsIkdJVEhVQiIsIktBS0FPIiwiTElOS0VESU4iLCJUV0lUVEVSIiwiV0VJQk8iLCJXRUNIQVQiLCJFTUFJTF9QQVNTV09SRExFU1MiLCJ0cmFuc2xhdGlvbnMiLCJlbiIsImVtYmVkIiwiY29udGludWUiLCJhY3Rpb25SZXF1aXJlZCIsInBlbmRpbmdBY3Rpb24iLCJjb29raWVzUmVxdWlyZWQiLCJlbmFibGVDb29raWVzIiwiY2xpY2tIZXJlIiwiZGUiLCJqYSIsImtvIiwiemgiLCJjb25maWd1cmF0aW9uIiwic3VwcG9ydGVkVmVyaWZpZXJMaXN0IiwiYXBpIiwicHJvZFRvcnVzVXJsIiwibG9jYWxTdG9yYWdlS2V5UHJlZml4IiwibG9nIiwiZ2V0TG9nZ2VyIiwiY3JlYXRlRXJyb3JNaWRkbGV3YXJlIiwicmVxIiwicmVzIiwibmV4dCIsImVycm9yIiwicnBjIiwiaW52YWxpZFJlcXVlc3QiLCJtZXNzYWdlIiwiZGF0YSIsImRvbmUiLCJsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZyIsInJlbW90ZUxhYmVsIiwiZW1pdHRlciIsIndhcm5pbmdNc2ciLCJzdGFjayIsIndhcm4iLCJsaXN0ZW5lckNvdW50IiwiZW1pdCIsImdldFdpbmRvd0lkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJnZXRUb3J1c1VybCIsImJ1aWxkRW52IiwidG9ydXNVcmwiLCJsb2dMZXZlbCIsImdldFVzZXJMYW5ndWFnZSIsInVzZXJMYW5ndWFnZSIsIndpbmRvdyIsIm5hdmlnYXRvciIsImxhbmd1YWdlIiwidXNlckxhbmd1YWdlcyIsInNwbGl0IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVyIsImhlaWdodCIsIndpZHRoIiwiRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XIiwiRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1ciLCJGRUFUVVJFU19DT05GSVJNX1dJTkRPVyIsInN0b3JhZ2VBdmFpbGFibGUiLCJ0eXBlIiwic3RvcmFnZSIsIngiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImUiLCJjb2RlIiwibmFtZSIsImxlbmd0aCIsImdldFBvcHVwRmVhdHVyZXMiLCJfcmVmIiwidyIsImgiLCJkdWFsU2NyZWVuTGVmdCIsInNjcmVlbkxlZnQiLCJ1bmRlZmluZWQiLCJzY3JlZW5YIiwiZHVhbFNjcmVlblRvcCIsInNjcmVlblRvcCIsInNjcmVlblkiLCJpbm5lcldpZHRoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsInNjcmVlbiIsImlubmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic3lzdGVtWm9vbSIsImxlZnQiLCJhYnMiLCJ0b3AiLCJmZWF0dXJlcyIsIkJhc2VQcm92aWRlciIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvblN0cmVhbSIsImpzb25ScGNTdHJlYW1OYW1lIiwiRXJyb3IiLCJpc1RvcnVzIiwic2V0TWF4TGlzdGVuZXJzIiwiX2hhbmRsZUNvbm5lY3QiLCJiaW5kIiwiX2hhbmRsZURpc2Nvbm5lY3QiLCJfaGFuZGxlU3RyZWFtRGlzY29ubmVjdCIsIl9ycGNSZXF1ZXN0IiwiX2luaXRpYWxpemVTdGF0ZSIsInJlcXVlc3QiLCJzZW5kQXN5bmMiLCJtdXgiLCJpZ25vcmVTdHJlYW0iLCJqc29uUnBjQ29ubmVjdGlvbiIsImNyZWF0ZVN0cmVhbSIsInJwY0VuZ2luZSIsInB1c2giLCJvcmlnaW4iLCJsb2NhdGlvbiIsIm1pZGRsZXdhcmUiLCJfcnBjRW5naW5lIiwianNvblJwY0Nvbm5lY3Rpb25FdmVudHMiLCJldmVudHMiLCJhcmdzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyYW1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzZW5kIiwicGF5bG9hZCIsImNhbGxiYWNrIiwic3RyZWFtTmFtZSIsImh0bWxUb0VsZW1lbnQiLCJodG1sIiwidGVtcGxhdGUiLCJjcmVhdGVFbGVtZW50IiwidHJpbW1lZEh0bWwiLCJ0cmltIiwiaW5uZXJIVE1MIiwiY29udGVudCIsImZpcnN0Q2hpbGQiLCJpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UiLCJ0cmFuc2FjdGlvbiIsIlBvcHVwSGFuZGxlciIsInVybCIsInRhcmdldCIsInRpbWVvdXQiLCJ3aW5kb3dUaW1lciIsImlDbG9zZWRXaW5kb3ciLCJfc2V0dXBUaW1lciIsIk51bWJlciIsInNldEludGVydmFsIiwiY2xvc2VkIiwiY2xlYXJJbnRlcnZhbCIsInNldFRpbWVvdXQiLCJvcGVuIiwiaHJlZiIsImZvY3VzIiwiY2xvc2UiLCJyZWRpcmVjdCIsImxvY2F0aW9uUmVwbGFjZU9uUmVkaXJlY3QiLCJyZXBsYWNlIiwiVG9ydXNDb21tdW5pY2F0aW9uUHJvdmlkZXIiLCJfc3RhdGUiLCJfZGVmYXVsdFN0YXRlIiwiZGFwcFN0b3JhZ2VLZXkiLCJsYW5ndWFnZVRyYW5zbGF0aW9ucyIsImVtYmVkVHJhbnNsYXRpb25zIiwid2luZG93UmVmcyIsIm9uIiwiaXNDb25uZWN0ZWQiLCJub3RpZmljYXRpb25IYW5kbGVyIiwiSUZSQU1FX1NUQVRVUyIsImlzRnVsbFNjcmVlbiIsInJpZCIsIl9kaXNwbGF5SWZyYW1lIiwiaXNGdWxsIiwid2luZG93SWQiLCJfY3JlYXRlUG9wdXBCbG9ja0FsZXJ0IiwiQ0xPU0VfV0lORE9XIiwiX2hhbmRsZUNsb3NlV2luZG93IiwiVVNFUl9MT0dHRURfSU4iLCJjdXJyZW50TG9naW5Qcm92aWRlciIsImlzTG9nZ2VkSW4iLCJVU0VSX0xPR0dFRF9PVVQiLCJpc0lGcmFtZUZ1bGxTY3JlZW4iLCJ0b3J1c0FsZXJ0Q29udGFpbmVyIiwidG9ydXNJZnJhbWUiLCJhZGRFdmVudExpc3RlbmVyIiwiR0VUX1BST1ZJREVSX1NUQVRFIiwiaW5pdGlhbGl6ZWQiLCJfaGFuZGxlV2luZG93IiwiYXJndW1lbnRzIiwiZmluYWxVcmwiLCJVUkwiLCJoYXNoIiwiaGFuZGxlZFdpbmRvdyIsIm9uY2UiLCJDTE9TRURfV0lORE9XIiwic3R5bGUiLCJkaXNwbGF5IiwidG9ydXNXaWRnZXRWaXNpYmlsaXR5IiwiYnV0dG9uUG9zaXRpb24iLCJyaWdodCIsImJvdHRvbSIsImFzc2lnbiIsImhpZGVUb3J1c0J1dHRvbiIsInNob3dUb3J1c0J1dHRvbiIsImNiIiwiX3BheWxvYWQiLCJqc29ucnBjIiwidHJ5V2luZG93SGFuZGxlIiwiZGVidWciLCJpc1JlY292ZXJhYmxlIiwiZXJyb3JNZXNzYWdlIiwiaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCIsImxvZ29VcmwiLCJnZXRMb2dvVXJsIiwidG9ydXNBbGVydCIsInN1Y2Nlc3NBbGVydCIsImJ0bkNvbnRhaW5lciIsImFwcGVuZENoaWxkIiwiYmluZE9uTG9hZCIsInJlbW92ZSIsImNoaWxkcmVuIiwiYXR0YWNoT25Mb2FkIiwiaGFzRW1pdHRlZENvbm5lY3Rpb24iLCJUb3J1c0luUGFnZVByb3ZpZGVyIiwic2VsZWN0ZWRBZGRyZXNzIiwiX2hhbmRsZUFjY291bnRzQ2hhbmdlZCIsIl9oYW5kbGVDaGFpbkNoYW5nZWQiLCJfaGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkIiwianNvblJwY05vdGlmaWNhdGlvbkhhbmRsZXIiLCJBQ0NPVU5UU19DSEFOR0VEIiwiVU5MT0NLX1NUQVRFX0NIQU5HRUQiLCJDSEFJTl9DSEFOR0VEIiwiYWNjb3VudHMiLCJpc1VubG9ja2VkIiwiaXNJbnRlcm5hbCIsImVyciIsInJlc3VsdCIsImhhbmRsZSIsImlzRXRoQWNjb3VudHMiLCJmaW5hbEFjY291bnRzIiwiYWNjb3VudCIsImltZ0V4aXN0cyIsImltZyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJnZXRTaXRlTmFtZSIsInNpdGVOYW1lIiwicXVlcnlTZWxlY3RvciIsIm1ldGFUaXRsZSIsInRpdGxlIiwiaG9zdG5hbWUiLCJnZXRTaXRlSWNvbiIsImljb24iLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImZpbmQiLCJfaWNvbiIsIkJvb2xlYW4iLCJnZXRTaXRlTWV0YWRhdGEiLCJQUk9WSURFUl9VTlNBRkVfTUVUSE9EUyIsIkNPTU1VTklDQVRJT05fVU5TQUZFX01FVEhPRFMiLCJTRVRfUFJPVklERVIiLCJpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSIsInByZUxvYWRJZnJhbWUiLCJ0b3J1c0lmcmFtZUh0bWwiLCJjcm9zc09yaWdpbiIsInJlbCIsInJlbExpc3QiLCJzdXBwb3J0cyIsImhlYWQiLCJUb3J1cyIsIm1vZGFsWkluZGV4IiwiaXNJbml0aWFsaXplZCIsInJlcXVlc3RlZExvZ2luUHJvdmlkZXIiLCJhbGVydFpJbmRleCIsImNvbW11bmljYXRpb25Qcm92aWRlciIsImluaXQiLCJlbmFibGVMb2dnaW5nIiwibmV0d29yayIsInVzZUxvY2FsU3RvcmFnZSIsImFwaUtleSIsImV4dHJhUGFyYW1zIiwid2hpdGVMYWJlbCIsImVuYWJsZUFsbCIsInNldERlZmF1bHRMZXZlbCIsImRpc2FibGVBbGwiLCJoYW5kbGVEYXBwU3RvcmFnZUtleSIsInRvcnVzSWZyYW1lVXJsIiwicGF0aG5hbWUiLCJlbmRzV2l0aCIsImhhc2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJzdHlsZUxpbmsiLCJkYXBwTWV0YWRhdGEiLCJjb250ZW50V2luZG93IiwicG9zdE1lc3NhZ2UiLCJfc2V0dXBXZWIzIiwidG9wdXBIaWRlIiwiaXNUb3B1cEhpZGRlbiIsInRvcnVzIiwiYm9keSIsImxvZ2luIiwibG9naW5Qcm92aWRlciIsInByb3ZpZGVyIiwibG9naW5faGludCIsImxvZ2luV2l0aFByaXZhdGVLZXkiLCJsb2dpblBhcmFtcyIsInByaXZhdGVLZXkiLCJ1c2VySW5mbyIsInN1Y2Nlc3MiLCJsb2dvdXQiLCJMT0dPVVQiLCJjbGVhblVwIiwiY2xlYXJJbml0IiwiaXNFbGVtZW50IiwiZWxlbWVudCIsIkVsZW1lbnQiLCJEb2N1bWVudCIsImNvbnRhaW5zIiwic2V0UHJvdmlkZXIiLCJzaG93V2FsbGV0IiwicGF0aCIsImluc3RhbmNlSWQiLCJXQUxMRVRfSU5TVEFOQ0VfSUQiLCJmaW5hbFBhdGgiLCJzZWFyY2hQYXJhbXMiLCJrZXlzIiwiZm9yRWFjaCIsIndhbGxldFdpbmRvdyIsImdldFVzZXJJbmZvIiwidXNlckluZm9SZXNwb25zZSIsIlVTRVJfSU5GTyIsImluaXRpYXRlVG9wdXAiLCJ0b3B1cFJlc3BvbnNlIiwiVE9QVVAiLCJnZXRBY2NvdW50cyIsInJlc3BvbnNlIiwic2VuZFRyYW5zYWN0aW9uIiwiaXNMZWdhY3lUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZSIsInJlcXVpcmVBbGxTaWduYXR1cmVzIiwiQnVmZmVyIiwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsIm9wdGlvbnMiLCJzaWduYXR1cmUiLCJzaWduVHJhbnNhY3Rpb24iLCJzZXJpYWxpemVNZXNzYWdlIiwibWVzc2FnZU9ubHkiLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJwdWJsaWNLZXkiLCJhZGRTaWduYXR1cmUiLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwidHJhbnNhY3Rpb25zIiwiZW5jb2RlZE1lc3NhZ2UiLCJtYXAiLCJ0eCIsInJlc3BvbnNlcyIsInNpZ25hdHVyZXMiLCJpdGVtIiwiaWR4Iiwic2lnbk1lc3NhZ2UiLCJnZXRHYXNsZXNzUHVibGljS2V5IiwibG9jYWxTdG9yYWdlS2V5Iiwic3RvcmVkS2V5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImdlbmVyYXRlZEtleSIsInByb3ZpZGVyUGFyYW1zIiwicHJvdmlkZXJTdHJlYW0iLCJ0YXJnZXRXaW5kb3ciLCJjb21tdW5pY2F0aW9uU3RyZWFtIiwiaW5QYWdlUHJvdmlkZXIiLCJpbmNsdWRlcyIsImRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIiLCJtIiwib3JpZ2luYWxNZXRob2QiLCJzZWxmIiwicHJvdmlkZXJGdW5jIiwidGhlbiIsImNhdGNoIiwiYXBwbHkiLCJwcm94aWVkSW5QYWdlUHJvdmlkZXIiLCJQcm94eSIsImRlbGV0ZVByb3BlcnR5IiwicHJveGllZENvbW11bmljYXRpb25Qcm92aWRlciIsImFsbCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js\n");

/***/ })

};
;