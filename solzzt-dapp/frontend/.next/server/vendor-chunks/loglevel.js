"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/loglevel";
exports.ids = ["vendor-chunks/loglevel"];
exports.modules = {

/***/ "(ssr)/./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    \"use strict\";\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n    var _loggersByName = {};\n    var defaultLogger = null;\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \"function\") {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [\n                        obj,\n                        arguments\n                    ]);\n                };\n            }\n        }\n    }\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [\n                    console,\n                    arguments\n                ]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \"debug\") {\n            methodName = \"log\";\n        }\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === \"trace\" && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \"log\");\n        } else {\n            return noop;\n        }\n    }\n    // These private functions always need `this` to be set properly\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */ var level = this.getLevel();\n        // Replace the actual methods.\n        for(var i = 0; i < logMethods.length; i++){\n            var methodName = logMethods[i];\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n        }\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function() {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, factory) {\n        // Private instance variables.\n        var self = this;\n        /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */ var inheritedLevel;\n        /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */ var defaultLevel;\n        /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */ var userLevel;\n        var storageKey = \"loglevel\";\n        if (typeof name === \"string\") {\n            storageKey += \":\" + name;\n        } else if (typeof name === \"symbol\") {\n            storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n            var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage[storageKey] = levelName;\n                return;\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n            } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n            var storedLevel;\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            try {\n                storedLevel = window.localStorage[storageKey];\n            } catch (ignore) {}\n            // Fallback to cookies if local storage gives us nothing\n            if (typeof storedLevel === undefinedType) {\n                try {\n                    var cookie = window.document.cookie;\n                    var cookieName = encodeURIComponent(storageKey);\n                    var location = cookie.indexOf(cookieName + \"=\");\n                    if (location !== -1) {\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n                    }\n                } catch (ignore) {}\n            }\n            // If the stored level is not valid, treat it as if nothing was stored.\n            if (self.levels[storedLevel] === undefined) {\n                storedLevel = undefined;\n            }\n            return storedLevel;\n        }\n        function clearPersistedLevel() {\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage.removeItem(storageKey);\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n            } catch (ignore) {}\n        }\n        function normalizeLevel(input) {\n            var level = input;\n            if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                level = self.levels[level.toUpperCase()];\n            }\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                return level;\n            } else {\n                throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n            }\n        }\n        /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self.name = name;\n        self.levels = {\n            \"TRACE\": 0,\n            \"DEBUG\": 1,\n            \"INFO\": 2,\n            \"WARN\": 3,\n            \"ERROR\": 4,\n            \"SILENT\": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function() {\n            if (userLevel != null) {\n                return userLevel;\n            } else if (defaultLevel != null) {\n                return defaultLevel;\n            } else {\n                return inheritedLevel;\n            }\n        };\n        self.setLevel = function(level, persist) {\n            userLevel = normalizeLevel(level);\n            if (persist !== false) {\n                persistLevelIfPossible(userLevel);\n            }\n            // NOTE: in v2, this should call rebuild(), which updates children.\n            return replaceLoggingMethods.call(self);\n        };\n        self.setDefaultLevel = function(level) {\n            defaultLevel = normalizeLevel(level);\n            if (!getPersistedLevel()) {\n                self.setLevel(level, false);\n            }\n        };\n        self.resetLevel = function() {\n            userLevel = null;\n            clearPersistedLevel();\n            replaceLoggingMethods.call(self);\n        };\n        self.enableAll = function(persist) {\n            self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function(persist) {\n            self.setLevel(self.levels.SILENT, persist);\n        };\n        self.rebuild = function() {\n            if (defaultLogger !== self) {\n                inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n            }\n            replaceLoggingMethods.call(self);\n            if (defaultLogger === self) {\n                for(var childName in _loggersByName){\n                    _loggersByName[childName].rebuild();\n                }\n            }\n        };\n        // Initialize all the internal levels.\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n        var initialLevel = getPersistedLevel();\n        if (initialLevel != null) {\n            userLevel = normalizeLevel(initialLevel);\n        }\n        replaceLoggingMethods.call(self);\n    }\n    /*\n     *\n     * Top-level API\n     *\n     */ defaultLogger = new Logger();\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n    // Grab the current global log variable in case of overwrite\n    var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n            window.log = _log;\n        }\n        return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n    // ES6 default export, for compatibility\n    defaultLogger[\"default\"] = defaultLogger;\n    return defaultLogger;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7QUFLQSxHQUNDLFVBQVVBLElBQUksRUFBRUMsVUFBVTtJQUN2QjtJQUNBLElBQUksSUFBMEMsRUFBRTtRQUM1Q0Msb0NBQU9ELFVBQVVBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ3RCLE9BQU8sRUFJTjtBQUNMLEdBQUUsUUFBTTtJQUNKO0lBRUEsMERBQTBEO0lBQzFELElBQUlNLE9BQU8sWUFBWTtJQUN2QixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMsT0FBTyxnQkFBbUJELGlCQUFtQixPQUFPRSxPQUFPQyxTQUFTLEtBQUtILGlCQUN6RSxrQkFBa0JJLElBQUksQ0FBQ0YsT0FBT0MsU0FBUyxDQUFDRSxTQUFTO0lBR3JELElBQUlDLGFBQWE7UUFDYjtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFFRCxJQUFJQyxpQkFBaUIsQ0FBQztJQUN0QixJQUFJQyxnQkFBZ0I7SUFFcEIsZ0VBQWdFO0lBQ2hFLFNBQVNDLFdBQVdDLEdBQUcsRUFBRUMsVUFBVTtRQUMvQixJQUFJQyxTQUFTRixHQUFHLENBQUNDLFdBQVc7UUFDNUIsSUFBSSxPQUFPQyxPQUFPQyxJQUFJLEtBQUssWUFBWTtZQUNuQyxPQUFPRCxPQUFPQyxJQUFJLENBQUNIO1FBQ3ZCLE9BQU87WUFDSCxJQUFJO2dCQUNBLE9BQU9JLFNBQVNDLFNBQVMsQ0FBQ0YsSUFBSSxDQUFDRyxJQUFJLENBQUNKLFFBQVFGO1lBQ2hELEVBQUUsT0FBT08sR0FBRztnQkFDUiw2REFBNkQ7Z0JBQzdELE9BQU87b0JBQ0gsT0FBT0gsU0FBU0MsU0FBUyxDQUFDRyxLQUFLLENBQUNBLEtBQUssQ0FBQ04sUUFBUTt3QkFBQ0Y7d0JBQUtTO3FCQUFVO2dCQUNsRTtZQUNKO1FBQ0o7SUFDSjtJQUVBLCtFQUErRTtJQUMvRSxTQUFTQztRQUNMLElBQUlDLFFBQVF2QixHQUFHLEVBQUU7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Y0FBYyxDQUFDd0IsS0FBSztRQUNqQyxJQUFJLENBQUMrQyxRQUFRO1lBQ1RBLFNBQVN2RSxjQUFjLENBQUN3QixLQUFLLEdBQUcsSUFBSVEsT0FDaENSLE1BQ0F2QixjQUFjc0IsYUFBYTtRQUVuQztRQUNBLE9BQU9nRDtJQUNYO0lBRUEsNERBQTREO0lBQzVELElBQUlDLE9BQU8sZ0JBQW1CL0UsZ0JBQWlCRSxPQUFPSixHQUFHLEdBQUcwQjtJQUM1RGhCLGNBQWN3RSxVQUFVLEdBQUc7UUFDdkIsSUFBSSxnQkFBa0JoRixpQkFDZkUsT0FBT0osR0FBRyxLQUFLVSxlQUFlO1lBQ2pDTixPQUFPSixHQUFHLEdBQUdpRjtRQUNqQjtRQUVBLE9BQU92RTtJQUNYO0lBRUFBLGNBQWN5RSxVQUFVLEdBQUcsU0FBU0E7UUFDaEMsT0FBTzFFO0lBQ1g7SUFFQSx3Q0FBd0M7SUFDeENDLGFBQWEsQ0FBQyxVQUFVLEdBQUdBO0lBRTNCLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2x6enQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzY4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG51bGw7XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMoKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuZ2V0TGV2ZWwoKTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBhY3R1YWwgbWV0aG9kcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuXG4gICAgICAgIC8vIFJldHVybiBhbnkgaW1wb3J0YW50IHdhcm5pbmdzLlxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCB0aGlzLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgX2xldmVsLCBfbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBmYWN0b3J5KSB7XG4gICAgICAvLyBQcml2YXRlIGluc3RhbmNlIHZhcmlhYmxlcy5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGxldmVsIGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IGxvZ2dlciAob3IgYSBnbG9iYWwgZGVmYXVsdCkuIFdlXG4gICAgICAgKiBjYWNoZSB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gZGVsZWdhdGluZyB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgc3RheXNcbiAgICAgICAqIGluIHN5bmMgd2l0aCB0aGUgYWN0dWFsIGxvZ2dpbmcgbWV0aG9kcyB0aGF0IHdlIGhhdmUgaW5zdGFsbGVkICh0aGVcbiAgICAgICAqIHBhcmVudCBjb3VsZCBjaGFuZ2UgbGV2ZWxzIGJ1dCB3ZSBtaWdodCBub3QgaGF2ZSByZWJ1aWx0IHRoZSBsb2dnZXJzXG4gICAgICAgKiBpbiB0aGlzIGNoaWxkIHlldCkuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB2YXIgaW5oZXJpdGVkTGV2ZWw7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkZWZhdWx0IGxldmVsIGZvciB0aGlzIGxvZ2dlciwgaWYgYW55LiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXG4gICAgICAgKiBgaW5oZXJpdGVkTGV2ZWxgLlxuICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxuICAgICAgICovXG4gICAgICB2YXIgZGVmYXVsdExldmVsO1xuICAgICAgLyoqXG4gICAgICAgKiBBIHVzZXItc3BlY2lmaWMgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXG4gICAgICAgKiBgZGVmYXVsdExldmVsYC5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICAgICAqL1xuICAgICAgdmFyIHVzZXJMZXZlbDtcblxuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llTmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKGNvb2tpZU5hbWUgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZS5zbGljZShsb2NhdGlvbiArIGNvb2tpZU5hbWUubGVuZ3RoICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICApWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhclBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxldmVsKGlucHV0KSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gaW5wdXQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHVzZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlckxldmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdExldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0TGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmhlcml0ZWRMZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xuICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKHVzZXJMZXZlbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTk9URTogaW4gdjIsIHRoaXMgc2hvdWxkIGNhbGwgcmVidWlsZCgpLCB3aGljaCB1cGRhdGVzIGNoaWxkcmVuLlxuICAgICAgICAgIHJldHVybiByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgZGVmYXVsdExldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVzZXJMZXZlbCA9IG51bGw7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5yZWJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG5cbiAgICAgICAgICBpZiAoZGVmYXVsdExvZ2dlciA9PT0gc2VsZikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBjaGlsZE5hbWUgaW4gX2xvZ2dlcnNCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICBfbG9nZ2Vyc0J5TmFtZVtjaGlsZE5hbWVdLnJlYnVpbGQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgYWxsIHRoZSBpbnRlcm5hbCBsZXZlbHMuXG4gICAgICBpbmhlcml0ZWRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKFxuICAgICAgICAgIGRlZmF1bHRMb2dnZXIgPyBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkgOiBcIldBUk5cIlxuICAgICAgKTtcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwoaW5pdGlhbExldmVsKTtcbiAgICAgIH1cbiAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiJdLCJuYW1lcyI6WyJyb290IiwiZGVmaW5pdGlvbiIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJsb2ciLCJub29wIiwidW5kZWZpbmVkVHlwZSIsImlzSUUiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwidXNlckFnZW50IiwibG9nTWV0aG9kcyIsIl9sb2dnZXJzQnlOYW1lIiwiZGVmYXVsdExvZ2dlciIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImUiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyYWNlRm9ySUUiLCJjb25zb2xlIiwidHJhY2UiLCJyZWFsTWV0aG9kIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJnZXRMZXZlbCIsImkiLCJsZW5ndGgiLCJtZXRob2RGYWN0b3J5IiwibmFtZSIsImRlYnVnIiwibGV2ZWxzIiwiU0lMRU5UIiwiZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyIsImRlZmF1bHRNZXRob2RGYWN0b3J5IiwiX2xldmVsIiwiX2xvZ2dlck5hbWUiLCJMb2dnZXIiLCJmYWN0b3J5Iiwic2VsZiIsImluaGVyaXRlZExldmVsIiwiZGVmYXVsdExldmVsIiwidXNlckxldmVsIiwic3RvcmFnZUtleSIsInBlcnNpc3RMZXZlbElmUG9zc2libGUiLCJsZXZlbE51bSIsImxldmVsTmFtZSIsInRvVXBwZXJDYXNlIiwibG9jYWxTdG9yYWdlIiwiaWdub3JlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRQZXJzaXN0ZWRMZXZlbCIsInN0b3JlZExldmVsIiwiY29va2llTmFtZSIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImNsZWFyUGVyc2lzdGVkTGV2ZWwiLCJyZW1vdmVJdGVtIiwibm9ybWFsaXplTGV2ZWwiLCJpbnB1dCIsIlR5cGVFcnJvciIsInNldExldmVsIiwicGVyc2lzdCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJyZWJ1aWxkIiwiY2hpbGROYW1lIiwiaW5pdGlhbExldmVsIiwiZ2V0TG9nZ2VyIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJnZXRMb2dnZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/loglevel/lib/loglevel.js\n");

/***/ })

};
;